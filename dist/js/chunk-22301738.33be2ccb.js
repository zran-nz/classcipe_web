(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-22301738"],{"104d":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ install_install; });\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(\"22b4\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(\"7fae\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\nvar DataZoomModel = __webpack_require__(\"3a56\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/component.js\nvar component = __webpack_require__(\"8918\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\nvar InsideZoomModel_InsideZoomModel =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(InsideZoomModel, _super);\n\n  function InsideZoomModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = InsideZoomModel.type;\n    return _this;\n  }\n\n  InsideZoomModel.type = 'dataZoom.inside';\n  InsideZoomModel.defaultOption = Object(component[\"d\" /* inheritDefaultOption */])(DataZoomModel[\"a\" /* default */].defaultOption, {\n    disabled: false,\n    zoomLock: false,\n    zoomOnMouseWheel: true,\n    moveOnMouseMove: true,\n    moveOnMouseWheel: false,\n    preventDefaultMouseMove: true\n  });\n  return InsideZoomModel;\n}(DataZoomModel[\"a\" /* default */]);\n\n/* harmony default export */ var dataZoom_InsideZoomModel = (InsideZoomModel_InsideZoomModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\nvar DataZoomView = __webpack_require__(\"7dcf\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/sliderMove.js\nvar sliderMove = __webpack_require__(\"ef6a\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Eventful.js\nvar Eventful = __webpack_require__(\"6fd3\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/event.js\nvar core_event = __webpack_require__(\"607d\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/interactionMutex.js\nvar interactionMutex = __webpack_require__(\"a4fe\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(\"6d8b\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/helper/RoamController.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n;\n\nvar RoamController_RoamController =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(RoamController, _super);\n\n  function RoamController(zr) {\n    var _this = _super.call(this) || this;\n\n    _this._zr = zr; // Avoid two roamController bind the same handler\n\n    var mousedownHandler = Object(util[\"c\" /* bind */])(_this._mousedownHandler, _this);\n    var mousemoveHandler = Object(util[\"c\" /* bind */])(_this._mousemoveHandler, _this);\n    var mouseupHandler = Object(util[\"c\" /* bind */])(_this._mouseupHandler, _this);\n    var mousewheelHandler = Object(util[\"c\" /* bind */])(_this._mousewheelHandler, _this);\n    var pinchHandler = Object(util[\"c\" /* bind */])(_this._pinchHandler, _this);\n    /**\n     * Notice: only enable needed types. For example, if 'zoom'\n     * is not needed, 'zoom' should not be enabled, otherwise\n     * default mousewheel behaviour (scroll page) will be disabled.\n     */\n\n    _this.enable = function (controlType, opt) {\n      // Disable previous first\n      this.disable();\n      this._opt = Object(util[\"i\" /* defaults */])(Object(util[\"d\" /* clone */])(opt) || {}, {\n        zoomOnMouseWheel: true,\n        moveOnMouseMove: true,\n        // By default, wheel do not trigger move.\n        moveOnMouseWheel: false,\n        preventDefaultMouseMove: true\n      });\n\n      if (controlType == null) {\n        controlType = true;\n      }\n\n      if (controlType === true || controlType === 'move' || controlType === 'pan') {\n        zr.on('mousedown', mousedownHandler);\n        zr.on('mousemove', mousemoveHandler);\n        zr.on('mouseup', mouseupHandler);\n      }\n\n      if (controlType === true || controlType === 'scale' || controlType === 'zoom') {\n        zr.on('mousewheel', mousewheelHandler);\n        zr.on('pinch', pinchHandler);\n      }\n    };\n\n    _this.disable = function () {\n      zr.off('mousedown', mousedownHandler);\n      zr.off('mousemove', mousemoveHandler);\n      zr.off('mouseup', mouseupHandler);\n      zr.off('mousewheel', mousewheelHandler);\n      zr.off('pinch', pinchHandler);\n    };\n\n    return _this;\n  }\n\n  RoamController.prototype.isDragging = function () {\n    return this._dragging;\n  };\n\n  RoamController.prototype.isPinching = function () {\n    return this._pinching;\n  };\n\n  RoamController.prototype.setPointerChecker = function (pointerChecker) {\n    this.pointerChecker = pointerChecker;\n  };\n\n  RoamController.prototype.dispose = function () {\n    this.disable();\n  };\n\n  RoamController.prototype._mousedownHandler = function (e) {\n    if (core_event[\"d\" /* isMiddleOrRightButtonOnMouseUpDown */](e) || e.target && e.target.draggable) {\n      return;\n    }\n\n    var x = e.offsetX;\n    var y = e.offsetY; // Only check on mosedown, but not mousemove.\n    // Mouse can be out of target when mouse moving.\n\n    if (this.pointerChecker && this.pointerChecker(e, x, y)) {\n      this._x = x;\n      this._y = y;\n      this._dragging = true;\n    }\n  };\n\n  RoamController.prototype._mousemoveHandler = function (e) {\n    if (!this._dragging || !isAvailableBehavior('moveOnMouseMove', e, this._opt) || e.gestureEvent === 'pinch' || interactionMutex[\"a\" /* isTaken */](this._zr, 'globalPan')) {\n      return;\n    }\n\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var oldX = this._x;\n    var oldY = this._y;\n    var dx = x - oldX;\n    var dy = y - oldY;\n    this._x = x;\n    this._y = y;\n    this._opt.preventDefaultMouseMove && core_event[\"g\" /* stop */](e.event);\n    trigger(this, 'pan', 'moveOnMouseMove', e, {\n      dx: dx,\n      dy: dy,\n      oldX: oldX,\n      oldY: oldY,\n      newX: x,\n      newY: y,\n      isAvailableBehavior: null\n    });\n  };\n\n  RoamController.prototype._mouseupHandler = function (e) {\n    if (!core_event[\"d\" /* isMiddleOrRightButtonOnMouseUpDown */](e)) {\n      this._dragging = false;\n    }\n  };\n\n  RoamController.prototype._mousewheelHandler = function (e) {\n    var shouldZoom = isAvailableBehavior('zoomOnMouseWheel', e, this._opt);\n    var shouldMove = isAvailableBehavior('moveOnMouseWheel', e, this._opt);\n    var wheelDelta = e.wheelDelta;\n    var absWheelDeltaDelta = Math.abs(wheelDelta);\n    var originX = e.offsetX;\n    var originY = e.offsetY; // wheelDelta maybe -0 in chrome mac.\n\n    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {\n      return;\n    } // If both `shouldZoom` and `shouldMove` is true, trigger\n    // their event both, and the final behavior is determined\n    // by event listener themselves.\n\n\n    if (shouldZoom) {\n      // Convenience:\n      // Mac and VM Windows on Mac: scroll up: zoom out.\n      // Windows: scroll up: zoom in.\n      // FIXME: Should do more test in different environment.\n      // wheelDelta is too complicated in difference nvironment\n      // (https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel),\n      // although it has been normallized by zrender.\n      // wheelDelta of mouse wheel is bigger than touch pad.\n      var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;\n      var scale = wheelDelta > 0 ? factor : 1 / factor;\n      checkPointerAndTrigger(this, 'zoom', 'zoomOnMouseWheel', e, {\n        scale: scale,\n        originX: originX,\n        originY: originY,\n        isAvailableBehavior: null\n      });\n    }\n\n    if (shouldMove) {\n      // FIXME: Should do more test in different environment.\n      var absDelta = Math.abs(wheelDelta); // wheelDelta of mouse wheel is bigger than touch pad.\n\n      var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);\n      checkPointerAndTrigger(this, 'scrollMove', 'moveOnMouseWheel', e, {\n        scrollDelta: scrollDelta,\n        originX: originX,\n        originY: originY,\n        isAvailableBehavior: null\n      });\n    }\n  };\n\n  RoamController.prototype._pinchHandler = function (e) {\n    if (interactionMutex[\"a\" /* isTaken */](this._zr, 'globalPan')) {\n      return;\n    }\n\n    var scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n    checkPointerAndTrigger(this, 'zoom', null, e, {\n      scale: scale,\n      originX: e.pinchX,\n      originY: e.pinchY,\n      isAvailableBehavior: null\n    });\n  };\n\n  return RoamController;\n}(Eventful[\"a\" /* default */]);\n\nfunction checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {\n  if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {\n    // When mouse is out of roamController rect,\n    // default befavoius should not be be disabled, otherwise\n    // page sliding is disabled, contrary to expectation.\n    core_event[\"g\" /* stop */](e.event);\n    trigger(controller, eventName, behaviorToCheck, e, contollerEvent);\n  }\n}\n\nfunction trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {\n  // Also provide behavior checker for event listener, for some case that\n  // multiple components share one listener.\n  contollerEvent.isAvailableBehavior = Object(util[\"c\" /* bind */])(isAvailableBehavior, null, behaviorToCheck, e); // TODO should not have type issue.\n\n  controller.trigger(eventName, contollerEvent);\n} // settings: {\n//     zoomOnMouseWheel\n//     moveOnMouseMove\n//     moveOnMouseWheel\n// }\n// The value can be: true / false / 'shift' / 'ctrl' / 'alt'.\n\n\nfunction isAvailableBehavior(behaviorToCheck, e, settings) {\n  var setting = settings[behaviorToCheck];\n  return !behaviorToCheck || setting && (!Object(util[\"A\" /* isString */])(setting) || e.event[setting + 'Key']);\n}\n\n/* harmony default export */ var helper_RoamController = (RoamController_RoamController);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/throttle.js\nvar throttle = __webpack_require__(\"88b3\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar util_model = __webpack_require__(\"e0d3\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/helper.js\nvar helper = __webpack_require__(\"50e5\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/roams.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Only create one roam controller for each coordinate system.\n// one roam controller might be refered by two inside data zoom\n// components (for example, one for x and one for y). When user\n// pan or zoom, only dispatch one action for those data zoom\n// components.\n\n\n\n\n\nvar inner = Object(util_model[\"m\" /* makeInner */])();\nfunction setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {\n  inner(api).coordSysRecordMap.each(function (coordSysRecord) {\n    var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);\n\n    if (dzInfo) {\n      dzInfo.getRange = getRange;\n    }\n  });\n}\nfunction disposeCoordSysRecordIfNeeded(api, dataZoomModel) {\n  var coordSysRecordMap = inner(api).coordSysRecordMap;\n  var coordSysKeyArr = coordSysRecordMap.keys();\n\n  for (var i = 0; i < coordSysKeyArr.length; i++) {\n    var coordSysKey = coordSysKeyArr[i];\n    var coordSysRecord = coordSysRecordMap.get(coordSysKey);\n    var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;\n\n    if (dataZoomInfoMap) {\n      var dzUid = dataZoomModel.uid;\n      var dzInfo = dataZoomInfoMap.get(dzUid);\n\n      if (dzInfo) {\n        dataZoomInfoMap.removeKey(dzUid);\n\n        if (!dataZoomInfoMap.keys().length) {\n          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);\n        }\n      }\n    }\n  }\n}\n\nfunction disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {\n  if (coordSysRecord) {\n    coordSysRecordMap.removeKey(coordSysRecord.model.uid);\n    var controller = coordSysRecord.controller;\n    controller && controller.dispose();\n  }\n}\n\nfunction createCoordSysRecord(api, coordSysModel) {\n  // These init props will never change after record created.\n  var coordSysRecord = {\n    model: coordSysModel,\n    containsPoint: Object(util[\"h\" /* curry */])(containsPoint, coordSysModel),\n    dispatchAction: Object(util[\"h\" /* curry */])(dispatchAction, api),\n    dataZoomInfoMap: null,\n    controller: null\n  }; // Must not do anything depends on coordSysRecord outside the event handler here,\n  // because coordSysRecord not completed yet.\n\n  var controller = coordSysRecord.controller = new helper_RoamController(api.getZr());\n  Object(util[\"k\" /* each */])(['pan', 'zoom', 'scrollMove'], function (eventName) {\n    controller.on(eventName, function (event) {\n      var batch = [];\n      coordSysRecord.dataZoomInfoMap.each(function (dzInfo) {\n        // Check whether the behaviors (zoomOnMouseWheel, moveOnMouseMove,\n        // moveOnMouseWheel, ...) enabled.\n        if (!event.isAvailableBehavior(dzInfo.model.option)) {\n          return;\n        }\n\n        var method = (dzInfo.getRange || {})[eventName];\n        var range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);\n        !dzInfo.model.get('disabled', true) && range && batch.push({\n          dataZoomId: dzInfo.model.id,\n          start: range[0],\n          end: range[1]\n        });\n      });\n      batch.length && coordSysRecord.dispatchAction(batch);\n    });\n  });\n  return coordSysRecord;\n}\n/**\n * This action will be throttled.\n */\n\n\nfunction dispatchAction(api, batch) {\n  if (!api.isDisposed()) {\n    api.dispatchAction({\n      type: 'dataZoom',\n      animation: {\n        easing: 'cubicOut',\n        duration: 100\n      },\n      batch: batch\n    });\n  }\n}\n\nfunction containsPoint(coordSysModel, e, x, y) {\n  return coordSysModel.coordinateSystem.containPoint([x, y]);\n}\n/**\n * Merge roamController settings when multiple dataZooms share one roamController.\n */\n\n\nfunction mergeControllerParams(dataZoomInfoMap) {\n  var controlType; // DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated\n  // as string, it is probably revert to reserved word by compress tool. See #7411.\n\n  var prefix = 'type_';\n  var typePriority = {\n    'type_true': 2,\n    'type_move': 1,\n    'type_false': 0,\n    'type_undefined': -1\n  };\n  var preventDefaultMouseMove = true;\n  dataZoomInfoMap.each(function (dataZoomInfo) {\n    var dataZoomModel = dataZoomInfo.model;\n    var oneType = dataZoomModel.get('disabled', true) ? false : dataZoomModel.get('zoomLock', true) ? 'move' : true;\n\n    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {\n      controlType = oneType;\n    } // Prevent default move event by default. If one false, do not prevent. Otherwise\n    // users may be confused why it does not work when multiple insideZooms exist.\n\n\n    preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get('preventDefaultMouseMove', true);\n  });\n  return {\n    controlType: controlType,\n    opt: {\n      // RoamController will enable all of these functionalities,\n      // and the final behavior is determined by its event listener\n      // provided by each inside zoom.\n      zoomOnMouseWheel: true,\n      moveOnMouseMove: true,\n      moveOnMouseWheel: true,\n      preventDefaultMouseMove: !!preventDefaultMouseMove\n    }\n  };\n}\n\nfunction installDataZoomRoamProcessor(registers) {\n  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function (ecModel, api) {\n    var apiInner = inner(api);\n    var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = Object(util[\"f\" /* createHashMap */])());\n    coordSysRecordMap.each(function (coordSysRecord) {\n      // `coordSysRecordMap` always exists (becuase it hold the `roam controller`, which should\n      // better not re-create each time), but clear `dataZoomInfoMap` each round of the workflow.\n      coordSysRecord.dataZoomInfoMap = null;\n    });\n    ecModel.eachComponent({\n      mainType: 'dataZoom',\n      subType: 'inside'\n    }, function (dataZoomModel) {\n      var dzReferCoordSysWrap = Object(helper[\"b\" /* collectReferCoordSysModelInfo */])(dataZoomModel);\n      Object(util[\"k\" /* each */])(dzReferCoordSysWrap.infoList, function (dzCoordSysInfo) {\n        var coordSysUid = dzCoordSysInfo.model.uid;\n        var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));\n        var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = Object(util[\"f\" /* createHashMap */])()); // Notice these props might be changed each time for a single dataZoomModel.\n\n        dataZoomInfoMap.set(dataZoomModel.uid, {\n          dzReferCoordSysInfo: dzCoordSysInfo,\n          model: dataZoomModel,\n          getRange: null\n        });\n      });\n    }); // (1) Merge dataZoom settings for each coord sys and set to the roam controller.\n    // (2) Clear coord sys if not refered by any dataZoom.\n\n    coordSysRecordMap.each(function (coordSysRecord) {\n      var controller = coordSysRecord.controller;\n      var firstDzInfo;\n      var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;\n\n      if (dataZoomInfoMap) {\n        var firstDzKey = dataZoomInfoMap.keys()[0];\n\n        if (firstDzKey != null) {\n          firstDzInfo = dataZoomInfoMap.get(firstDzKey);\n        }\n      }\n\n      if (!firstDzInfo) {\n        disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);\n        return;\n      }\n\n      var controllerParams = mergeControllerParams(dataZoomInfoMap);\n      controller.enable(controllerParams.controlType, controllerParams.opt);\n      controller.setPointerChecker(coordSysRecord.containsPoint);\n      throttle[\"b\" /* createOrUpdate */](coordSysRecord, 'dispatchAction', firstDzInfo.model.get('throttle', true), 'fixRate');\n    });\n  });\n}\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\nvar InsideZoomView_InsideZoomView =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(InsideZoomView, _super);\n\n  function InsideZoomView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'dataZoom.inside';\n    return _this;\n  }\n\n  InsideZoomView.prototype.render = function (dataZoomModel, ecModel, api) {\n    _super.prototype.render.apply(this, arguments);\n\n    if (dataZoomModel.noTarget()) {\n      this._clear();\n\n      return;\n    } // Hence the `throttle` util ensures to preserve command order,\n    // here simply updating range all the time will not cause missing\n    // any of the the roam change.\n\n\n    this.range = dataZoomModel.getPercentRange(); // Reset controllers.\n\n    setViewInfoToCoordSysRecord(api, dataZoomModel, {\n      pan: Object(util[\"c\" /* bind */])(getRangeHandlers.pan, this),\n      zoom: Object(util[\"c\" /* bind */])(getRangeHandlers.zoom, this),\n      scrollMove: Object(util[\"c\" /* bind */])(getRangeHandlers.scrollMove, this)\n    });\n  };\n\n  InsideZoomView.prototype.dispose = function () {\n    this._clear();\n\n    _super.prototype.dispose.apply(this, arguments);\n  };\n\n  InsideZoomView.prototype._clear = function () {\n    disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);\n    this.range = null;\n  };\n\n  InsideZoomView.type = 'dataZoom.inside';\n  return InsideZoomView;\n}(DataZoomView[\"a\" /* default */]);\n\nvar getRangeHandlers = {\n  zoom: function (coordSysInfo, coordSysMainType, controller, e) {\n    var lastRange = this.range;\n    var range = lastRange.slice(); // Calculate transform by the first axis.\n\n    var axisModel = coordSysInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysMainType](null, [e.originX, e.originY], axisModel, controller, coordSysInfo);\n    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n    var scale = Math.max(1 / e.scale, 0);\n    range[0] = (range[0] - percentPoint) * scale + percentPoint;\n    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.\n\n    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    Object(sliderMove[\"a\" /* default */])(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);\n    this.range = range;\n\n    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {\n      return range;\n    }\n  },\n  pan: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {\n    var directionInfo = getDirectionInfo[coordSysMainType]([e.oldX, e.oldY], [e.newX, e.newY], axisModel, controller, coordSysInfo);\n    return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;\n  }),\n  scrollMove: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {\n    var directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e.scrollDelta, e.scrollDelta], axisModel, controller, coordSysInfo);\n    return directionInfo.signal * (range[1] - range[0]) * e.scrollDelta;\n  })\n};\n\nfunction makeMover(getPercentDelta) {\n  return function (coordSysInfo, coordSysMainType, controller, e) {\n    var lastRange = this.range;\n    var range = lastRange.slice(); // Calculate transform by the first axis.\n\n    var axisModel = coordSysInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e);\n    Object(sliderMove[\"a\" /* default */])(percentDelta, range, [0, 100], 'all');\n    this.range = range;\n\n    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {\n      return range;\n    }\n  };\n}\n\nvar getDirectionInfo = {\n  grid: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var rect = coordSysInfo.model.coordinateSystem.getRect();\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.dim === 'x') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // axis.dim === 'y'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  polar: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var polar = coordSysInfo.model.coordinateSystem;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var angleExtent = polar.getAngleAxis().getExtent();\n    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n    newPoint = polar.pointToCoord(newPoint);\n\n    if (axisModel.mainType === 'radiusAxis') {\n      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n\n      ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n      ret.pixelStart = radiusExtent[0];\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'angleAxis'\n      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n\n      ret.pixelLength = angleExtent[1] - angleExtent[0];\n      ret.pixelStart = angleExtent[0];\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {\n    var axis = axisModel.axis;\n    var rect = coordSysInfo.model.coordinateSystem.getRect();\n    var ret = {};\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.orient === 'horizontal') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'vertical'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  }\n};\n/* harmony default export */ var dataZoom_InsideZoomView = (InsideZoomView_InsideZoomView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/installCommon.js + 3 modules\nvar installCommon = __webpack_require__(\"1459\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/installDataZoomInside.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\nfunction install(registers) {\n  Object(installCommon[\"a\" /* default */])(registers);\n  registers.registerComponentModel(dataZoom_InsideZoomModel);\n  registers.registerComponentView(dataZoom_InsideZoomView);\n  installDataZoomRoamProcessor(registers);\n}\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\nvar SliderZoomModel_SliderZoomModel =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(SliderZoomModel, _super);\n\n  function SliderZoomModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = SliderZoomModel.type;\n    return _this;\n  }\n\n  SliderZoomModel.type = 'dataZoom.slider';\n  SliderZoomModel.layoutMode = 'box';\n  SliderZoomModel.defaultOption = Object(component[\"d\" /* inheritDefaultOption */])(DataZoomModel[\"a\" /* default */].defaultOption, {\n    show: true,\n    // deault value can only be drived in view stage.\n    right: 'ph',\n    top: 'ph',\n    width: 'ph',\n    height: 'ph',\n    left: null,\n    bottom: null,\n    borderColor: '#d2dbee',\n    borderRadius: 3,\n    backgroundColor: 'rgba(47,69,84,0)',\n    // dataBackgroundColor: '#ddd',\n    dataBackground: {\n      lineStyle: {\n        color: '#d2dbee',\n        width: 0.5\n      },\n      areaStyle: {\n        color: '#d2dbee',\n        opacity: 0.2\n      }\n    },\n    selectedDataBackground: {\n      lineStyle: {\n        color: '#8fb0f7',\n        width: 0.5\n      },\n      areaStyle: {\n        color: '#8fb0f7',\n        opacity: 0.2\n      }\n    },\n    // Color of selected window.\n    fillerColor: 'rgba(135,175,274,0.2)',\n    handleIcon: 'path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z',\n    // Percent of the slider height\n    handleSize: '100%',\n    handleStyle: {\n      color: '#fff',\n      borderColor: '#ACB8D1'\n    },\n    moveHandleSize: 7,\n    moveHandleIcon: 'path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z',\n    moveHandleStyle: {\n      color: '#D2DBEE',\n      opacity: 0.7\n    },\n    showDetail: true,\n    showDataShadow: 'auto',\n    realtime: true,\n    zoomLock: false,\n    textStyle: {\n      color: '#6E7079'\n    },\n    brushSelect: true,\n    brushStyle: {\n      color: 'rgba(135,175,274,0.15)'\n    },\n    emphasis: {\n      handleStyle: {\n        borderColor: '#8FB0F7'\n      },\n      moveHandleStyle: {\n        color: '#8FB0F7'\n      }\n    }\n  });\n  return SliderZoomModel;\n}(DataZoomModel[\"a\" /* default */]);\n\n/* harmony default export */ var dataZoom_SliderZoomModel = (SliderZoomModel_SliderZoomModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(\"c7a2\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(\"2dc5\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polygon.js\nvar Polygon = __webpack_require__(\"87b1\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polyline.js\nvar Polyline = __webpack_require__(\"d498\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(\"76a5\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js + 8 modules\nvar graphic = __webpack_require__(\"2306\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Point.js\nvar Point = __webpack_require__(\"dce8\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(\"3842\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(\"f934\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(\"7d6c\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar symbol = __webpack_require__(\"a15a\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(\"7837\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar SliderZoomView_Rect = Rect[\"a\" /* default */]; // Constants\n\nvar DEFAULT_LOCATION_EDGE_GAP = 7;\nvar DEFAULT_FRAME_BORDER_WIDTH = 1;\nvar DEFAULT_FILLER_SIZE = 30;\nvar DEFAULT_MOVE_HANDLE_SIZE = 7;\nvar HORIZONTAL = 'horizontal';\nvar VERTICAL = 'vertical';\nvar LABEL_GAP = 5;\nvar SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\nvar REALTIME_ANIMATION_CONFIG = {\n  easing: 'cubicOut',\n  duration: 100,\n  delay: 0\n};\n\nvar SliderZoomView_SliderZoomView =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(SliderZoomView, _super);\n\n  function SliderZoomView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = SliderZoomView.type;\n    _this._displayables = {};\n    return _this;\n  }\n\n  SliderZoomView.prototype.init = function (ecModel, api) {\n    this.api = api; // A unique handler for each dataZoom component\n\n    this._onBrush = Object(util[\"c\" /* bind */])(this._onBrush, this);\n    this._onBrushEnd = Object(util[\"c\" /* bind */])(this._onBrushEnd, this);\n  };\n\n  SliderZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {\n    _super.prototype.render.apply(this, arguments);\n\n    throttle[\"b\" /* createOrUpdate */](this, '_dispatchZoomAction', dataZoomModel.get('throttle'), 'fixRate');\n    this._orient = dataZoomModel.getOrient();\n\n    if (dataZoomModel.get('show') === false) {\n      this.group.removeAll();\n      return;\n    }\n\n    if (dataZoomModel.noTarget()) {\n      this._clear();\n\n      this.group.removeAll();\n      return;\n    } // Notice: this._resetInterval() should not be executed when payload.type\n    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n\n\n    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n      this._buildView();\n    }\n\n    this._updateView();\n  };\n\n  SliderZoomView.prototype.dispose = function () {\n    this._clear();\n\n    _super.prototype.dispose.apply(this, arguments);\n  };\n\n  SliderZoomView.prototype._clear = function () {\n    throttle[\"a\" /* clear */](this, '_dispatchZoomAction');\n    var zr = this.api.getZr();\n    zr.off('mousemove', this._onBrush);\n    zr.off('mouseup', this._onBrushEnd);\n  };\n\n  SliderZoomView.prototype._buildView = function () {\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n    this._brushing = false;\n    this._displayables.brushRect = null;\n\n    this._resetLocation();\n\n    this._resetInterval();\n\n    var barGroup = this._displayables.sliderGroup = new Group[\"a\" /* default */]();\n\n    this._renderBackground();\n\n    this._renderHandle();\n\n    this._renderDataShadow();\n\n    thisGroup.add(barGroup);\n\n    this._positionGroup();\n  };\n\n  SliderZoomView.prototype._resetLocation = function () {\n    var dataZoomModel = this.dataZoomModel;\n    var api = this.api;\n    var showMoveHandle = dataZoomModel.get('brushSelect');\n    var moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0; // If some of x/y/width/height are not specified,\n    // auto-adapt according to target grid.\n\n    var coordRect = this._findCoordRect();\n\n    var ecSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    }; // Default align by coordinate system rect.\n\n    var positionInfo = this._orient === HORIZONTAL ? {\n      // Why using 'right', because right should be used in vertical,\n      // and it is better to be consistent for dealing with position param merge.\n      right: ecSize.width - coordRect.x - coordRect.width,\n      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,\n      width: coordRect.width,\n      height: DEFAULT_FILLER_SIZE\n    } : {\n      right: DEFAULT_LOCATION_EDGE_GAP,\n      top: coordRect.y,\n      width: DEFAULT_FILLER_SIZE,\n      height: coordRect.height\n    }; // Do not write back to option and replace value 'ph', because\n    // the 'ph' value should be recalculated when resize.\n\n    var layoutParams = layout[\"c\" /* getLayoutParams */](dataZoomModel.option); // Replace the placeholder value.\n\n    Object(util[\"k\" /* each */])(['right', 'top', 'width', 'height'], function (name) {\n      if (layoutParams[name] === 'ph') {\n        layoutParams[name] = positionInfo[name];\n      }\n    });\n    var layoutRect = layout[\"d\" /* getLayoutRect */](layoutParams, ecSize);\n    this._location = {\n      x: layoutRect.x,\n      y: layoutRect.y\n    };\n    this._size = [layoutRect.width, layoutRect.height];\n    this._orient === VERTICAL && this._size.reverse();\n  };\n\n  SliderZoomView.prototype._positionGroup = function () {\n    var thisGroup = this.group;\n    var location = this._location;\n    var orient = this._orient; // Just use the first axis to determine mapping.\n\n    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n    var inverse = targetAxisModel && targetAxisModel.get('inverse');\n    var sliderGroup = this._displayables.sliderGroup;\n    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.\n\n    sliderGroup.attr(orient === HORIZONTAL && !inverse ? {\n      scaleY: otherAxisInverse ? 1 : -1,\n      scaleX: 1\n    } : orient === HORIZONTAL && inverse ? {\n      scaleY: otherAxisInverse ? 1 : -1,\n      scaleX: -1\n    } : orient === VERTICAL && !inverse ? {\n      scaleY: otherAxisInverse ? -1 : 1,\n      scaleX: 1,\n      rotation: Math.PI / 2\n    } // Dont use Math.PI, considering shadow direction.\n    : {\n      scaleY: otherAxisInverse ? -1 : 1,\n      scaleX: -1,\n      rotation: Math.PI / 2\n    }); // Position barGroup\n\n    var rect = thisGroup.getBoundingRect([sliderGroup]);\n    thisGroup.x = location.x - rect.x;\n    thisGroup.y = location.y - rect.y;\n    thisGroup.markRedraw();\n  };\n\n  SliderZoomView.prototype._getViewExtent = function () {\n    return [0, this._size[0]];\n  };\n\n  SliderZoomView.prototype._renderBackground = function () {\n    var dataZoomModel = this.dataZoomModel;\n    var size = this._size;\n    var barGroup = this._displayables.sliderGroup;\n    var brushSelect = dataZoomModel.get('brushSelect');\n    barGroup.add(new SliderZoomView_Rect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: dataZoomModel.get('backgroundColor')\n      },\n      z2: -40\n    })); // Click panel, over shadow, below handles.\n\n    var clickPanel = new SliderZoomView_Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: 'transparent'\n      },\n      z2: 0,\n      onclick: Object(util[\"c\" /* bind */])(this._onClickPanel, this)\n    });\n    var zr = this.api.getZr();\n\n    if (brushSelect) {\n      clickPanel.on('mousedown', this._onBrushStart, this);\n      clickPanel.cursor = 'crosshair';\n      zr.on('mousemove', this._onBrush);\n      zr.on('mouseup', this._onBrushEnd);\n    } else {\n      zr.off('mousemove', this._onBrush);\n      zr.off('mouseup', this._onBrushEnd);\n    }\n\n    barGroup.add(clickPanel);\n  };\n\n  SliderZoomView.prototype._renderDataShadow = function () {\n    var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n    this._displayables.dataShadowSegs = [];\n\n    if (!info) {\n      return;\n    }\n\n    var size = this._size;\n    var oldSize = this._shadowSize || [];\n    var seriesModel = info.series;\n    var data = seriesModel.getRawData();\n    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick\n    : info.otherDim;\n\n    if (otherDim == null) {\n      return;\n    }\n\n    var polygonPts = this._shadowPolygonPts;\n    var polylinePts = this._shadowPolylinePts; // Not re-render if data doesn't change.\n\n    if (data !== this._shadowData || otherDim !== this._shadowDim || size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      var otherDataExtent_1 = data.getDataExtent(otherDim); // Nice extent.\n\n      var otherOffset = (otherDataExtent_1[1] - otherDataExtent_1[0]) * 0.3;\n      otherDataExtent_1 = [otherDataExtent_1[0] - otherOffset, otherDataExtent_1[1] + otherOffset];\n      var otherShadowExtent_1 = [0, size[1]];\n      var thisShadowExtent = [0, size[0]];\n      var areaPoints_1 = [[size[0], 0], [0, 0]];\n      var linePoints_1 = [];\n      var step_1 = thisShadowExtent[1] / (data.count() - 1);\n      var thisCoord_1 = 0; // Optimize for large data shadow\n\n      var stride_1 = Math.round(data.count() / size[0]);\n      var lastIsEmpty_1;\n      data.each([otherDim], function (value, index) {\n        if (stride_1 > 0 && index % stride_1) {\n          thisCoord_1 += step_1;\n          return;\n        } // FIXME\n        // Should consider axis.min/axis.max when drawing dataShadow.\n        // FIXME\n        // 应该使用统一的空判断？还是在list里进行空判断？\n\n\n        var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.\n\n        var otherCoord = isEmpty ? 0 : Object(number[\"j\" /* linearMap */])(value, otherDataExtent_1, otherShadowExtent_1, true); // Attempt to draw data shadow precisely when there are empty value.\n\n        if (isEmpty && !lastIsEmpty_1 && index) {\n          areaPoints_1.push([areaPoints_1[areaPoints_1.length - 1][0], 0]);\n          linePoints_1.push([linePoints_1[linePoints_1.length - 1][0], 0]);\n        } else if (!isEmpty && lastIsEmpty_1) {\n          areaPoints_1.push([thisCoord_1, 0]);\n          linePoints_1.push([thisCoord_1, 0]);\n        }\n\n        areaPoints_1.push([thisCoord_1, otherCoord]);\n        linePoints_1.push([thisCoord_1, otherCoord]);\n        thisCoord_1 += step_1;\n        lastIsEmpty_1 = isEmpty;\n      });\n      polygonPts = this._shadowPolygonPts = areaPoints_1;\n      polylinePts = this._shadowPolylinePts = linePoints_1;\n    }\n\n    this._shadowData = data;\n    this._shadowDim = otherDim;\n    this._shadowSize = [size[0], size[1]];\n    var dataZoomModel = this.dataZoomModel;\n\n    function createDataShadowGroup(isSelectedArea) {\n      var model = dataZoomModel.getModel(isSelectedArea ? 'selectedDataBackground' : 'dataBackground');\n      var group = new Group[\"a\" /* default */]();\n      var polygon = new Polygon[\"a\" /* default */]({\n        shape: {\n          points: polygonPts\n        },\n        segmentIgnoreThreshold: 1,\n        style: model.getModel('areaStyle').getAreaStyle(),\n        silent: true,\n        z2: -20\n      });\n      var polyline = new Polyline[\"a\" /* default */]({\n        shape: {\n          points: polylinePts\n        },\n        segmentIgnoreThreshold: 1,\n        style: model.getModel('lineStyle').getLineStyle(),\n        silent: true,\n        z2: -19\n      });\n      group.add(polygon);\n      group.add(polyline);\n      return group;\n    } // let dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n\n\n    for (var i = 0; i < 3; i++) {\n      var group = createDataShadowGroup(i === 1);\n\n      this._displayables.sliderGroup.add(group);\n\n      this._displayables.dataShadowSegs.push(group);\n    }\n  };\n\n  SliderZoomView.prototype._prepareDataShadowInfo = function () {\n    var dataZoomModel = this.dataZoomModel;\n    var showDataShadow = dataZoomModel.get('showDataShadow');\n\n    if (showDataShadow === false) {\n      return;\n    } // Find a representative series.\n\n\n    var result;\n    var ecModel = this.ecModel;\n    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n      var seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();\n      Object(util[\"k\" /* each */])(seriesModels, function (seriesModel) {\n        if (result) {\n          return;\n        }\n\n        if (showDataShadow !== true && Object(util[\"q\" /* indexOf */])(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {\n          return;\n        }\n\n        var thisAxis = ecModel.getComponent(Object(helper[\"d\" /* getAxisMainType */])(axisDim), axisIndex).axis;\n        var otherDim = getOtherDim(axisDim);\n        var otherAxisInverse;\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (otherDim != null && coordSys.getOtherAxis) {\n          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n        }\n\n        otherDim = seriesModel.getData().mapDimension(otherDim);\n        result = {\n          thisAxis: thisAxis,\n          series: seriesModel,\n          thisDim: axisDim,\n          otherDim: otherDim,\n          otherAxisInverse: otherAxisInverse\n        };\n      }, this);\n    }, this);\n    return result;\n  };\n\n  SliderZoomView.prototype._renderHandle = function () {\n    var thisGroup = this.group;\n    var displayables = this._displayables;\n    var handles = displayables.handles = [null, null];\n    var handleLabels = displayables.handleLabels = [null, null];\n    var sliderGroup = this._displayables.sliderGroup;\n    var size = this._size;\n    var dataZoomModel = this.dataZoomModel;\n    var api = this.api;\n    var borderRadius = dataZoomModel.get('borderRadius') || 0;\n    var brushSelect = dataZoomModel.get('brushSelect');\n    var filler = displayables.filler = new SliderZoomView_Rect({\n      silent: brushSelect,\n      style: {\n        fill: dataZoomModel.get('fillerColor')\n      },\n      textConfig: {\n        position: 'inside'\n      }\n    });\n    sliderGroup.add(filler); // Frame border.\n\n    sliderGroup.add(new SliderZoomView_Rect({\n      silent: true,\n      subPixelOptimize: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1],\n        r: borderRadius\n      },\n      style: {\n        stroke: dataZoomModel.get('dataBackgroundColor') // deprecated option\n        || dataZoomModel.get('borderColor'),\n        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n        fill: 'rgba(0,0,0,0)'\n      }\n    })); // Left and right handle to resize\n\n    Object(util[\"k\" /* each */])([0, 1], function (handleIndex) {\n      var iconStr = dataZoomModel.get('handleIcon');\n\n      if (!symbol[\"d\" /* symbolBuildProxies */][iconStr] && iconStr.indexOf('path://') < 0 && iconStr.indexOf('image://') < 0) {\n        // Compatitable with the old icon parsers. Which can use a path string without path://\n        iconStr = 'path://' + iconStr;\n\n        if (false) {}\n      }\n\n      var path = Object(symbol[\"a\" /* createSymbol */])(iconStr, -1, 0, 2, 2, null, true);\n      path.attr({\n        cursor: getCursor(this._orient),\n        draggable: true,\n        drift: Object(util[\"c\" /* bind */])(this._onDragMove, this, handleIndex),\n        ondragend: Object(util[\"c\" /* bind */])(this._onDragEnd, this),\n        onmouseover: Object(util[\"c\" /* bind */])(this._showDataInfo, this, true),\n        onmouseout: Object(util[\"c\" /* bind */])(this._showDataInfo, this, false),\n        z2: 5\n      });\n      var bRect = path.getBoundingRect();\n      var handleSize = dataZoomModel.get('handleSize');\n      this._handleHeight = Object(number[\"n\" /* parsePercent */])(handleSize, this._size[1]);\n      this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n      path.style.strokeNoScale = true;\n      path.rectHover = true;\n      path.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'handleStyle']).getItemStyle();\n      Object(states[\"m\" /* enableHoverEmphasis */])(path);\n      var handleColor = dataZoomModel.get('handleColor'); // deprecated option\n      // Compatitable with previous version\n\n      if (handleColor != null) {\n        path.style.fill = handleColor;\n      }\n\n      sliderGroup.add(handles[handleIndex] = path);\n      var textStyleModel = dataZoomModel.getModel('textStyle');\n      thisGroup.add(handleLabels[handleIndex] = new Text[\"a\" /* default */]({\n        silent: true,\n        invisible: true,\n        style: Object(labelStyle[\"a\" /* createTextStyle */])(textStyleModel, {\n          x: 0,\n          y: 0,\n          text: '',\n          verticalAlign: 'middle',\n          align: 'center',\n          fill: textStyleModel.getTextColor(),\n          font: textStyleModel.getFont()\n        }),\n        z2: 10\n      }));\n    }, this); // Handle to move. Only visible when brushSelect is set true.\n\n    var actualMoveZone = filler;\n\n    if (brushSelect) {\n      var moveHandleHeight = Object(number[\"n\" /* parsePercent */])(dataZoomModel.get('moveHandleSize'), size[1]);\n      var moveHandle_1 = displayables.moveHandle = new Rect[\"a\" /* default */]({\n        style: dataZoomModel.getModel('moveHandleStyle').getItemStyle(),\n        silent: true,\n        shape: {\n          r: [0, 0, 2, 2],\n          y: size[1] - 0.5,\n          height: moveHandleHeight\n        }\n      });\n      var iconSize = moveHandleHeight * 0.8;\n      var moveHandleIcon = displayables.moveHandleIcon = Object(symbol[\"a\" /* createSymbol */])(dataZoomModel.get('moveHandleIcon'), -iconSize / 2, -iconSize / 2, iconSize, iconSize, '#fff', true);\n      moveHandleIcon.silent = true;\n      moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;\n      moveHandle_1.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'moveHandleStyle']).getItemStyle();\n      var moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));\n      actualMoveZone = displayables.moveZone = new Rect[\"a\" /* default */]({\n        invisible: true,\n        shape: {\n          y: size[1] - moveZoneExpandSize,\n          height: moveHandleHeight + moveZoneExpandSize\n        }\n      });\n      actualMoveZone.on('mouseover', function () {\n        api.enterEmphasis(moveHandle_1);\n      }).on('mouseout', function () {\n        api.leaveEmphasis(moveHandle_1);\n      });\n      sliderGroup.add(moveHandle_1);\n      sliderGroup.add(moveHandleIcon);\n      sliderGroup.add(actualMoveZone);\n    }\n\n    actualMoveZone.attr({\n      draggable: true,\n      cursor: getCursor(this._orient),\n      drift: Object(util[\"c\" /* bind */])(this._onDragMove, this, 'all'),\n      ondragstart: Object(util[\"c\" /* bind */])(this._showDataInfo, this, true),\n      ondragend: Object(util[\"c\" /* bind */])(this._onDragEnd, this),\n      onmouseover: Object(util[\"c\" /* bind */])(this._showDataInfo, this, true),\n      onmouseout: Object(util[\"c\" /* bind */])(this._showDataInfo, this, false)\n    });\n  };\n\n  SliderZoomView.prototype._resetInterval = function () {\n    var range = this._range = this.dataZoomModel.getPercentRange();\n\n    var viewExtent = this._getViewExtent();\n\n    this._handleEnds = [Object(number[\"j\" /* linearMap */])(range[0], [0, 100], viewExtent, true), Object(number[\"j\" /* linearMap */])(range[1], [0, 100], viewExtent, true)];\n  };\n\n  SliderZoomView.prototype._updateInterval = function (handleIndex, delta) {\n    var dataZoomModel = this.dataZoomModel;\n    var handleEnds = this._handleEnds;\n\n    var viewExtend = this._getViewExtent();\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    var percentExtent = [0, 100];\n    Object(sliderMove[\"a\" /* default */])(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? Object(number[\"j\" /* linearMap */])(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? Object(number[\"j\" /* linearMap */])(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);\n    var lastRange = this._range;\n    var range = this._range = Object(number[\"b\" /* asc */])([Object(number[\"j\" /* linearMap */])(handleEnds[0], viewExtend, percentExtent, true), Object(number[\"j\" /* linearMap */])(handleEnds[1], viewExtend, percentExtent, true)]);\n    return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];\n  };\n\n  SliderZoomView.prototype._updateView = function (nonRealtime) {\n    var displaybles = this._displayables;\n    var handleEnds = this._handleEnds;\n    var handleInterval = Object(number[\"b\" /* asc */])(handleEnds.slice());\n    var size = this._size;\n    Object(util[\"k\" /* each */])([0, 1], function (handleIndex) {\n      // Handles\n      var handle = displaybles.handles[handleIndex];\n      var handleHeight = this._handleHeight;\n      handle.attr({\n        scaleX: handleHeight / 2,\n        scaleY: handleHeight / 2,\n        // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.\n        // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.\n        x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),\n        y: size[1] / 2 - handleHeight / 2\n      });\n    }, this); // Filler\n\n    displaybles.filler.setShape({\n      x: handleInterval[0],\n      y: 0,\n      width: handleInterval[1] - handleInterval[0],\n      height: size[1]\n    });\n    var viewExtent = {\n      x: handleInterval[0],\n      width: handleInterval[1] - handleInterval[0]\n    }; // Move handle\n\n    if (displaybles.moveHandle) {\n      displaybles.moveHandle.setShape(viewExtent);\n      displaybles.moveZone.setShape(viewExtent); // Force update path on the invisible object\n\n      displaybles.moveZone.getBoundingRect();\n      displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr('x', viewExtent.x + viewExtent.width / 2);\n    } // update clip path of shadow.\n\n\n    var dataShadowSegs = displaybles.dataShadowSegs;\n    var segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];\n\n    for (var i = 0; i < dataShadowSegs.length; i++) {\n      var segGroup = dataShadowSegs[i];\n      var clipPath = segGroup.getClipPath();\n\n      if (!clipPath) {\n        clipPath = new Rect[\"a\" /* default */]();\n        segGroup.setClipPath(clipPath);\n      }\n\n      clipPath.setShape({\n        x: segIntervals[i],\n        y: 0,\n        width: segIntervals[i + 1] - segIntervals[i],\n        height: size[1]\n      });\n    }\n\n    this._updateDataInfo(nonRealtime);\n  };\n\n  SliderZoomView.prototype._updateDataInfo = function (nonRealtime) {\n    var dataZoomModel = this.dataZoomModel;\n    var displaybles = this._displayables;\n    var handleLabels = displaybles.handleLabels;\n    var orient = this._orient;\n    var labelTexts = ['', '']; // FIXME\n    // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）\n\n    if (dataZoomModel.get('showDetail')) {\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        var axis = axisProxy.getAxisModel().axis;\n        var range = this._range;\n        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.\n        ? axisProxy.calculateDataWindow({\n          start: range[0],\n          end: range[1]\n        }).valueWindow : axisProxy.getDataValueWindow();\n        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];\n      }\n    }\n\n    var orderedHandleEnds = Object(number[\"b\" /* asc */])(this._handleEnds.slice());\n    setLabel.call(this, 0);\n    setLabel.call(this, 1);\n\n    function setLabel(handleIndex) {\n      // Label\n      // Text should not transform by barGroup.\n      // Ignore handlers transform\n      var barTransform = graphic[\"getTransform\"](displaybles.handles[handleIndex].parent, this.group);\n      var direction = graphic[\"transformDirection\"](handleIndex === 0 ? 'right' : 'left', barTransform);\n      var offset = this._handleWidth / 2 + LABEL_GAP;\n      var textPoint = graphic[\"applyTransform\"]([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);\n      handleLabels[handleIndex].setStyle({\n        x: textPoint[0],\n        y: textPoint[1],\n        verticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n        align: orient === HORIZONTAL ? direction : 'center',\n        text: labelTexts[handleIndex]\n      });\n    }\n  };\n\n  SliderZoomView.prototype._formatLabel = function (value, axis) {\n    var dataZoomModel = this.dataZoomModel;\n    var labelFormatter = dataZoomModel.get('labelFormatter');\n    var labelPrecision = dataZoomModel.get('labelPrecision');\n\n    if (labelPrecision == null || labelPrecision === 'auto') {\n      labelPrecision = axis.getPixelPrecision();\n    }\n\n    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code\n    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel({\n      value: Math.round(value)\n    }) // param of toFixed should less then 20.\n    : value.toFixed(Math.min(labelPrecision, 20));\n    return Object(util[\"v\" /* isFunction */])(labelFormatter) ? labelFormatter(value, valueStr) : Object(util[\"A\" /* isString */])(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;\n  };\n  /**\n   * @param showOrHide true: show, false: hide\n   */\n\n\n  SliderZoomView.prototype._showDataInfo = function (showOrHide) {\n    // Always show when drgging.\n    showOrHide = this._dragging || showOrHide;\n    var displayables = this._displayables;\n    var handleLabels = displayables.handleLabels;\n    handleLabels[0].attr('invisible', !showOrHide);\n    handleLabels[1].attr('invisible', !showOrHide); // Highlight move handle\n\n    displayables.moveHandle && this.api[showOrHide ? 'enterEmphasis' : 'leaveEmphasis'](displayables.moveHandle, 1);\n  };\n\n  SliderZoomView.prototype._onDragMove = function (handleIndex, dx, dy, event) {\n    this._dragging = true; // For mobile device, prevent screen slider on the button.\n\n    core_event[\"g\" /* stop */](event.event); // Transform dx, dy to bar coordination.\n\n    var barTransform = this._displayables.sliderGroup.getLocalTransform();\n\n    var vertex = graphic[\"applyTransform\"]([dx, dy], barTransform, true);\n\n    var changed = this._updateInterval(handleIndex, vertex[0]);\n\n    var realtime = this.dataZoomModel.get('realtime');\n\n    this._updateView(!realtime); // Avoid dispatch dataZoom repeatly but range not changed,\n    // which cause bad visual effect when progressive enabled.\n\n\n    changed && realtime && this._dispatchZoomAction(true);\n  };\n\n  SliderZoomView.prototype._onDragEnd = function () {\n    this._dragging = false;\n\n    this._showDataInfo(false); // While in realtime mode and stream mode, dispatch action when\n    // drag end will cause the whole view rerender, which is unnecessary.\n\n\n    var realtime = this.dataZoomModel.get('realtime');\n    !realtime && this._dispatchZoomAction(false);\n  };\n\n  SliderZoomView.prototype._onClickPanel = function (e) {\n    var size = this._size;\n\n    var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY);\n\n    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {\n      return;\n    }\n\n    var handleEnds = this._handleEnds;\n    var center = (handleEnds[0] + handleEnds[1]) / 2;\n\n    var changed = this._updateInterval('all', localPoint[0] - center);\n\n    this._updateView();\n\n    changed && this._dispatchZoomAction(false);\n  };\n\n  SliderZoomView.prototype._onBrushStart = function (e) {\n    var x = e.offsetX;\n    var y = e.offsetY;\n    this._brushStart = new Point[\"a\" /* default */](x, y);\n    this._brushing = true;\n    this._brushStartTime = +new Date(); // this._updateBrushRect(x, y);\n  };\n\n  SliderZoomView.prototype._onBrushEnd = function (e) {\n    if (!this._brushing) {\n      return;\n    }\n\n    var brushRect = this._displayables.brushRect;\n    this._brushing = false;\n\n    if (!brushRect) {\n      return;\n    }\n\n    brushRect.attr('ignore', true);\n    var brushShape = brushRect.shape;\n    var brushEndTime = +new Date(); // console.log(brushEndTime - this._brushStartTime);\n\n    if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {\n      // Will treat it as a click\n      return;\n    }\n\n    var viewExtend = this._getViewExtent();\n\n    var percentExtent = [0, 100];\n    this._range = Object(number[\"b\" /* asc */])([Object(number[\"j\" /* linearMap */])(brushShape.x, viewExtend, percentExtent, true), Object(number[\"j\" /* linearMap */])(brushShape.x + brushShape.width, viewExtend, percentExtent, true)]);\n    this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];\n\n    this._updateView();\n\n    this._dispatchZoomAction(false);\n  };\n\n  SliderZoomView.prototype._onBrush = function (e) {\n    if (this._brushing) {\n      // For mobile device, prevent screen slider on the button.\n      core_event[\"g\" /* stop */](e.event);\n\n      this._updateBrushRect(e.offsetX, e.offsetY);\n    }\n  };\n\n  SliderZoomView.prototype._updateBrushRect = function (mouseX, mouseY) {\n    var displayables = this._displayables;\n    var dataZoomModel = this.dataZoomModel;\n    var brushRect = displayables.brushRect;\n\n    if (!brushRect) {\n      brushRect = displayables.brushRect = new SliderZoomView_Rect({\n        silent: true,\n        style: dataZoomModel.getModel('brushStyle').getItemStyle()\n      });\n      displayables.sliderGroup.add(brushRect);\n    }\n\n    brushRect.attr('ignore', false);\n    var brushStart = this._brushStart;\n    var sliderGroup = this._displayables.sliderGroup;\n    var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);\n    var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);\n    var size = this._size;\n    endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);\n    brushRect.setShape({\n      x: startPoint[0],\n      y: 0,\n      width: endPoint[0] - startPoint[0],\n      height: size[1]\n    });\n  };\n  /**\n   * This action will be throttled.\n   */\n\n\n  SliderZoomView.prototype._dispatchZoomAction = function (realtime) {\n    var range = this._range;\n    this.api.dispatchAction({\n      type: 'dataZoom',\n      from: this.uid,\n      dataZoomId: this.dataZoomModel.id,\n      animation: realtime ? REALTIME_ANIMATION_CONFIG : null,\n      start: range[0],\n      end: range[1]\n    });\n  };\n\n  SliderZoomView.prototype._findCoordRect = function () {\n    // Find the grid coresponding to the first axis referred by dataZoom.\n    var rect;\n    var coordSysInfoList = Object(helper[\"b\" /* collectReferCoordSysModelInfo */])(this.dataZoomModel).infoList;\n\n    if (!rect && coordSysInfoList.length) {\n      var coordSys = coordSysInfoList[0].model.coordinateSystem;\n      rect = coordSys.getRect && coordSys.getRect();\n    }\n\n    if (!rect) {\n      var width = this.api.getWidth();\n      var height = this.api.getHeight();\n      rect = {\n        x: width * 0.2,\n        y: height * 0.2,\n        width: width * 0.6,\n        height: height * 0.6\n      };\n    }\n\n    return rect;\n  };\n\n  SliderZoomView.type = 'dataZoom.slider';\n  return SliderZoomView;\n}(DataZoomView[\"a\" /* default */]);\n\nfunction getOtherDim(thisDim) {\n  // FIXME\n  // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好\n  var map = {\n    x: 'y',\n    y: 'x',\n    radius: 'angle',\n    angle: 'radius'\n  };\n  return map[thisDim];\n}\n\nfunction getCursor(orient) {\n  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n\n/* harmony default export */ var dataZoom_SliderZoomView = (SliderZoomView_SliderZoomView);\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/installDataZoomSlider.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nfunction installDataZoomSlider_install(registers) {\n  registers.registerComponentModel(dataZoom_SliderZoomModel);\n  registers.registerComponentView(dataZoom_SliderZoomView);\n  Object(installCommon[\"a\" /* default */])(registers);\n}\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nfunction install_install(registers) {\n  Object(extension[\"a\" /* use */])(install);\n  Object(extension[\"a\" /* use */])(installDataZoomSlider_install); // Do not install './dataZoomSelect',\n  // since it only work for toolbox dataZoom.\n}\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/component/dataZoom/install.js_+_8_modules?")},1459:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ installCommon; });\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__("6d8b");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/helper.js\nvar helper = __webpack_require__("50e5");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__("3842");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/sliderMove.js\nvar sliderMove = __webpack_require__("ef6a");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisHelper.js + 3 modules\nvar axisHelper = __webpack_require__("697e");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/scaleRawExtentInfo.js\nvar scaleRawExtentInfo = __webpack_require__("538f");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__("e0d3");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/AxisProxy.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\n\nvar each = util["k" /* each */];\nvar asc = number["b" /* asc */];\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. \'inside\' data zoom and \'slider\' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n */\n\nvar AxisProxy_AxisProxy =\n/** @class */\nfunction () {\n  function AxisProxy(dimName, axisIndex, dataZoomModel, ecModel) {\n    this._dimName = dimName;\n    this._axisIndex = axisIndex;\n    this.ecModel = ecModel;\n    this._dataZoomModel = dataZoomModel; // /**\n    //  * @readOnly\n    //  * @private\n    //  */\n    // this.hasSeriesStacked;\n  }\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   */\n\n\n  AxisProxy.prototype.hostedBy = function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  };\n  /**\n   * @return Value can only be NaN or finite value.\n   */\n\n\n  AxisProxy.prototype.getDataValueWindow = function () {\n    return this._valueWindow.slice();\n  };\n  /**\n   * @return {Array.<number>}\n   */\n\n\n  AxisProxy.prototype.getDataPercentWindow = function () {\n    return this._percentWindow.slice();\n  };\n\n  AxisProxy.prototype.getTargetSeriesModels = function () {\n    var seriesModels = [];\n    this.ecModel.eachSeries(function (seriesModel) {\n      if (Object(helper["e" /* isCoordSupported */])(seriesModel)) {\n        var axisMainType = Object(helper["d" /* getAxisMainType */])(this._dimName);\n        var axisModel = seriesModel.getReferringComponents(axisMainType, model["b" /* SINGLE_REFERRING */]).models[0];\n\n        if (axisModel && this._axisIndex === axisModel.componentIndex) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  };\n\n  AxisProxy.prototype.getAxisModel = function () {\n    return this.ecModel.getComponent(this._dimName + \'Axis\', this._axisIndex);\n  };\n\n  AxisProxy.prototype.getMinMaxSpan = function () {\n    return util["d" /* clone */](this._minMaxSpan);\n  };\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   */\n\n\n  AxisProxy.prototype.calculateDataWindow = function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [];\n    var valueWindow = [];\n    var hasPropModeValue;\n    each([\'start\', \'end\'], function (prop, idx) {\n      var boundPercent = opt[prop];\n      var boundValue = opt[prop + \'Value\']; // Notice: dataZoom is based either on `percentProp` (\'start\', \'end\') or\n      // on `valueProp` (\'startValue\', \'endValue\'). (They are based on the data extent\n      // but not min/max of axis, which will be calculated by data window then).\n      // The former one is suitable for cases that a dataZoom component controls multiple\n      // axes with different unit or extent, and the latter one is suitable for accurate\n      // zoom by pixel (e.g., in dataZoomSelect).\n      // we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated\n      // only when setOption or dispatchAction, otherwise it remains its original value.\n      // (Why not only record `percentProp` and always map to `valueProp`? Because\n      // the map `valueProp` -> `percentProp` -> `valueProp` probably not the original\n      // `valueProp`. consider two axes constrolled by one dataZoom. They have different\n      // data extent. All of values that are overflow the `dataExtent` will be calculated\n      // to percent \'100%\').\n\n      if (rangePropMode[idx] === \'percent\') {\n        boundPercent == null && (boundPercent = percentExtent[idx]); // Use scale.parse to math round for category or time axis.\n\n        boundValue = scale.parse(number["j" /* linearMap */](boundPercent, percentExtent, dataExtent));\n      } else {\n        hasPropModeValue = true;\n        boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue); // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent \'100%\'\n\n        boundPercent = number["j" /* linearMap */](boundValue, dataExtent, percentExtent);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    asc(valueWindow);\n    asc(percentWindow); // The windows from user calling of `dispatchAction` might be out of the extent,\n    // or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we dont restrict window\n    // by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,\n    // where API is able to initialize/modify the window size even though `zoomLock`\n    // specified.\n\n    var spans = this._minMaxSpan;\n    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);\n\n    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {\n      var suffix = toValue ? \'Span\' : \'ValueSpan\';\n      Object(sliderMove["a" /* default */])(0, fromWindow, fromExtent, \'all\', spans[\'min\' + suffix], spans[\'max\' + suffix]);\n\n      for (var i = 0; i < 2; i++) {\n        toWindow[i] = number["j" /* linearMap */](fromWindow[i], fromExtent, toExtent, true);\n        toValue && (toWindow[i] = scale.parse(toWindow[i]));\n      }\n    }\n\n    return {\n      valueWindow: valueWindow,\n      percentWindow: percentWindow\n    };\n  };\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in "process stage" but not "model init\n   * stage".\n   */\n\n\n  AxisProxy.prototype.reset = function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // `calculateDataWindow` uses min/maxSpan.\n\n    this._updateMinMaxSpan();\n\n    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow; // Update axis setting then.\n\n    this._setAxisModel();\n  };\n\n  AxisProxy.prototype.filterData = function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get(\'filterMode\');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === \'none\') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-\'filter\'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support "single axis\n    // selection" some day, which might need "adapt to data extent on the\n    // otherAxis", which is disabled by filterMode-\'empty\'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // let otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get(\'$fromToolbox\')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = \'empty\';\n    // }\n    // TODO\n    // filterMode \'weakFilter\' and \'empty\' is not optimized for huge data yet.\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimensionsAll(axisDim);\n\n      if (!dataDims.length) {\n        return;\n      }\n\n      if (filterMode === \'weakFilter\') {\n        var store_1 = seriesData.getStore();\n        var dataDimIndices_1 = util["F" /* map */](dataDims, function (dim) {\n          return seriesData.getDimensionIndex(dim);\n        }, seriesData);\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = store_1.get(dataDimIndices_1[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === \'empty\') {\n            seriesModel.setData(seriesData = seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time(\'select\');\n\n            seriesData.selectRange(range); // console.timeEnd(\'select\');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  };\n\n  AxisProxy.prototype._updateMinMaxSpan = function () {\n    var minMaxSpan = this._minMaxSpan = {};\n    var dataZoomModel = this._dataZoomModel;\n    var dataExtent = this._dataExtent;\n    each([\'min\', \'max\'], function (minMax) {\n      var percentSpan = dataZoomModel.get(minMax + \'Span\');\n      var valueSpan = dataZoomModel.get(minMax + \'ValueSpan\');\n      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan)); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n      if (valueSpan != null) {\n        percentSpan = number["j" /* linearMap */](dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      } else if (percentSpan != null) {\n        valueSpan = number["j" /* linearMap */](percentSpan, [0, 100], dataExtent, true) - dataExtent[0];\n      }\n\n      minMaxSpan[minMax + \'Span\'] = percentSpan;\n      minMaxSpan[minMax + \'ValueSpan\'] = valueSpan;\n    }, this);\n  };\n\n  AxisProxy.prototype._setAxisModel = function () {\n    var axisModel = this.getAxisModel();\n    var percentWindow = this._percentWindow;\n    var valueWindow = this._valueWindow;\n\n    if (!percentWindow) {\n      return;\n    } // [0, 500]: arbitrary value, guess axis extent.\n\n\n    var precision = number["e" /* getPixelPrecision */](valueWindow, [0, 500]);\n    precision = Math.min(precision, 20); // For value axis, if min/max/scale are not set, we just use the extent obtained\n    // by series data, which may be a little different from the extent calculated by\n    // `axisHelper.getScaleExtent`. But the different just affects the experience a\n    // little when zooming. So it will not be fixed until some users require it strongly.\n\n    var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;\n\n    if (percentWindow[0] !== 0) {\n      rawExtentInfo.setDeterminedMinMax(\'min\', +valueWindow[0].toFixed(precision));\n    }\n\n    if (percentWindow[1] !== 100) {\n      rawExtentInfo.setDeterminedMinMax(\'max\', +valueWindow[1].toFixed(precision));\n    }\n\n    rawExtentInfo.freeze();\n  };\n\n  return AxisProxy;\n}();\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    Object(axisHelper["k" /* unionAxisExtentFromData */])(dataExtent, seriesModel.getData(), axisDim);\n  }); // It is important to get "consistent" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is "consistent", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n  var axisModel = axisProxy.getAxisModel();\n  var rawExtentResult = Object(scaleRawExtentInfo["a" /* ensureScaleRawExtentInfo */])(axisModel.axis.scale, axisModel, dataExtent).calculate();\n  return [rawExtentResult.min, rawExtentResult.max];\n}\n\n/* harmony default export */ var dataZoom_AxisProxy = (AxisProxy_AxisProxy);\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nvar dataZoomProcessor = {\n  // `dataZoomProcessor` will only be performed in needed series. Consider if\n  // there is a line series and a pie series, it is better not to update the\n  // line series if only pie series is needed to be updated.\n  getTargetSeries: function (ecModel) {\n    function eachAxisModel(cb) {\n      ecModel.eachComponent(\'dataZoom\', function (dataZoomModel) {\n        dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n          var axisModel = ecModel.getComponent(Object(helper["d" /* getAxisMainType */])(axisDim), axisIndex);\n          cb(axisDim, axisIndex, axisModel, dataZoomModel);\n        });\n      });\n    } // FIXME: it brings side-effect to `getTargetSeries`.\n    // Prepare axis proxies.\n\n\n    eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {\n      // dispose all last axis proxy, in case that some axis are deleted.\n      axisModel.__dzAxisProxy = null;\n    });\n    var proxyList = [];\n    eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {\n      // Different dataZooms may constrol the same axis. In that case,\n      // an axisProxy serves both of them.\n      if (!axisModel.__dzAxisProxy) {\n        // Use the first dataZoomModel as the main model of axisProxy.\n        axisModel.__dzAxisProxy = new dataZoom_AxisProxy(axisDim, axisIndex, dataZoomModel, ecModel);\n        proxyList.push(axisModel.__dzAxisProxy);\n      }\n    });\n    var seriesModelMap = Object(util["f" /* createHashMap */])();\n    Object(util["k" /* each */])(proxyList, function (axisProxy) {\n      Object(util["k" /* each */])(axisProxy.getTargetSeriesModels(), function (seriesModel) {\n        seriesModelMap.set(seriesModel.uid, seriesModel);\n      });\n    });\n    return seriesModelMap;\n  },\n  // Consider appendData, where filter should be performed. Because data process is\n  // in block mode currently, it is not need to worry about that the overallProgress\n  // execute every frame.\n  overallReset: function (ecModel, api) {\n    ecModel.eachComponent(\'dataZoom\', function (dataZoomModel) {\n      // We calculate window and reset axis here but not in model\n      // init stage and not after action dispatch handler, because\n      // reset should be called after seriesData.restoreData.\n      dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n        dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);\n      }); // Caution: data zoom filtering is order sensitive when using\n      // percent range and no min/max/scale set on axis.\n      // For example, we have dataZoom definition:\n      // [\n      //      {xAxisIndex: 0, start: 30, end: 70},\n      //      {yAxisIndex: 0, start: 20, end: 80}\n      // ]\n      // In this case, [20, 80] of y-dataZoom should be based on data\n      // that have filtered by x-dataZoom using range of [30, 70],\n      // but should not be based on full raw data. Thus sliding\n      // x-dataZoom will change both ranges of xAxis and yAxis,\n      // while sliding y-dataZoom will only change the range of yAxis.\n      // So we should filter x-axis after reset x-axis immediately,\n      // and then reset y-axis and filter y-axis.\n\n      dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n        dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);\n      });\n    });\n    ecModel.eachComponent(\'dataZoom\', function (dataZoomModel) {\n      // Fullfill all of the range props so that user\n      // is able to get them from chart.getOption().\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        var percentRange = axisProxy.getDataPercentWindow();\n        var valueRange = axisProxy.getDataValueWindow();\n        dataZoomModel.setCalculatedRange({\n          start: percentRange[0],\n          end: percentRange[1],\n          startValue: valueRange[0],\n          endValue: valueRange[1]\n        });\n      }\n    });\n  }\n};\n/* harmony default export */ var dataZoom_dataZoomProcessor = (dataZoomProcessor);\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\nfunction installDataZoomAction(registers) {\n  registers.registerAction(\'dataZoom\', function (payload, ecModel) {\n    var effectedModels = Object(helper["c" /* findEffectedDataZooms */])(ecModel, payload);\n    Object(util["k" /* each */])(effectedModels, function (dataZoomModel) {\n      dataZoomModel.setRawRange({\n        start: payload.start,\n        end: payload.end,\n        startValue: payload.startValue,\n        endValue: payload.endValue\n      });\n    });\n  });\n}\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/installCommon.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\nvar installed = false;\nfunction installCommon(registers) {\n  if (installed) {\n    return;\n  }\n\n  installed = true;\n  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoom_dataZoomProcessor);\n  installDataZoomAction(registers);\n  registers.registerSubTypeDefaulter(\'dataZoom\', function () {\n    // Default \'slider\' when no type specified.\n    return \'slider\';\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/component/dataZoom/installCommon.js_+_3_modules?')},1830:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__("6d8b");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/SeriesData.js\nvar SeriesData = __webpack_require__("b682");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/createDimensions.js\nvar createDimensions = __webpack_require__("b1d4");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/dimensionHelper.js\nvar dimensionHelper = __webpack_require__("2f45");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__("e0d3");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/core/CoordinateSystem.js\nvar CoordinateSystem = __webpack_require__("1f39");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/model/referHelper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Helper for model references.\n * There are many manners to refer axis/coordSys.\n */\n// TODO\n// merge relevant logic to this file?\n// check: "modelHelper" of tooltip and "BrushTargetManager".\n\n\n/**\n * @class\n * For example:\n * {\n *     coordSysName: \'cartesian2d\',\n *     coordSysDims: [\'x\', \'y\', ...],\n *     axisMap: HashMap({\n *         x: xAxisModel,\n *         y: yAxisModel\n *     }),\n *     categoryAxisMap: HashMap({\n *         x: xAxisModel,\n *         y: undefined\n *     }),\n *     // The index of the first category axis in `coordSysDims`.\n *     // `null/undefined` means no category axis exists.\n *     firstCategoryDimIndex: 1,\n *     // To replace user specified encode.\n * }\n */\n\nvar referHelper_CoordSysInfo =\n/** @class */\nfunction () {\n  function CoordSysInfo(coordSysName) {\n    this.coordSysDims = [];\n    this.axisMap = Object(util["f" /* createHashMap */])();\n    this.categoryAxisMap = Object(util["f" /* createHashMap */])();\n    this.coordSysName = coordSysName;\n  }\n\n  return CoordSysInfo;\n}();\n\nfunction getCoordSysInfoBySeries(seriesModel) {\n  var coordSysName = seriesModel.get(\'coordinateSystem\');\n  var result = new referHelper_CoordSysInfo(coordSysName);\n  var fetch = fetchers[coordSysName];\n\n  if (fetch) {\n    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);\n    return result;\n  }\n}\nvar fetchers = {\n  cartesian2d: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var xAxisModel = seriesModel.getReferringComponents(\'xAxis\', model["b" /* SINGLE_REFERRING */]).models[0];\n    var yAxisModel = seriesModel.getReferringComponents(\'yAxis\', model["b" /* SINGLE_REFERRING */]).models[0];\n\n    if (false) {}\n\n    result.coordSysDims = [\'x\', \'y\'];\n    axisMap.set(\'x\', xAxisModel);\n    axisMap.set(\'y\', yAxisModel);\n\n    if (isCategory(xAxisModel)) {\n      categoryAxisMap.set(\'x\', xAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n\n    if (isCategory(yAxisModel)) {\n      categoryAxisMap.set(\'y\', yAxisModel);\n      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);\n    }\n  },\n  singleAxis: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var singleAxisModel = seriesModel.getReferringComponents(\'singleAxis\', model["b" /* SINGLE_REFERRING */]).models[0];\n\n    if (false) {}\n\n    result.coordSysDims = [\'single\'];\n    axisMap.set(\'single\', singleAxisModel);\n\n    if (isCategory(singleAxisModel)) {\n      categoryAxisMap.set(\'single\', singleAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n  },\n  polar: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var polarModel = seriesModel.getReferringComponents(\'polar\', model["b" /* SINGLE_REFERRING */]).models[0];\n    var radiusAxisModel = polarModel.findAxisModel(\'radiusAxis\');\n    var angleAxisModel = polarModel.findAxisModel(\'angleAxis\');\n\n    if (false) {}\n\n    result.coordSysDims = [\'radius\', \'angle\'];\n    axisMap.set(\'radius\', radiusAxisModel);\n    axisMap.set(\'angle\', angleAxisModel);\n\n    if (isCategory(radiusAxisModel)) {\n      categoryAxisMap.set(\'radius\', radiusAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n\n    if (isCategory(angleAxisModel)) {\n      categoryAxisMap.set(\'angle\', angleAxisModel);\n      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);\n    }\n  },\n  geo: function (seriesModel, result, axisMap, categoryAxisMap) {\n    result.coordSysDims = [\'lng\', \'lat\'];\n  },\n  parallel: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var ecModel = seriesModel.ecModel;\n    var parallelModel = ecModel.getComponent(\'parallel\', seriesModel.get(\'parallelIndex\'));\n    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();\n    Object(util["k" /* each */])(parallelModel.parallelAxisIndex, function (axisIndex, index) {\n      var axisModel = ecModel.getComponent(\'parallelAxis\', axisIndex);\n      var axisDim = coordSysDims[index];\n      axisMap.set(axisDim, axisModel);\n\n      if (isCategory(axisModel)) {\n        categoryAxisMap.set(axisDim, axisModel);\n\n        if (result.firstCategoryDimIndex == null) {\n          result.firstCategoryDimIndex = index;\n        }\n      }\n    });\n  }\n};\n\nfunction isCategory(axisModel) {\n  return axisModel.get(\'type\') === \'category\';\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/Source.js\nvar Source = __webpack_require__("ec6f");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/dataStackHelper.js\nvar dataStackHelper = __webpack_require__("ee1a");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/sourceHelper.js\nvar sourceHelper = __webpack_require__("0f99");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/types.js\nvar types = __webpack_require__("07fd");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesData.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getCoordSysDimDefs(seriesModel, coordSysInfo) {\n  var coordSysName = seriesModel.get(\'coordinateSystem\');\n  var registeredCoordSys = CoordinateSystem["a" /* default */].get(coordSysName);\n  var coordSysDimDefs;\n\n  if (coordSysInfo && coordSysInfo.coordSysDims) {\n    coordSysDimDefs = util["F" /* map */](coordSysInfo.coordSysDims, function (dim) {\n      var dimInfo = {\n        name: dim\n      };\n      var axisModel = coordSysInfo.axisMap.get(dim);\n\n      if (axisModel) {\n        var axisType = axisModel.get(\'type\');\n        dimInfo.type = Object(dimensionHelper["a" /* getDimensionTypeByAxis */])(axisType);\n      }\n\n      return dimInfo;\n    });\n  }\n\n  if (!coordSysDimDefs) {\n    // Get dimensions from registered coordinate system\n    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || [\'x\', \'y\'];\n  }\n\n  return coordSysDimDefs;\n}\n\nfunction injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {\n  var firstCategoryDimIndex;\n  var hasNameEncode;\n  coordSysInfo && util["k" /* each */](dimInfoList, function (dimInfo, dimIndex) {\n    var coordDim = dimInfo.coordDim;\n    var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);\n\n    if (categoryAxisModel) {\n      if (firstCategoryDimIndex == null) {\n        firstCategoryDimIndex = dimIndex;\n      }\n\n      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();\n\n      if (createInvertedIndices) {\n        dimInfo.createInvertedIndices = true;\n      }\n    }\n\n    if (dimInfo.otherDims.itemName != null) {\n      hasNameEncode = true;\n    }\n  });\n\n  if (!hasNameEncode && firstCategoryDimIndex != null) {\n    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;\n  }\n\n  return firstCategoryDimIndex;\n}\n/**\n * Caution: there are side effects to `sourceManager` in this method.\n * Should better only be called in `Series[\'getInitialData\']`.\n */\n\n\nfunction createSeriesData(sourceRaw, seriesModel, opt) {\n  opt = opt || {};\n  var sourceManager = seriesModel.getSourceManager();\n  var source;\n  var isOriginalSource = false;\n\n  if (sourceRaw) {\n    isOriginalSource = true;\n    source = Object(Source["c" /* createSourceFromSeriesDataOption */])(sourceRaw);\n  } else {\n    source = sourceManager.getSource(); // Is series.data. not dataset.\n\n    isOriginalSource = source.sourceFormat === types["f" /* SOURCE_FORMAT_ORIGINAL */];\n  }\n\n  var coordSysInfo = getCoordSysInfoBySeries(seriesModel);\n  var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);\n  var useEncodeDefaulter = opt.useEncodeDefaulter;\n  var encodeDefaulter = util["v" /* isFunction */](useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? util["h" /* curry */](sourceHelper["c" /* makeSeriesEncodeForAxisCoordSys */], coordSysDimDefs, seriesModel) : null;\n  var createDimensionOptions = {\n    coordDimensions: coordSysDimDefs,\n    generateCoord: opt.generateCoord,\n    encodeDefine: seriesModel.getEncode(),\n    encodeDefaulter: encodeDefaulter,\n    canOmitUnusedDimensions: !isOriginalSource\n  };\n  var schema = Object(createDimensions["a" /* default */])(source, createDimensionOptions);\n  var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);\n  var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;\n  var stackCalculationInfo = Object(dataStackHelper["a" /* enableDataStack */])(seriesModel, {\n    schema: schema,\n    store: store\n  });\n  var data = new SeriesData["a" /* default */](schema, seriesModel);\n  data.setCalculationInfo(stackCalculationInfo);\n  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n    // Use dataIndex as ordinal value in categoryAxis\n    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);\n  } : null;\n  data.hasItemOption = false;\n  data.initData( // Try to reuse the data store in sourceManager if using dataset.\n  isOriginalSource ? source : store, null, dimValueGetter);\n  return data;\n}\n\nfunction isNeedCompleteOrdinalData(source) {\n  if (source.sourceFormat === types["f" /* SOURCE_FORMAT_ORIGINAL */]) {\n    var sampleItem = firstDataNotNull(source.data || []);\n    return !util["s" /* isArray */](Object(model["g" /* getDataItemValue */])(sampleItem));\n  }\n}\n\nfunction firstDataNotNull(arr) {\n  var i = 0;\n\n  while (i < arr.length && arr[i] == null) {\n    i++;\n  }\n\n  return arr[i];\n}\n\n/* harmony default export */ var helper_createSeriesData = __webpack_exports__["a"] = (createSeriesData);\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/chart/helper/createSeriesData.js_+_1_modules?')},3094:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ install_install; });\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(\"22b4\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(\"7fae\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\nvar DataZoomModel = __webpack_require__(\"3a56\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nvar SelectZoomModel_SelectDataZoomModel =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(SelectDataZoomModel, _super);\n\n  function SelectDataZoomModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = SelectDataZoomModel.type;\n    return _this;\n  }\n\n  SelectDataZoomModel.type = 'dataZoom.select';\n  return SelectDataZoomModel;\n}(DataZoomModel[\"a\" /* default */]);\n\n/* harmony default export */ var SelectZoomModel = (SelectZoomModel_SelectDataZoomModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\nvar DataZoomView = __webpack_require__(\"7dcf\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nvar SelectZoomView_SelectDataZoomView =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(SelectDataZoomView, _super);\n\n  function SelectDataZoomView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = SelectDataZoomView.type;\n    return _this;\n  }\n\n  SelectDataZoomView.type = 'dataZoom.select';\n  return SelectDataZoomView;\n}(DataZoomView[\"a\" /* default */]);\n\n/* harmony default export */ var SelectZoomView = (SelectZoomView_SelectDataZoomView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/installCommon.js + 3 modules\nvar installCommon = __webpack_require__(\"1459\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/installDataZoomSelect.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(SelectZoomModel);\n  registers.registerComponentView(SelectZoomView);\n  Object(installCommon[\"a\" /* default */])(registers);\n}\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(\"6d8b\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/toolbox/featureManager.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\nvar ToolboxFeature =\n/** @class */\nfunction () {\n  function ToolboxFeature() {}\n\n  return ToolboxFeature;\n}();\n\n\nvar featureManager_features = {};\nfunction registerFeature(name, ctor) {\n  featureManager_features[name] = ctor;\n}\nfunction getFeature(name) {\n  return featureManager_features[name];\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Component.js\nvar Component = __webpack_require__(\"6cb7\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/toolbox/ToolboxModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\nvar ToolboxModel_ToolboxModel =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(ToolboxModel, _super);\n\n  function ToolboxModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = ToolboxModel.type;\n    return _this;\n  }\n\n  ToolboxModel.prototype.optionUpdated = function () {\n    _super.prototype.optionUpdated.apply(this, arguments);\n\n    var ecModel = this.ecModel;\n    util[\"k\" /* each */](this.option.feature, function (featureOpt, featureName) {\n      var Feature = getFeature(featureName);\n\n      if (Feature) {\n        if (Feature.getDefaultOption) {\n          Feature.defaultOption = Feature.getDefaultOption(ecModel);\n        }\n\n        util[\"G\" /* merge */](featureOpt, Feature.defaultOption);\n      }\n    });\n  };\n\n  ToolboxModel.type = 'toolbox';\n  ToolboxModel.layoutMode = {\n    type: 'box',\n    ignoreSize: true\n  };\n  ToolboxModel.defaultOption = {\n    show: true,\n    z: 6,\n    // zlevel: 0,\n    orient: 'horizontal',\n    left: 'right',\n    top: 'top',\n    // right\n    // bottom\n    backgroundColor: 'transparent',\n    borderColor: '#ccc',\n    borderRadius: 0,\n    borderWidth: 0,\n    padding: 5,\n    itemSize: 15,\n    itemGap: 8,\n    showTitle: true,\n    iconStyle: {\n      borderColor: '#666',\n      color: 'none'\n    },\n    emphasis: {\n      iconStyle: {\n        borderColor: '#3E98C5'\n      }\n    },\n    // textStyle: {},\n    // feature\n    tooltip: {\n      show: false,\n      position: 'bottom'\n    }\n  };\n  return ToolboxModel;\n}(Component[\"a\" /* default */]);\n\n/* harmony default export */ var toolbox_ToolboxModel = (ToolboxModel_ToolboxModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/contain/text.js\nvar contain_text = __webpack_require__(\"e86a\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js + 8 modules\nvar graphic = __webpack_require__(\"2306\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(\"7d6c\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(\"4319\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/DataDiffer.js\nvar DataDiffer = __webpack_require__(\"80f0\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/listComponent.js\nvar listComponent = __webpack_require__(\"7919\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar view_Component = __webpack_require__(\"b12f\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/component.js\nvar component = __webpack_require__(\"8918\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(\"76a5\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/toolbox/ToolboxView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar ToolboxView_ToolboxView =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(ToolboxView, _super);\n\n  function ToolboxView() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ToolboxView.prototype.render = function (toolboxModel, ecModel, api, payload) {\n    var group = this.group;\n    group.removeAll();\n\n    if (!toolboxModel.get('show')) {\n      return;\n    }\n\n    var itemSize = +toolboxModel.get('itemSize');\n    var featureOpts = toolboxModel.get('feature') || {};\n    var features = this._features || (this._features = {});\n    var featureNames = [];\n    util[\"k\" /* each */](featureOpts, function (opt, name) {\n      featureNames.push(name);\n    });\n    new DataDiffer[\"a\" /* default */](this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(util[\"h\" /* curry */](processFeature, null)).execute(); // Keep for diff.\n\n    this._featureNames = featureNames;\n\n    function processFeature(newIndex, oldIndex) {\n      var featureName = featureNames[newIndex];\n      var oldName = featureNames[oldIndex];\n      var featureOpt = featureOpts[featureName];\n      var featureModel = new Model[\"a\" /* default */](featureOpt, toolboxModel, toolboxModel.ecModel);\n      var feature; // FIX#11236, merge feature title from MagicType newOption. TODO: consider seriesIndex ?\n\n      if (payload && payload.newTitle != null && payload.featureName === featureName) {\n        featureOpt.title = payload.newTitle;\n      }\n\n      if (featureName && !oldName) {\n        // Create\n        if (isUserFeatureName(featureName)) {\n          feature = {\n            onclick: featureModel.option.onclick,\n            featureName: featureName\n          };\n        } else {\n          var Feature = getFeature(featureName);\n\n          if (!Feature) {\n            return;\n          }\n\n          feature = new Feature();\n        }\n\n        features[featureName] = feature;\n      } else {\n        feature = features[oldName]; // If feature does not exsit.\n\n        if (!feature) {\n          return;\n        }\n      }\n\n      feature.uid = Object(component[\"c\" /* getUID */])('toolbox-feature');\n      feature.model = featureModel;\n      feature.ecModel = ecModel;\n      feature.api = api;\n      var isToolboxFeature = feature instanceof ToolboxFeature;\n\n      if (!featureName && oldName) {\n        isToolboxFeature && feature.dispose && feature.dispose(ecModel, api);\n        return;\n      }\n\n      if (!featureModel.get('show') || isToolboxFeature && feature.unusable) {\n        isToolboxFeature && feature.remove && feature.remove(ecModel, api);\n        return;\n      }\n\n      createIconPaths(featureModel, feature, featureName);\n\n      featureModel.setIconStatus = function (iconName, status) {\n        var option = this.option;\n        var iconPaths = this.iconPaths;\n        option.iconStatus = option.iconStatus || {};\n        option.iconStatus[iconName] = status;\n\n        if (iconPaths[iconName]) {\n          (status === 'emphasis' ? states[\"o\" /* enterEmphasis */] : states[\"z\" /* leaveEmphasis */])(iconPaths[iconName]);\n        }\n      };\n\n      if (feature instanceof ToolboxFeature) {\n        if (feature.render) {\n          feature.render(featureModel, ecModel, api, payload);\n        }\n      }\n    }\n\n    function createIconPaths(featureModel, feature, featureName) {\n      var iconStyleModel = featureModel.getModel('iconStyle');\n      var iconStyleEmphasisModel = featureModel.getModel(['emphasis', 'iconStyle']); // If one feature has mutiple icon. they are orginaized as\n      // {\n      //     icon: {\n      //         foo: '',\n      //         bar: ''\n      //     },\n      //     title: {\n      //         foo: '',\n      //         bar: ''\n      //     }\n      // }\n\n      var icons = feature instanceof ToolboxFeature && feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n      var titles = featureModel.get('title') || {};\n      var iconsMap;\n      var titlesMap;\n\n      if (util[\"A\" /* isString */](icons)) {\n        iconsMap = {};\n        iconsMap[featureName] = icons;\n      } else {\n        iconsMap = icons;\n      }\n\n      if (util[\"A\" /* isString */](titles)) {\n        titlesMap = {};\n        titlesMap[featureName] = titles;\n      } else {\n        titlesMap = titles;\n      }\n\n      var iconPaths = featureModel.iconPaths = {};\n      util[\"k\" /* each */](iconsMap, function (iconStr, iconName) {\n        var path = graphic[\"createIcon\"](iconStr, {}, {\n          x: -itemSize / 2,\n          y: -itemSize / 2,\n          width: itemSize,\n          height: itemSize\n        }); // TODO handling image\n\n        path.setStyle(iconStyleModel.getItemStyle());\n        var pathEmphasisState = path.ensureState('emphasis');\n        pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle(); // Text position calculation\n\n        var textContent = new Text[\"a\" /* default */]({\n          style: {\n            text: titlesMap[iconName],\n            align: iconStyleEmphasisModel.get('textAlign'),\n            borderRadius: iconStyleEmphasisModel.get('textBorderRadius'),\n            padding: iconStyleEmphasisModel.get('textPadding'),\n            fill: null\n          },\n          ignore: true\n        });\n        path.setTextContent(textContent);\n        graphic[\"setTooltipConfig\"]({\n          el: path,\n          componentModel: toolboxModel,\n          itemName: iconName,\n          formatterParamsExtra: {\n            title: titlesMap[iconName]\n          }\n        }); // graphic.enableHoverEmphasis(path);\n\n        path.__title = titlesMap[iconName];\n        path.on('mouseover', function () {\n          // Should not reuse above hoverStyle, which might be modified.\n          var hoverStyle = iconStyleEmphasisModel.getItemStyle();\n          var defaultTextPosition = toolboxModel.get('orient') === 'vertical' ? toolboxModel.get('right') == null ? 'right' : 'left' : toolboxModel.get('bottom') == null ? 'bottom' : 'top';\n          textContent.setStyle({\n            fill: iconStyleEmphasisModel.get('textFill') || hoverStyle.fill || hoverStyle.stroke || '#000',\n            backgroundColor: iconStyleEmphasisModel.get('textBackgroundColor')\n          });\n          path.setTextConfig({\n            position: iconStyleEmphasisModel.get('textPosition') || defaultTextPosition\n          });\n          textContent.ignore = !toolboxModel.get('showTitle'); // Use enterEmphasis and leaveEmphasis provide by ec.\n          // There are flags managed by the echarts.\n\n          Object(states[\"o\" /* enterEmphasis */])(this);\n        }).on('mouseout', function () {\n          if (featureModel.get(['iconStatus', iconName]) !== 'emphasis') {\n            Object(states[\"z\" /* leaveEmphasis */])(this);\n          }\n\n          textContent.hide();\n        });\n        (featureModel.get(['iconStatus', iconName]) === 'emphasis' ? states[\"o\" /* enterEmphasis */] : states[\"z\" /* leaveEmphasis */])(path);\n        group.add(path);\n        path.on('click', util[\"c\" /* bind */](feature.onclick, feature, ecModel, api, iconName));\n        iconPaths[iconName] = path;\n      });\n    }\n\n    listComponent[\"a\" /* layout */](group, toolboxModel, api); // Render background after group is layout\n    // FIXME\n\n    group.add(listComponent[\"b\" /* makeBackground */](group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen\n\n    group.eachChild(function (icon) {\n      var titleText = icon.__title; // const hoverStyle = icon.hoverStyle;\n      // TODO simplify code?\n\n      var emphasisState = icon.ensureState('emphasis');\n      var emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {});\n      var textContent = icon.getTextContent();\n      var emphasisTextState = textContent && textContent.states.emphasis; // May be background element\n\n      if (emphasisTextState && !util[\"v\" /* isFunction */](emphasisTextState) && titleText) {\n        var emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {});\n        var rect = contain_text[\"d\" /* getBoundingRect */](titleText, Text[\"a\" /* default */].makeFont(emphasisTextStyle));\n        var offsetX = icon.x + group.x;\n        var offsetY = icon.y + group.y + itemSize;\n        var needPutOnTop = false;\n\n        if (offsetY + rect.height > api.getHeight()) {\n          emphasisTextConfig.position = 'top';\n          needPutOnTop = true;\n        }\n\n        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;\n\n        if (offsetX + rect.width / 2 > api.getWidth()) {\n          emphasisTextConfig.position = ['100%', topOffset];\n          emphasisTextStyle.align = 'right';\n        } else if (offsetX - rect.width / 2 < 0) {\n          emphasisTextConfig.position = [0, topOffset];\n          emphasisTextStyle.align = 'left';\n        }\n      }\n    });\n  };\n\n  ToolboxView.prototype.updateView = function (toolboxModel, ecModel, api, payload) {\n    util[\"k\" /* each */](this._features, function (feature) {\n      feature instanceof ToolboxFeature && feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n    });\n  }; // updateLayout(toolboxModel, ecModel, api, payload) {\n  //     zrUtil.each(this._features, function (feature) {\n  //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n  //     });\n  // },\n\n\n  ToolboxView.prototype.remove = function (ecModel, api) {\n    util[\"k\" /* each */](this._features, function (feature) {\n      feature instanceof ToolboxFeature && feature.remove && feature.remove(ecModel, api);\n    });\n    this.group.removeAll();\n  };\n\n  ToolboxView.prototype.dispose = function (ecModel, api) {\n    util[\"k\" /* each */](this._features, function (feature) {\n      feature instanceof ToolboxFeature && feature.dispose && feature.dispose(ecModel, api);\n    });\n  };\n\n  ToolboxView.type = 'toolbox';\n  return ToolboxView;\n}(view_Component[\"a\" /* default */]);\n\nfunction isUserFeatureName(featureName) {\n  return featureName.indexOf('my') === 0;\n}\n\n/* harmony default export */ var toolbox_ToolboxView = (ToolboxView_ToolboxView);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/env.js\nvar env = __webpack_require__(\"22d1\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Uint8Array, document */\n\n\n\n\n/* global window, document */\n\nvar SaveAsImage_SaveAsImage =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(SaveAsImage, _super);\n\n  function SaveAsImage() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SaveAsImage.prototype.onclick = function (ecModel, api) {\n    var model = this.model;\n    var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n    var isSvg = api.getZr().painter.getType() === 'svg';\n    var type = isSvg ? 'svg' : model.get('type', true) || 'png';\n    var url = api.getConnectedDataURL({\n      type: type,\n      backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',\n      connectedBackgroundColor: model.get('connectedBackgroundColor'),\n      excludeComponents: model.get('excludeComponents'),\n      pixelRatio: model.get('pixelRatio')\n    });\n    var browser = env[\"a\" /* default */].browser; // Chrome, Firefox, New Edge\n\n    if (Object(util[\"v\" /* isFunction */])(MouseEvent) && (browser.newEdge || !browser.ie && !browser.edge)) {\n      var $a = document.createElement('a');\n      $a.download = title + '.' + type;\n      $a.target = '_blank';\n      $a.href = url;\n      var evt = new MouseEvent('click', {\n        // some micro front-end framework， window maybe is a Proxy\n        view: document.defaultView,\n        bubbles: true,\n        cancelable: false\n      });\n      $a.dispatchEvent(evt);\n    } // IE or old Edge\n    else {\n        // @ts-ignore\n        if (window.navigator.msSaveOrOpenBlob || isSvg) {\n          var parts = url.split(','); // data:[<mime type>][;charset=<charset>][;base64],<encoded data>\n\n          var base64Encoded = parts[0].indexOf('base64') > -1;\n          var bstr = isSvg // should decode the svg data uri first\n          ? decodeURIComponent(parts[1]) : parts[1]; // only `atob` when the data uri is encoded with base64\n          // otherwise, like `svg` data uri exported by zrender,\n          // there will be an error, for it's not encoded with base64.\n          // (just a url-encoded string through `encodeURIComponent`)\n\n          base64Encoded && (bstr = window.atob(bstr));\n          var filename = title + '.' + type; // @ts-ignore\n\n          if (window.navigator.msSaveOrOpenBlob) {\n            var n = bstr.length;\n            var u8arr = new Uint8Array(n);\n\n            while (n--) {\n              u8arr[n] = bstr.charCodeAt(n);\n            }\n\n            var blob = new Blob([u8arr]); // @ts-ignore\n\n            window.navigator.msSaveOrOpenBlob(blob, filename);\n          } else {\n            var frame = document.createElement('iframe');\n            document.body.appendChild(frame);\n            var cw = frame.contentWindow;\n            var doc = cw.document;\n            doc.open('image/svg+xml', 'replace');\n            doc.write(bstr);\n            doc.close();\n            cw.focus();\n            doc.execCommand('SaveAs', true, filename);\n            document.body.removeChild(frame);\n          }\n        } else {\n          var lang = model.get('lang');\n          var html = '' + '<body style=\"margin:0;\">' + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + (lang && lang[0] || '') + '\" />' + '</body>';\n          var tab = window.open();\n          tab.document.write(html);\n          tab.document.title = title;\n        }\n      }\n  };\n\n  SaveAsImage.getDefaultOption = function (ecModel) {\n    var defaultOption = {\n      show: true,\n      icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n      title: ecModel.getLocaleModel().get(['toolbox', 'saveAsImage', 'title']),\n      type: 'png',\n      // Default use option.backgroundColor\n      // backgroundColor: '#fff',\n      connectedBackgroundColor: '#fff',\n      name: '',\n      excludeComponents: ['toolbox'],\n      // use current pixel ratio of device by default\n      // pixelRatio: 1,\n      lang: ecModel.getLocaleModel().get(['toolbox', 'saveAsImage', 'lang'])\n    };\n    return defaultOption;\n  };\n\n  return SaveAsImage;\n}(ToolboxFeature);\n\n/* harmony default export */ var feature_SaveAsImage = (SaveAsImage_SaveAsImage);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/core/echarts.js + 19 modules\nvar echarts = __webpack_require__(\"1be7\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar util_model = __webpack_require__(\"e0d3\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/toolbox/feature/MagicType.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\nvar INNER_STACK_KEYWORD = '__ec_magicType_stack__';\nvar ICON_TYPES = ['line', 'bar', 'stack']; // stack and tiled appears in pair for the title\n\nvar TITLE_TYPES = ['line', 'bar', 'stack', 'tiled'];\nvar radioTypes = [['line', 'bar'], ['stack']];\n\nvar MagicType_MagicType =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(MagicType, _super);\n\n  function MagicType() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  MagicType.prototype.getIcons = function () {\n    var model = this.model;\n    var availableIcons = model.get('icon');\n    var icons = {};\n    util[\"k\" /* each */](model.get('type'), function (type) {\n      if (availableIcons[type]) {\n        icons[type] = availableIcons[type];\n      }\n    });\n    return icons;\n  };\n\n  MagicType.getDefaultOption = function (ecModel) {\n    var defaultOption = {\n      show: true,\n      type: [],\n      // Icon group\n      icon: {\n        line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n        bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n        // eslint-disable-next-line\n        stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z' // jshint ignore:line\n\n      },\n      // `line`, `bar`, `stack`, `tiled`\n      title: ecModel.getLocaleModel().get(['toolbox', 'magicType', 'title']),\n      option: {},\n      seriesIndex: {}\n    };\n    return defaultOption;\n  };\n\n  MagicType.prototype.onclick = function (ecModel, api, type) {\n    var model = this.model;\n    var seriesIndex = model.get(['seriesIndex', type]); // Not supported magicType\n\n    if (!seriesOptGenreator[type]) {\n      return;\n    }\n\n    var newOption = {\n      series: []\n    };\n\n    var generateNewSeriesTypes = function (seriesModel) {\n      var seriesType = seriesModel.subType;\n      var seriesId = seriesModel.id;\n      var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);\n\n      if (newSeriesOpt) {\n        // PENDING If merge original option?\n        util[\"i\" /* defaults */](newSeriesOpt, seriesModel.option);\n        newOption.series.push(newSeriesOpt);\n      } // Modify boundaryGap\n\n\n      var coordSys = seriesModel.coordinateSystem;\n\n      if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n        var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n        if (categoryAxis) {\n          var axisDim = categoryAxis.dim;\n          var axisType = axisDim + 'Axis';\n          var axisModel = seriesModel.getReferringComponents(axisType, util_model[\"b\" /* SINGLE_REFERRING */]).models[0];\n          var axisIndex = axisModel.componentIndex;\n          newOption[axisType] = newOption[axisType] || [];\n\n          for (var i = 0; i <= axisIndex; i++) {\n            newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n          }\n\n          newOption[axisType][axisIndex].boundaryGap = type === 'bar';\n        }\n      }\n    };\n\n    util[\"k\" /* each */](radioTypes, function (radio) {\n      if (util[\"q\" /* indexOf */](radio, type) >= 0) {\n        util[\"k\" /* each */](radio, function (item) {\n          model.setIconStatus(item, 'normal');\n        });\n      }\n    });\n    model.setIconStatus(type, 'emphasis');\n    ecModel.eachComponent({\n      mainType: 'series',\n      query: seriesIndex == null ? null : {\n        seriesIndex: seriesIndex\n      }\n    }, generateNewSeriesTypes);\n    var newTitle;\n    var currentType = type; // Change title of stack\n\n    if (type === 'stack') {\n      // use titles in model instead of ecModel\n      // as stack and tiled appears in pair, just flip them\n      // no need of checking stack state\n      newTitle = util[\"G\" /* merge */]({\n        stack: model.option.title.tiled,\n        tiled: model.option.title.stack\n      }, model.option.title);\n\n      if (model.get(['iconStatus', type]) !== 'emphasis') {\n        currentType = 'tiled';\n      }\n    }\n\n    api.dispatchAction({\n      type: 'changeMagicType',\n      currentType: currentType,\n      newOption: newOption,\n      newTitle: newTitle,\n      featureName: 'magicType'\n    });\n  };\n\n  return MagicType;\n}(ToolboxFeature);\n\nvar seriesOptGenreator = {\n  'line': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'bar') {\n      return util[\"G\" /* merge */]({\n        id: seriesId,\n        type: 'line',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get(['option', 'line']) || {}, true);\n    }\n  },\n  'bar': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line') {\n      return util[\"G\" /* merge */]({\n        id: seriesId,\n        type: 'bar',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get(['option', 'bar']) || {}, true);\n    }\n  },\n  'stack': function (seriesType, seriesId, seriesModel, model) {\n    var isStack = seriesModel.get('stack') === INNER_STACK_KEYWORD;\n\n    if (seriesType === 'line' || seriesType === 'bar') {\n      model.setIconStatus('stack', isStack ? 'normal' : 'emphasis');\n      return util[\"G\" /* merge */]({\n        id: seriesId,\n        stack: isStack ? '' : INNER_STACK_KEYWORD\n      }, model.get(['option', 'stack']) || {}, true);\n    }\n  }\n}; // TODO: SELF REGISTERED.\n\necharts[\"c\" /* registerAction */]({\n  type: 'changeMagicType',\n  event: 'magicTypeChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.mergeOption(payload.newOption);\n});\n/* harmony default export */ var feature_MagicType = (MagicType_MagicType);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/event.js\nvar core_event = __webpack_require__(\"607d\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/toolbox/feature/DataView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global document */\n\n\n\n\n\n/* global document */\n\nvar BLOCK_SPLITER = new Array(60).join('-');\nvar ITEM_SPLITER = '\\t';\n/**\n * Group series into two types\n *  1. on category axis, like line, bar\n *  2. others, like scatter, pie\n */\n\nfunction groupSeries(ecModel) {\n  var seriesGroupByCategoryAxis = {};\n  var otherSeries = [];\n  var meta = [];\n  ecModel.eachRawSeries(function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n      // TODO: TYPE Consider polar? Include polar may increase unecessary bundle size.\n      var baseAxis = coordSys.getBaseAxis();\n\n      if (baseAxis.type === 'category') {\n        var key = baseAxis.dim + '_' + baseAxis.index;\n\n        if (!seriesGroupByCategoryAxis[key]) {\n          seriesGroupByCategoryAxis[key] = {\n            categoryAxis: baseAxis,\n            valueAxis: coordSys.getOtherAxis(baseAxis),\n            series: []\n          };\n          meta.push({\n            axisDim: baseAxis.dim,\n            axisIndex: baseAxis.index\n          });\n        }\n\n        seriesGroupByCategoryAxis[key].series.push(seriesModel);\n      } else {\n        otherSeries.push(seriesModel);\n      }\n    } else {\n      otherSeries.push(seriesModel);\n    }\n  });\n  return {\n    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n    other: otherSeries,\n    meta: meta\n  };\n}\n/**\n * Assemble content of series on cateogory axis\n * @inner\n */\n\n\nfunction assembleSeriesWithCategoryAxis(groups) {\n  var tables = [];\n  util[\"k\" /* each */](groups, function (group, key) {\n    var categoryAxis = group.categoryAxis;\n    var valueAxis = group.valueAxis;\n    var valueAxisDim = valueAxis.dim;\n    var headers = [' '].concat(util[\"F\" /* map */](group.series, function (series) {\n      return series.name;\n    })); // @ts-ignore TODO Polar\n\n    var columns = [categoryAxis.model.getCategories()];\n    util[\"k\" /* each */](group.series, function (series) {\n      var rawData = series.getRawData();\n      columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function (val) {\n        return val;\n      }));\n    }); // Assemble table content\n\n    var lines = [headers.join(ITEM_SPLITER)];\n\n    for (var i = 0; i < columns[0].length; i++) {\n      var items = [];\n\n      for (var j = 0; j < columns.length; j++) {\n        items.push(columns[j][i]);\n      }\n\n      lines.push(items.join(ITEM_SPLITER));\n    }\n\n    tables.push(lines.join('\\n'));\n  });\n  return tables.join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\n * Assemble content of other series\n */\n\n\nfunction assembleOtherSeries(series) {\n  return util[\"F\" /* map */](series, function (series) {\n    var data = series.getRawData();\n    var lines = [series.name];\n    var vals = [];\n    data.each(data.dimensions, function () {\n      var argLen = arguments.length;\n      var dataIndex = arguments[argLen - 1];\n      var name = data.getName(dataIndex);\n\n      for (var i = 0; i < argLen - 1; i++) {\n        vals[i] = arguments[i];\n      }\n\n      lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));\n    });\n    return lines.join('\\n');\n  }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n\nfunction getContentFromModel(ecModel) {\n  var result = groupSeries(ecModel);\n  return {\n    value: util[\"n\" /* filter */]([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {\n      return !!str.replace(/[\\n\\t\\s]/g, '');\n    }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n    meta: result.meta\n  };\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n}\n/**\n * If a block is tsv format\n */\n\n\nfunction isTSVFormat(block) {\n  // Simple method to find out if a block is tsv format\n  var firstLine = block.slice(0, block.indexOf('\\n'));\n\n  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n    return true;\n  }\n}\n\nvar itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n/**\n * @param {string} tsv\n * @return {Object}\n */\n\nfunction parseTSVContents(tsv) {\n  var tsvLines = tsv.split(/\\n+/g);\n  var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n  var categories = [];\n  var series = util[\"F\" /* map */](headers, function (header) {\n    return {\n      name: header,\n      data: []\n    };\n  });\n\n  for (var i = 0; i < tsvLines.length; i++) {\n    var items = trim(tsvLines[i]).split(itemSplitRegex);\n    categories.push(items.shift());\n\n    for (var j = 0; j < items.length; j++) {\n      series[j] && (series[j].data[i] = items[j]);\n    }\n  }\n\n  return {\n    series: series,\n    categories: categories\n  };\n}\n\nfunction parseListContents(str) {\n  var lines = str.split(/\\n+/g);\n  var seriesName = trim(lines.shift());\n  var data = [];\n\n  for (var i = 0; i < lines.length; i++) {\n    // if line is empty, ignore it.\n    // there is a case that a user forgot to delete `\\n`.\n    var line = trim(lines[i]);\n\n    if (!line) {\n      continue;\n    }\n\n    var items = line.split(itemSplitRegex);\n    var name_1 = '';\n    var value = void 0;\n    var hasName = false;\n\n    if (isNaN(items[0])) {\n      // First item is name\n      hasName = true;\n      name_1 = items[0];\n      items = items.slice(1);\n      data[i] = {\n        name: name_1,\n        value: []\n      };\n      value = data[i].value;\n    } else {\n      value = data[i] = [];\n    }\n\n    for (var j = 0; j < items.length; j++) {\n      value.push(+items[j]);\n    }\n\n    if (value.length === 1) {\n      hasName ? data[i].value = value[0] : data[i] = value[0];\n    }\n  }\n\n  return {\n    name: seriesName,\n    data: data\n  };\n}\n\nfunction parseContents(str, blockMetaList) {\n  var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n  var newOption = {\n    series: []\n  };\n  util[\"k\" /* each */](blocks, function (block, idx) {\n    if (isTSVFormat(block)) {\n      var result = parseTSVContents(block);\n      var blockMeta = blockMetaList[idx];\n      var axisKey = blockMeta.axisDim + 'Axis';\n\n      if (blockMeta) {\n        newOption[axisKey] = newOption[axisKey] || [];\n        newOption[axisKey][blockMeta.axisIndex] = {\n          data: result.categories\n        };\n        newOption.series = newOption.series.concat(result.series);\n      }\n    } else {\n      var result = parseListContents(block);\n      newOption.series.push(result);\n    }\n  });\n  return newOption;\n}\n\nvar DataView_DataView =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(DataView, _super);\n\n  function DataView() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DataView.prototype.onclick = function (ecModel, api) {\n    // FIXME: better way?\n    setTimeout(function () {\n      api.dispatchAction({\n        type: 'hideTip'\n      });\n    });\n    var container = api.getDom();\n    var model = this.model;\n\n    if (this._dom) {\n      container.removeChild(this._dom);\n    }\n\n    var root = document.createElement('div'); // use padding to avoid 5px whitespace\n\n    root.style.cssText = 'position:absolute;top:0;bottom:0;left:0;right:0;padding:5px';\n    root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements\n\n    var header = document.createElement('h4');\n    var lang = model.get('lang') || [];\n    header.innerHTML = lang[0] || model.get('title');\n    header.style.cssText = 'margin:10px 20px';\n    header.style.color = model.get('textColor');\n    var viewMain = document.createElement('div');\n    var textarea = document.createElement('textarea');\n    viewMain.style.cssText = 'overflow:auto';\n    var optionToContent = model.get('optionToContent');\n    var contentToOption = model.get('contentToOption');\n    var result = getContentFromModel(ecModel);\n\n    if (util[\"v\" /* isFunction */](optionToContent)) {\n      var htmlOrDom = optionToContent(api.getOption());\n\n      if (util[\"A\" /* isString */](htmlOrDom)) {\n        viewMain.innerHTML = htmlOrDom;\n      } else if (util[\"u\" /* isDom */](htmlOrDom)) {\n        viewMain.appendChild(htmlOrDom);\n      }\n    } else {\n      // Use default textarea\n      textarea.readOnly = model.get('readOnly');\n      var style = textarea.style; // eslint-disable-next-line max-len\n\n      style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none';\n      style.color = model.get('textColor');\n      style.borderColor = model.get('textareaBorderColor');\n      style.backgroundColor = model.get('textareaColor');\n      textarea.value = result.value;\n      viewMain.appendChild(textarea);\n    }\n\n    var blockMetaList = result.meta;\n    var buttonContainer = document.createElement('div');\n    buttonContainer.style.cssText = 'position:absolute;bottom:5px;left:0;right:0'; // eslint-disable-next-line max-len\n\n    var buttonStyle = 'float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n    var closeButton = document.createElement('div');\n    var refreshButton = document.createElement('div');\n    buttonStyle += ';background-color:' + model.get('buttonColor');\n    buttonStyle += ';color:' + model.get('buttonTextColor');\n    var self = this;\n\n    function close() {\n      container.removeChild(root);\n      self._dom = null;\n    }\n\n    Object(core_event[\"a\" /* addEventListener */])(closeButton, 'click', close);\n    Object(core_event[\"a\" /* addEventListener */])(refreshButton, 'click', function () {\n      if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {\n        if (false) {}\n\n        close();\n        return;\n      }\n\n      var newOption;\n\n      try {\n        if (util[\"v\" /* isFunction */](contentToOption)) {\n          newOption = contentToOption(viewMain, api.getOption());\n        } else {\n          newOption = parseContents(textarea.value, blockMetaList);\n        }\n      } catch (e) {\n        close();\n        throw new Error('Data view format error ' + e);\n      }\n\n      if (newOption) {\n        api.dispatchAction({\n          type: 'changeDataView',\n          newOption: newOption\n        });\n      }\n\n      close();\n    });\n    closeButton.innerHTML = lang[1];\n    refreshButton.innerHTML = lang[2];\n    refreshButton.style.cssText = closeButton.style.cssText = buttonStyle;\n    !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n    buttonContainer.appendChild(closeButton);\n    root.appendChild(header);\n    root.appendChild(viewMain);\n    root.appendChild(buttonContainer);\n    viewMain.style.height = container.clientHeight - 80 + 'px';\n    container.appendChild(root);\n    this._dom = root;\n  };\n\n  DataView.prototype.remove = function (ecModel, api) {\n    this._dom && api.getDom().removeChild(this._dom);\n  };\n\n  DataView.prototype.dispose = function (ecModel, api) {\n    this.remove(ecModel, api);\n  };\n\n  DataView.getDefaultOption = function (ecModel) {\n    var defaultOption = {\n      show: true,\n      readOnly: false,\n      optionToContent: null,\n      contentToOption: null,\n      // eslint-disable-next-line\n      icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n      title: ecModel.getLocaleModel().get(['toolbox', 'dataView', 'title']),\n      lang: ecModel.getLocaleModel().get(['toolbox', 'dataView', 'lang']),\n      backgroundColor: '#fff',\n      textColor: '#000',\n      textareaColor: '#fff',\n      textareaBorderColor: '#333',\n      buttonColor: '#c23531',\n      buttonTextColor: '#fff'\n    };\n    return defaultOption;\n  };\n\n  return DataView;\n}(ToolboxFeature);\n/**\n * @inner\n */\n\n\nfunction tryMergeDataOption(newData, originalData) {\n  return util[\"F\" /* map */](newData, function (newVal, idx) {\n    var original = originalData && originalData[idx];\n\n    if (util[\"z\" /* isObject */](original) && !util[\"s\" /* isArray */](original)) {\n      var newValIsObject = util[\"z\" /* isObject */](newVal) && !util[\"s\" /* isArray */](newVal);\n\n      if (!newValIsObject) {\n        newVal = {\n          value: newVal\n        };\n      } // original data has name but new data has no name\n\n\n      var shouldDeleteName = original.name != null && newVal.name == null; // Original data has option\n\n      newVal = util[\"i\" /* defaults */](newVal, original);\n      shouldDeleteName && delete newVal.name;\n      return newVal;\n    } else {\n      return newVal;\n    }\n  });\n} // TODO: SELF REGISTERED.\n\n\necharts[\"c\" /* registerAction */]({\n  type: 'changeDataView',\n  event: 'dataViewChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  var newSeriesOptList = [];\n  util[\"k\" /* each */](payload.newOption.series, function (seriesOpt) {\n    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n\n    if (!seriesModel) {\n      // New created series\n      // Geuss the series type\n      newSeriesOptList.push(util[\"m\" /* extend */]({\n        // Default is scatter\n        type: 'scatter'\n      }, seriesOpt));\n    } else {\n      var originalData = seriesModel.get('data');\n      newSeriesOptList.push({\n        name: seriesOpt.name,\n        data: tryMergeDataOption(seriesOpt.data, originalData)\n      });\n    }\n  });\n  ecModel.mergeOption(util[\"i\" /* defaults */]({\n    series: newSeriesOptList\n  }, payload.newOption));\n});\n/* harmony default export */ var feature_DataView = (DataView_DataView);\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/dataZoom/history.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\nvar each = util[\"k\" /* each */];\nvar inner = Object(util_model[\"m\" /* makeInner */])();\n/**\n * @param ecModel\n * @param newSnapshot key is dataZoomId\n */\n\nfunction push(ecModel, newSnapshot) {\n  var storedSnapshots = getStoreSnapshots(ecModel); // If previous dataZoom can not be found,\n  // complete an range with current range.\n\n  each(newSnapshot, function (batchItem, dataZoomId) {\n    var i = storedSnapshots.length - 1;\n\n    for (; i >= 0; i--) {\n      var snapshot = storedSnapshots[i];\n\n      if (snapshot[dataZoomId]) {\n        break;\n      }\n    }\n\n    if (i < 0) {\n      // No origin range set, create one by current range.\n      var dataZoomModel = ecModel.queryComponents({\n        mainType: 'dataZoom',\n        subType: 'select',\n        id: dataZoomId\n      })[0];\n\n      if (dataZoomModel) {\n        var percentRange = dataZoomModel.getPercentRange();\n        storedSnapshots[0][dataZoomId] = {\n          dataZoomId: dataZoomId,\n          start: percentRange[0],\n          end: percentRange[1]\n        };\n      }\n    }\n  });\n  storedSnapshots.push(newSnapshot);\n}\nfunction pop(ecModel) {\n  var storedSnapshots = getStoreSnapshots(ecModel);\n  var head = storedSnapshots[storedSnapshots.length - 1];\n  storedSnapshots.length > 1 && storedSnapshots.pop(); // Find top for all dataZoom.\n\n  var snapshot = {};\n  each(head, function (batchItem, dataZoomId) {\n    for (var i = storedSnapshots.length - 1; i >= 0; i--) {\n      batchItem = storedSnapshots[i][dataZoomId];\n\n      if (batchItem) {\n        snapshot[dataZoomId] = batchItem;\n        break;\n      }\n    }\n  });\n  return snapshot;\n}\nfunction clear(ecModel) {\n  inner(ecModel).snapshots = null;\n}\nfunction count(ecModel) {\n  return getStoreSnapshots(ecModel).length;\n}\n/**\n * History length of each dataZoom may be different.\n * this._history[0] is used to store origin range.\n */\n\nfunction getStoreSnapshots(ecModel) {\n  var store = inner(ecModel);\n\n  if (!store.snapshots) {\n    store.snapshots = [{}];\n  }\n\n  return store.snapshots;\n}\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/toolbox/feature/Restore.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\nvar Restore_RestoreOption =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(RestoreOption, _super);\n\n  function RestoreOption() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  RestoreOption.prototype.onclick = function (ecModel, api) {\n    clear(ecModel);\n    api.dispatchAction({\n      type: 'restore',\n      from: this.uid\n    });\n  };\n\n  RestoreOption.getDefaultOption = function (ecModel) {\n    var defaultOption = {\n      show: true,\n      // eslint-disable-next-line\n      icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n      title: ecModel.getLocaleModel().get(['toolbox', 'restore', 'title'])\n    };\n    return defaultOption;\n  };\n\n  return RestoreOption;\n}(ToolboxFeature); // TODO: SELF REGISTERED.\n\n\necharts[\"c\" /* registerAction */]({\n  type: 'restore',\n  event: 'restore',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.resetOption('recreate');\n});\n/* harmony default export */ var Restore = (Restore_RestoreOption);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/Eventful.js\nvar Eventful = __webpack_require__(\"6fd3\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(\"2dc5\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(\"c7a2\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polyline.js\nvar Polyline = __webpack_require__(\"d498\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polygon.js\nvar Polygon = __webpack_require__(\"87b1\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/interactionMutex.js\nvar interactionMutex = __webpack_require__(\"a4fe\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/helper/BrushController.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\nvar BRUSH_PANEL_GLOBAL = true;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(210,219,238,0.3)',\n    fill: '#D2DBEE'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * params:\n *     areas: Array.<Array>, coord relates to container group,\n *                             If no container specified, to global.\n *     opt {\n *         isEnd: boolean,\n *         removeOnClick: boolean\n *     }\n */\n\nvar BrushController_BrushController =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(BrushController, _super);\n\n  function BrushController(zr) {\n    var _this = _super.call(this) || this;\n    /**\n     * @internal\n     */\n\n\n    _this._track = [];\n    /**\n     * @internal\n     */\n\n    _this._covers = [];\n    _this._handlers = {};\n\n    if (false) {}\n\n    _this._zr = zr;\n    _this.group = new Group[\"a\" /* default */]();\n    _this._uid = 'brushController_' + baseUID++;\n    Object(util[\"k\" /* each */])(pointerHandlers, function (handler, eventName) {\n      this._handlers[eventName] = Object(util[\"c\" /* bind */])(handler, this);\n    }, _this);\n    return _this;\n  }\n  /**\n   * If set to `false`, select disabled.\n   */\n\n\n  BrushController.prototype.enableBrush = function (brushOption) {\n    if (false) {}\n\n    this._brushType && this._doDisableBrush();\n    brushOption.brushType && this._doEnableBrush(brushOption);\n    return this;\n  };\n\n  BrushController.prototype._doEnableBrush = function (brushOption) {\n    var zr = this._zr; // Consider roam, which takes globalPan too.\n\n    if (!this._enableGlobalPan) {\n      interactionMutex[\"c\" /* take */](zr, MUTEX_RESOURCE_KEY, this._uid);\n    }\n\n    Object(util[\"k\" /* each */])(this._handlers, function (handler, eventName) {\n      zr.on(eventName, handler);\n    });\n    this._brushType = brushOption.brushType;\n    this._brushOption = Object(util[\"G\" /* merge */])(Object(util[\"d\" /* clone */])(DEFAULT_BRUSH_OPT), brushOption, true);\n  };\n\n  BrushController.prototype._doDisableBrush = function () {\n    var zr = this._zr;\n    interactionMutex[\"b\" /* release */](zr, MUTEX_RESOURCE_KEY, this._uid);\n    Object(util[\"k\" /* each */])(this._handlers, function (handler, eventName) {\n      zr.off(eventName, handler);\n    });\n    this._brushType = this._brushOption = null;\n  };\n  /**\n   * @param panelOpts If not pass, it is global brush.\n   */\n\n\n  BrushController.prototype.setPanels = function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels_1 = this._panels = {};\n      Object(util[\"k\" /* each */])(panelOpts, function (panelOpts) {\n        panels_1[panelOpts.panelId] = Object(util[\"d\" /* clone */])(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  };\n\n  BrushController.prototype.mount = function (opt) {\n    opt = opt || {};\n\n    if (false) {}\n\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      x: opt.x || 0,\n      y: opt.y || 0,\n      rotation: opt.rotation || 0,\n      scaleX: opt.scaleX || 1,\n      scaleY: opt.scaleY || 1\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  }; // eachCover(cb, context): void {\n  //     each(this._covers, cb, context);\n  // }\n\n  /**\n   * Update covers.\n   * @param coverConfigList\n   *        If coverConfigList is null/undefined, all covers removed.\n   */\n\n\n  BrushController.prototype.updateCovers = function (coverConfigList) {\n    if (false) {}\n\n    coverConfigList = Object(util[\"F\" /* map */])(coverConfigList, function (coverConfig) {\n      return Object(util[\"G\" /* merge */])(Object(util[\"d\" /* clone */])(DEFAULT_BRUSH_OPT), coverConfig, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer[\"a\" /* default */](oldCovers, coverConfigList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushInternal = coverConfigList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  };\n\n  BrushController.prototype.unmount = function () {\n    if (false) {}\n\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    if (false) {}\n\n    return this;\n  };\n\n  BrushController.prototype.dispose = function () {\n    this.unmount();\n    this.off();\n  };\n\n  return BrushController;\n}(Eventful[\"a\" /* default */]);\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return BRUSH_PANEL_GLOBAL; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  Object(util[\"k\" /* each */])(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return BRUSH_PANEL_GLOBAL; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  Object(util[\"k\" /* each */])(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = Object(util[\"F\" /* map */])(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = Object(util[\"d\" /* clone */])(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', {\n    areas: areas,\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\n;\n\nfunction createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {\n  var cover = new Group[\"a\" /* default */]();\n  cover.add(new Rect[\"a\" /* default */]({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: Object(util[\"h\" /* curry */])(driftRect, rectRangeConverter, controller, cover, ['n', 's', 'w', 'e']),\n    ondragend: Object(util[\"h\" /* curry */])(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  Object(util[\"k\" /* each */])(edgeNameSequences, function (nameSequence) {\n    cover.add(new Rect[\"a\" /* default */]({\n      name: nameSequence.join(''),\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: Object(util[\"h\" /* curry */])(driftRect, rectRangeConverter, controller, cover, nameSequence),\n      ondragend: Object(util[\"h\" /* curry */])(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  Object(util[\"k\" /* each */])([['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']], function (nameSequence) {\n    var el = cover.childOfName(nameSequence.join(''));\n    var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return Object(util[\"i\" /* defaults */])({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic[\"getTransform\"](controller.group);\n}\n\nfunction getGlobalDirection1(controller, localDirName) {\n  var map = {\n    w: 'left',\n    e: 'right',\n    n: 'top',\n    s: 'bottom'\n  };\n  var inverseMap = {\n    left: 'w',\n    right: 'e',\n    top: 'n',\n    bottom: 's'\n  };\n  var dir = graphic[\"transformDirection\"](map[localDirName], getTransform(controller));\n  return inverseMap[dir];\n}\n\nfunction getGlobalDirection2(controller, localDirNameSeq) {\n  var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];\n  (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n  return globalDir.join('');\n}\n\nfunction driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {\n  var brushOption = cover.__brushOption;\n  var rectRange = rectRangeConverter.toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  Object(util[\"k\" /* each */])(dirNameSequence, function (dirName) {\n    var ind = DIRECTION_MAP[dirName];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  Object(util[\"k\" /* each */])(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : Object(util[\"d\" /* clone */])(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  if ( // Check active\n  !controller._brushType // resetCursor should be always called when mouse is in zr area,\n  // but not called when mouse is out of zr area to avoid bad influence\n  // if `mousemove`, `mouseup` are triggered from `document` event.\n  || isOutsideZrArea(controller, e.offsetX, e.offsetY)) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = Object(util[\"d\" /* clone */])(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    if (false) {}\n\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar pointerHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mouse out side the browser.\n      handleDragEnd(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = this.group.transformCoordToLocal(x, y);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: function (e) {\n    handleDragEnd(this, e);\n  }\n};\n\nfunction handleDragEnd(controller, e) {\n  if (controller._dragging) {\n    preventDefault(e);\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = controller.group.transformCoordToLocal(x, y);\n    var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);\n    controller._dragging = false;\n    controller._track = [];\n    controller._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(controller, eventParams);\n  }\n}\n\nfunction isOutsideZrArea(controller, x, y) {\n  var zr = controller._zr;\n  return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();\n}\n/**\n * key: brushType\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      function returnInput(range) {\n        return range;\n      }\n\n      return createBaseRectCover({\n        toRectRange: returnInput,\n        fromRectRange: returnInput\n      }, controller, brushOption, [['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new Group[\"a\" /* default */](); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new Polyline[\"a\" /* default */]({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new Polygon[\"a\" /* default */]({\n        name: 'main',\n        draggable: true,\n        drift: Object(util[\"h\" /* curry */])(driftPolygon, controller, cover),\n        ondragend: Object(util[\"h\" /* curry */])(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover({\n        toRectRange: function (range) {\n          var rectRange = [range, [0, 100]];\n          xyIndex && rectRange.reverse();\n          return rectRange;\n        },\n        fromRectRange: function (rectRange) {\n          return rectRange[xyIndex];\n        }\n      }, controller, brushOption, [[['w'], ['e']], [['n'], ['s']]][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\n/* harmony default export */ var helper_BrushController = (BrushController_BrushController);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__(\"9850\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/helper/cursorHelper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar IRRELEVANT_EXCLUDES = {\n  'axisPointer': 1,\n  'tooltip': 1,\n  'brush': 1\n};\n/**\n * Avoid that: mouse click on a elements that is over geo or graph,\n * but roam is triggered.\n */\n\nfunction onIrrelevantElement(e, api, targetCoordSysModel) {\n  var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.\n\n  var coordSys = model && model.coordinateSystem;\n  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES.hasOwnProperty(model.mainType) && coordSys && coordSys.model !== targetCoordSysModel;\n}\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/helper/brushHelper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nfunction makeRectPanelClipPath(rect) {\n  rect = normalizeRect(rect);\n  return function (localPoints) {\n    return graphic[\"clipPointsByRect\"](localPoints, rect);\n  };\n}\nfunction makeLinearBrushOtherExtent(rect, specifiedXYIndex) {\n  rect = normalizeRect(rect);\n  return function (xyIndex) {\n    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n    var brushWidth = idx ? rect.width : rect.height;\n    var base = idx ? rect.x : rect.y;\n    return [base, base + (brushWidth || 0)];\n  };\n}\nfunction makeRectIsTargetByCursor(rect, api, targetModel) {\n  var boundingRect = normalizeRect(rect);\n  return function (e, localCursorPoint) {\n    return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);\n  };\n} // Consider width/height is negative.\n\nfunction normalizeRect(rect) {\n  return BoundingRect[\"a\" /* default */].create(rect);\n}\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/helper/BrushTargetManager.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n\nvar BrushTargetManager_BrushTargetManager =\n/** @class */\nfunction () {\n  /**\n   * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid\n   *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n   * @param opt.include include coordinate system types.\n   */\n  function BrushTargetManager(finder, ecModel, opt) {\n    var _this = this;\n\n    this._targetInfoList = [];\n    var foundCpts = parseFinder(ecModel, finder);\n    Object(util[\"k\" /* each */])(targetInfoBuilders, function (builder, type) {\n      if (!opt || !opt.include || Object(util[\"q\" /* indexOf */])(opt.include, type) >= 0) {\n        builder(foundCpts, _this._targetInfoList);\n      }\n    });\n  }\n\n  BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {\n    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n      (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n      if (!area.coordRange) {\n        area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n        // rebuild range by coordRange accrately, which may bring trouble when\n        // brushing only one item. So we use __rangeOffset to rebuilding range\n        // by coordRange. And this it only used in brush component so it is no\n        // need to be adapted to coordRanges.\n\n        var result = coordConvert[area.brushType](0, coordSys, coordRange);\n        area.__rangeOffset = {\n          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n          xyMinMax: result.xyMinMax\n        };\n      }\n    });\n    return areas;\n  };\n\n  BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {\n    Object(util[\"k\" /* each */])(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (targetInfo && targetInfo !== true) {\n        Object(util[\"k\" /* each */])(targetInfo.coordSyses, function (coordSys) {\n          var result = coordConvert[area.brushType](1, coordSys, area.range, true);\n          cb(area, result.values, coordSys, ecModel);\n        });\n      }\n    }, this);\n  };\n  /**\n   * the `areas` is `BrushModel.areas`.\n   * Called in layout stage.\n   * convert `area.coordRange` to global range and set panelId to `area.range`.\n   */\n\n\n  BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {\n    Object(util[\"k\" /* each */])(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (false) {}\n\n      area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n      if (targetInfo && targetInfo !== true) {\n        area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n        // not keep its original value, for the sake of the dataZoom scenario,\n        // where area.coordRange remains unchanged but area.range may be changed.\n        // (2) Only support converting one coordRange to pixel range in brush\n        // component. So do not consider `coordRanges`.\n        // (3) About __rangeOffset, see comment above.\n\n        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n        var rangeOffset = area.__rangeOffset;\n        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n      }\n    }, this);\n  };\n\n  BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {\n    return Object(util[\"F\" /* map */])(this._targetInfoList, function (targetInfo) {\n      var rect = targetInfo.getPanelRect();\n      return {\n        panelId: targetInfo.panelId,\n        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,\n        clipPath: makeRectPanelClipPath(rect),\n        isTargetByCursor: makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n        getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)\n      };\n    });\n  };\n\n  BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {\n    // Check whether area is bound in coord, and series do not belong to that coord.\n    // If do not do this check, some brush (like lineX) will controll all axes.\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    return targetInfo === true || targetInfo && Object(util[\"q\" /* indexOf */])(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n  };\n  /**\n   * If return Object, a coord found.\n   * If reutrn true, global found.\n   * Otherwise nothing found.\n   */\n\n\n  BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {\n    var targetInfoList = this._targetInfoList;\n    var foundCpts = parseFinder(ecModel, area);\n\n    for (var i = 0; i < targetInfoList.length; i++) {\n      var targetInfo = targetInfoList[i];\n      var areaPanelId = area.panelId;\n\n      if (areaPanelId) {\n        if (targetInfo.panelId === areaPanelId) {\n          return targetInfo;\n        }\n      } else {\n        for (var j = 0; j < targetInfoMatchers.length; j++) {\n          if (targetInfoMatchers[j](foundCpts, targetInfo)) {\n            return targetInfo;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  return BrushTargetManager;\n}();\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, finder) {\n  return Object(util_model[\"q\" /* parseFinder */])(ecModel, finder, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = Object(util[\"f\" /* createHashMap */])();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    Object(util[\"k\" /* each */])(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    Object(util[\"k\" /* each */])(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    Object(util[\"k\" /* each */])(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      Object(util[\"k\" /* each */])(grid.getCartesians(), function (cartesian, index) {\n        if (Object(util[\"q\" /* indexOf */])(xAxisModels, cartesian.getAxis('x').model) >= 0 || Object(util[\"q\" /* indexOf */])(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilders.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    Object(util[\"k\" /* each */])(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilders.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilders = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.master.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic[\"getTransform\"](coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: Object(util[\"h\" /* curry */])(axisConvert, 0),\n  lineY: Object(util[\"h\" /* curry */])(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp);\n    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = Object(util[\"F\" /* map */])(rangeOrCoordRange, function (item) {\n      var p = to ? coordSys.pointToData(item, clamp) : coordSys.dataToPoint(item, clamp);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  if (false) {}\n\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(Object(util[\"F\" /* map */])([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: Object(util[\"h\" /* curry */])(axisDiffProcessor, 0),\n  lineY: Object(util[\"h\" /* curry */])(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return Object(util[\"F\" /* map */])(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n// Return [0~1, 0~1]\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\n/* harmony default export */ var helper_BrushTargetManager = (BrushTargetManager_BrushTargetManager);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/sliderMove.js\nvar sliderMove = __webpack_require__(\"ef6a\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/internalComponentCreator.js\nvar internalComponentCreator = __webpack_require__(\"2f1f\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n // TODO depends on DataZoom and Brush\n\n\n\n\n\n\n\n\n\nvar DataZoom_each = util[\"k\" /* each */];\nvar DATA_ZOOM_ID_BASE = Object(util_model[\"n\" /* makeInternalComponentId */])('toolbox-dataZoom_');\nvar DataZoom_ICON_TYPES = ['zoom', 'back'];\n\nvar DataZoom_DataZoomFeature =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(DataZoomFeature, _super);\n\n  function DataZoomFeature() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DataZoomFeature.prototype.render = function (featureModel, ecModel, api, payload) {\n    if (!this._brushController) {\n      this._brushController = new helper_BrushController(api.getZr());\n\n      this._brushController.on('brush', util[\"c\" /* bind */](this._onBrush, this)).mount();\n    }\n\n    updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n    updateBackBtnStatus(featureModel, ecModel);\n  };\n\n  DataZoomFeature.prototype.onclick = function (ecModel, api, type) {\n    handlers[type].call(this);\n  };\n\n  DataZoomFeature.prototype.remove = function (ecModel, api) {\n    this._brushController && this._brushController.unmount();\n  };\n\n  DataZoomFeature.prototype.dispose = function (ecModel, api) {\n    this._brushController && this._brushController.dispose();\n  };\n\n  DataZoomFeature.prototype._onBrush = function (eventParam) {\n    var areas = eventParam.areas;\n\n    if (!eventParam.isEnd || !areas.length) {\n      return;\n    }\n\n    var snapshot = {};\n    var ecModel = this.ecModel;\n\n    this._brushController.updateCovers([]); // remove cover\n\n\n    var brushTargetManager = new helper_BrushTargetManager(makeAxisFinder(this.model), ecModel, {\n      include: ['grid']\n    });\n    brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n      if (coordSys.type !== 'cartesian2d') {\n        return;\n      }\n\n      var brushType = area.brushType;\n\n      if (brushType === 'rect') {\n        setBatch('x', coordSys, coordRange[0]);\n        setBatch('y', coordSys, coordRange[1]);\n      } else {\n        setBatch({\n          lineX: 'x',\n          lineY: 'y'\n        }[brushType], coordSys, coordRange);\n      }\n    });\n    push(ecModel, snapshot);\n\n    this._dispatchZoomAction(snapshot);\n\n    function setBatch(dimName, coordSys, minMax) {\n      var axis = coordSys.getAxis(dimName);\n      var axisModel = axis.model;\n      var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range.\n\n      var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n\n      if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n        minMax = Object(sliderMove[\"a\" /* default */])(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);\n      }\n\n      dataZoomModel && (snapshot[dataZoomModel.id] = {\n        dataZoomId: dataZoomModel.id,\n        startValue: minMax[0],\n        endValue: minMax[1]\n      });\n    }\n\n    function findDataZoom(dimName, axisModel, ecModel) {\n      var found;\n      ecModel.eachComponent({\n        mainType: 'dataZoom',\n        subType: 'select'\n      }, function (dzModel) {\n        var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n        has && (found = dzModel);\n      });\n      return found;\n    }\n  };\n\n  ;\n\n  DataZoomFeature.prototype._dispatchZoomAction = function (snapshot) {\n    var batch = []; // Convert from hash map to array.\n\n    DataZoom_each(snapshot, function (batchItem, dataZoomId) {\n      batch.push(util[\"d\" /* clone */](batchItem));\n    });\n    batch.length && this.api.dispatchAction({\n      type: 'dataZoom',\n      from: this.uid,\n      batch: batch\n    });\n  };\n\n  DataZoomFeature.getDefaultOption = function (ecModel) {\n    var defaultOption = {\n      show: true,\n      filterMode: 'filter',\n      // Icon group\n      icon: {\n        zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n        back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n      },\n      // `zoom`, `back`\n      title: ecModel.getLocaleModel().get(['toolbox', 'dataZoom', 'title']),\n      brushStyle: {\n        borderWidth: 0,\n        color: 'rgba(210,219,238,0.2)'\n      }\n    };\n    return defaultOption;\n  };\n\n  return DataZoomFeature;\n}(ToolboxFeature);\n\nvar handlers = {\n  zoom: function () {\n    var nextActive = !this._isZoomActive;\n    this.api.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: nextActive\n    });\n  },\n  back: function () {\n    this._dispatchZoomAction(pop(this.ecModel));\n  }\n};\n\nfunction makeAxisFinder(dzFeatureModel) {\n  var setting = {\n    xAxisIndex: dzFeatureModel.get('xAxisIndex', true),\n    yAxisIndex: dzFeatureModel.get('yAxisIndex', true),\n    xAxisId: dzFeatureModel.get('xAxisId', true),\n    yAxisId: dzFeatureModel.get('yAxisId', true)\n  }; // If both `xAxisIndex` `xAxisId` not set, it means 'all'.\n  // If both `yAxisIndex` `yAxisId` not set, it means 'all'.\n  // Some old cases set like this below to close yAxis control but leave xAxis control:\n  // `{ feature: { dataZoom: { yAxisIndex: false } }`.\n\n  if (setting.xAxisIndex == null && setting.xAxisId == null) {\n    setting.xAxisIndex = 'all';\n  }\n\n  if (setting.yAxisIndex == null && setting.yAxisId == null) {\n    setting.yAxisIndex = 'all';\n  }\n\n  return setting;\n}\n\nfunction updateBackBtnStatus(featureModel, ecModel) {\n  featureModel.setIconStatus('back', count(ecModel) > 1 ? 'emphasis' : 'normal');\n}\n\nfunction updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n  var zoomActive = view._isZoomActive;\n\n  if (payload && payload.type === 'takeGlobalCursor') {\n    zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;\n  }\n\n  view._isZoomActive = zoomActive;\n  featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n  var brushTargetManager = new helper_BrushTargetManager(makeAxisFinder(featureModel), ecModel, {\n    include: ['grid']\n  });\n  var panels = brushTargetManager.makePanelOpts(api, function (targetInfo) {\n    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';\n  });\n\n  view._brushController.setPanels(panels).enableBrush(zoomActive && panels.length ? {\n    brushType: 'auto',\n    brushStyle: featureModel.getModel('brushStyle').getItemStyle()\n  } : false);\n}\n\nObject(internalComponentCreator[\"b\" /* registerInternalOptionCreator */])('dataZoom', function (ecModel) {\n  var toolboxModel = ecModel.getComponent('toolbox', 0);\n  var featureDataZoomPath = ['feature', 'dataZoom'];\n\n  if (!toolboxModel || toolboxModel.get(featureDataZoomPath) == null) {\n    return;\n  }\n\n  var dzFeatureModel = toolboxModel.getModel(featureDataZoomPath);\n  var dzOptions = [];\n  var finder = makeAxisFinder(dzFeatureModel);\n  var finderResult = Object(util_model[\"q\" /* parseFinder */])(ecModel, finder);\n  DataZoom_each(finderResult.xAxisModels, function (axisModel) {\n    return buildInternalOptions(axisModel, 'xAxis', 'xAxisIndex');\n  });\n  DataZoom_each(finderResult.yAxisModels, function (axisModel) {\n    return buildInternalOptions(axisModel, 'yAxis', 'yAxisIndex');\n  });\n\n  function buildInternalOptions(axisModel, axisMainType, axisIndexPropName) {\n    var axisIndex = axisModel.componentIndex;\n    var newOpt = {\n      type: 'select',\n      $fromToolbox: true,\n      // Default to be filter\n      filterMode: dzFeatureModel.get('filterMode', true) || 'filter',\n      // Id for merge mapping.\n      id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex\n    };\n    newOpt[axisIndexPropName] = axisIndex;\n    dzOptions.push(newOpt);\n  }\n\n  return dzOptions;\n});\n/* harmony default export */ var DataZoom = (DataZoom_DataZoomFeature);\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/toolbox/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n // TODOD: REGISTER IN INSTALL\n\n\n\n\n\n\n\nfunction install_install(registers) {\n  registers.registerComponentModel(toolbox_ToolboxModel);\n  registers.registerComponentView(toolbox_ToolboxView);\n  registerFeature('saveAsImage', feature_SaveAsImage);\n  registerFeature('magicType', feature_MagicType);\n  registerFeature('dataView', feature_DataView);\n  registerFeature('dataZoom', DataZoom);\n  registerFeature('restore', Restore);\n  Object(extension[\"a\" /* use */])(install);\n}\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/component/toolbox/install.js_+_16_modules?")},"3a56":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"7fae\");\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"6d8b\");\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"6cb7\");\n/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"50e5\");\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"e0d3\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\nvar DataZoomAxisInfo =\n/** @class */\nfunction () {\n  function DataZoomAxisInfo() {\n    this.indexList = [];\n    this.indexMap = [];\n  }\n\n  DataZoomAxisInfo.prototype.add = function (axisCmptIdx) {\n    // Remove duplication.\n    if (!this.indexMap[axisCmptIdx]) {\n      this.indexList.push(axisCmptIdx);\n      this.indexMap[axisCmptIdx] = true;\n    }\n  };\n\n  return DataZoomAxisInfo;\n}();\n\nvar DataZoomModel =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"a\"])(DataZoomModel, _super);\n\n  function DataZoomModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = DataZoomModel.type;\n    _this._autoThrottle = true;\n    _this._noTarget = true;\n    /**\n     * It is `[rangeModeForMin, rangeModeForMax]`.\n     * The optional values for `rangeMode`:\n     * + `'value'` mode: the axis extent will always be determined by\n     *     `dataZoom.startValue` and `dataZoom.endValue`, despite\n     *     how data like and how `axis.min` and `axis.max` are.\n     * + `'percent'` mode: `100` represents 100% of the `[dMin, dMax]`,\n     *     where `dMin` is `axis.min` if `axis.min` specified, otherwise `data.extent[0]`,\n     *     and `dMax` is `axis.max` if `axis.max` specified, otherwise `data.extent[1]`.\n     *     Axis extent will be determined by the result of the percent of `[dMin, dMax]`.\n     *\n     * For example, when users are using dynamic data (update data periodically via `setOption`),\n     * if in `'value`' mode, the window will be kept in a fixed value range despite how\n     * data are appended, while if in `'percent'` mode, whe window range will be changed alone with\n     * the appended data (suppose `axis.min` and `axis.max` are not specified).\n     */\n\n    _this._rangePropMode = ['percent', 'percent'];\n    return _this;\n  }\n\n  DataZoomModel.prototype.init = function (option, parentModel, ecModel) {\n    var inputRawOption = retrieveRawOption(option);\n    /**\n     * Suppose a \"main process\" start at the point that model prepared (that is,\n     * model initialized or merged or method called in `action`).\n     * We should keep the `main process` idempotent, that is, given a set of values\n     * on `option`, we get the same result.\n     *\n     * But sometimes, values on `option` will be updated for providing users\n     * a \"final calculated value\" (`dataZoomProcessor` will do that). Those value\n     * should not be the base/input of the `main process`.\n     *\n     * So in that case we should save and keep the input of the `main process`\n     * separately, called `settledOption`.\n     *\n     * For example, consider the case:\n     * (Step_1) brush zoom the grid by `toolbox.dataZoom`,\n     *     where the original input `option.startValue`, `option.endValue` are earsed by\n     *     calculated value.\n     * (Step)2) click the legend to hide and show a series,\n     *     where the new range is calculated by the earsed `startValue` and `endValue`,\n     *     which brings incorrect result.\n     */\n\n    this.settledOption = inputRawOption;\n    this.mergeDefaultAndTheme(option, ecModel);\n\n    this._doInit(inputRawOption);\n  };\n\n  DataZoomModel.prototype.mergeOption = function (newOption) {\n    var inputRawOption = retrieveRawOption(newOption); //FIX #2591\n\n    Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* merge */ \"G\"])(this.option, newOption, true);\n    Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* merge */ \"G\"])(this.settledOption, inputRawOption, true);\n\n    this._doInit(inputRawOption);\n  };\n\n  DataZoomModel.prototype._doInit = function (inputRawOption) {\n    var thisOption = this.option;\n\n    this._setDefaultThrottle(inputRawOption);\n\n    this._updateRangeUse(inputRawOption);\n\n    var settledOption = this.settledOption;\n    Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* each */ \"k\"])([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = settledOption[names[0]] = null;\n      } // Otherwise do nothing and use the merge result.\n\n    }, this);\n\n    this._resetTarget();\n  };\n\n  DataZoomModel.prototype._resetTarget = function () {\n    var optionOrient = this.get('orient', true);\n    var targetAxisIndexMap = this._targetAxisInfoMap = Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* createHashMap */ \"f\"])();\n\n    var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);\n\n    if (hasAxisSpecified) {\n      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();\n    } else {\n      this._orient = optionOrient || 'horizontal';\n\n      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);\n    }\n\n    this._noTarget = true;\n    targetAxisIndexMap.each(function (axisInfo) {\n      if (axisInfo.indexList.length) {\n        this._noTarget = false;\n      }\n    }, this);\n  };\n\n  DataZoomModel.prototype._fillSpecifiedTargetAxis = function (targetAxisIndexMap) {\n    var hasAxisSpecified = false;\n    Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* each */ \"k\"])(_helper_js__WEBPACK_IMPORTED_MODULE_3__[/* DATA_ZOOM_AXIS_DIMENSIONS */ \"a\"], function (axisDim) {\n      var refering = this.getReferringComponents(Object(_helper_js__WEBPACK_IMPORTED_MODULE_3__[/* getAxisMainType */ \"d\"])(axisDim), _util_model_js__WEBPACK_IMPORTED_MODULE_4__[/* MULTIPLE_REFERRING */ \"a\"]); // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occured.\n\n      if (!refering.specified) {\n        return;\n      }\n\n      hasAxisSpecified = true;\n      var axisInfo = new DataZoomAxisInfo();\n      Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* each */ \"k\"])(refering.models, function (axisModel) {\n        axisInfo.add(axisModel.componentIndex);\n      });\n      targetAxisIndexMap.set(axisDim, axisInfo);\n    }, this);\n    return hasAxisSpecified;\n  };\n\n  DataZoomModel.prototype._fillAutoTargetAxisByOrient = function (targetAxisIndexMap, orient) {\n    var ecModel = this.ecModel;\n    var needAuto = true; // Find axis that parallel to dataZoom as default.\n\n    if (needAuto) {\n      var axisDim = orient === 'vertical' ? 'y' : 'x';\n      var axisModels = ecModel.findComponents({\n        mainType: axisDim + 'Axis'\n      });\n      setParallelAxis(axisModels, axisDim);\n    } // Find axis that parallel to dataZoom as default.\n\n\n    if (needAuto) {\n      var axisModels = ecModel.findComponents({\n        mainType: 'singleAxis',\n        filter: function (axisModel) {\n          return axisModel.get('orient', true) === orient;\n        }\n      });\n      setParallelAxis(axisModels, 'single');\n    }\n\n    function setParallelAxis(axisModels, axisDim) {\n      // At least use the first parallel axis as the target axis.\n      var axisModel = axisModels[0];\n\n      if (!axisModel) {\n        return;\n      }\n\n      var axisInfo = new DataZoomAxisInfo();\n      axisInfo.add(axisModel.componentIndex);\n      targetAxisIndexMap.set(axisDim, axisInfo);\n      needAuto = false; // Find parallel axes in the same grid.\n\n      if (axisDim === 'x' || axisDim === 'y') {\n        var gridModel_1 = axisModel.getReferringComponents('grid', _util_model_js__WEBPACK_IMPORTED_MODULE_4__[/* SINGLE_REFERRING */ \"b\"]).models[0];\n        gridModel_1 && Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* each */ \"k\"])(axisModels, function (axModel) {\n          if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents('grid', _util_model_js__WEBPACK_IMPORTED_MODULE_4__[/* SINGLE_REFERRING */ \"b\"]).models[0]) {\n            axisInfo.add(axModel.componentIndex);\n          }\n        });\n      }\n    }\n\n    if (needAuto) {\n      // If no parallel axis, find the first category axis as default. (Also consider polar).\n      Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* each */ \"k\"])(_helper_js__WEBPACK_IMPORTED_MODULE_3__[/* DATA_ZOOM_AXIS_DIMENSIONS */ \"a\"], function (axisDim) {\n        if (!needAuto) {\n          return;\n        }\n\n        var axisModels = ecModel.findComponents({\n          mainType: Object(_helper_js__WEBPACK_IMPORTED_MODULE_3__[/* getAxisMainType */ \"d\"])(axisDim),\n          filter: function (axisModel) {\n            return axisModel.get('type', true) === 'category';\n          }\n        });\n\n        if (axisModels[0]) {\n          var axisInfo = new DataZoomAxisInfo();\n          axisInfo.add(axisModels[0].componentIndex);\n          targetAxisIndexMap.set(axisDim, axisInfo);\n          needAuto = false;\n        }\n      }, this);\n    }\n  };\n\n  DataZoomModel.prototype._makeAutoOrientByTargetAxis = function () {\n    var dim; // Find the first axis\n\n    this.eachTargetAxis(function (axisDim) {\n      !dim && (dim = axisDim);\n    }, this);\n    return dim === 'y' ? 'vertical' : 'horizontal';\n  };\n\n  DataZoomModel.prototype._setDefaultThrottle = function (inputRawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (inputRawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  };\n\n  DataZoomModel.prototype._updateRangeUse = function (inputRawOption) {\n    var rangePropMode = this._rangePropMode;\n    var rangeModeInOption = this.get('rangeMode');\n    Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* each */ \"k\"])([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      var percentSpecified = inputRawOption[names[0]] != null;\n      var valueSpecified = inputRawOption[names[1]] != null;\n\n      if (percentSpecified && !valueSpecified) {\n        rangePropMode[index] = 'percent';\n      } else if (!percentSpecified && valueSpecified) {\n        rangePropMode[index] = 'value';\n      } else if (rangeModeInOption) {\n        rangePropMode[index] = rangeModeInOption[index];\n      } else if (percentSpecified) {\n        // percentSpecified && valueSpecified\n        rangePropMode[index] = 'percent';\n      } // else remain its original setting.\n\n    });\n  };\n\n  DataZoomModel.prototype.noTarget = function () {\n    return this._noTarget;\n  };\n\n  DataZoomModel.prototype.getFirstTargetAxisModel = function () {\n    var firstAxisModel;\n    this.eachTargetAxis(function (axisDim, axisIndex) {\n      if (firstAxisModel == null) {\n        firstAxisModel = this.ecModel.getComponent(Object(_helper_js__WEBPACK_IMPORTED_MODULE_3__[/* getAxisMainType */ \"d\"])(axisDim), axisIndex);\n      }\n    }, this);\n    return firstAxisModel;\n  };\n  /**\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n   */\n\n\n  DataZoomModel.prototype.eachTargetAxis = function (callback, context) {\n    this._targetAxisInfoMap.each(function (axisInfo, axisDim) {\n      Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* each */ \"k\"])(axisInfo.indexList, function (axisIndex) {\n        callback.call(context, axisDim, axisIndex);\n      });\n    });\n  };\n  /**\n   * @return If not found, return null/undefined.\n   */\n\n\n  DataZoomModel.prototype.getAxisProxy = function (axisDim, axisIndex) {\n    var axisModel = this.getAxisModel(axisDim, axisIndex);\n\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    }\n  };\n  /**\n   * @return If not found, return null/undefined.\n   */\n\n\n  DataZoomModel.prototype.getAxisModel = function (axisDim, axisIndex) {\n    if (false) {}\n\n    var axisInfo = this._targetAxisInfoMap.get(axisDim);\n\n    if (axisInfo && axisInfo.indexMap[axisIndex]) {\n      return this.ecModel.getComponent(Object(_helper_js__WEBPACK_IMPORTED_MODULE_3__[/* getAxisMainType */ \"d\"])(axisDim), axisIndex);\n    }\n  };\n  /**\n   * If not specified, set to undefined.\n   */\n\n\n  DataZoomModel.prototype.setRawRange = function (opt) {\n    var thisOption = this.option;\n    var settledOption = this.settledOption;\n    Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* each */ \"k\"])([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // Consider the pair <start, startValue>:\n      // If one has value and the other one is `null/undefined`, we both set them\n      // to `settledOption`. This strategy enables the feature to clear the original\n      // value in `settledOption` to `null/undefined`.\n      // But if both of them are `null/undefined`, we do not set them to `settledOption`\n      // and keep `settledOption` with the original value. This strategy enables users to\n      // only set <end or endValue> but not set <start or startValue> when calling\n      // `dispatchAction`.\n      // The pair <end, endValue> is treated in the same way.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];\n        thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];\n      }\n    }, this);\n\n    this._updateRangeUse(opt);\n  };\n\n  DataZoomModel.prototype.setCalculatedRange = function (opt) {\n    var option = this.option;\n    Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* each */ \"k\"])(['start', 'startValue', 'end', 'endValue'], function (name) {\n      option[name] = opt[name];\n    });\n  };\n\n  DataZoomModel.prototype.getPercentRange = function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  };\n  /**\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n   *\n   * @return [startValue, endValue] value can only be '-' or finite number.\n   */\n\n\n  DataZoomModel.prototype.getValueRange = function (axisDim, axisIndex) {\n    if (axisDim == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();\n    }\n  };\n  /**\n   * @param axisModel If axisModel given, find axisProxy\n   *      corresponding to the axisModel\n   */\n\n\n  DataZoomModel.prototype.findRepresentativeAxisProxy = function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    } // Find the first hosted axisProxy\n\n\n    var firstProxy;\n\n    var axisDimList = this._targetAxisInfoMap.keys();\n\n    for (var i = 0; i < axisDimList.length; i++) {\n      var axisDim = axisDimList[i];\n\n      var axisInfo = this._targetAxisInfoMap.get(axisDim);\n\n      for (var j = 0; j < axisInfo.indexList.length; j++) {\n        var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);\n\n        if (proxy.hostedBy(this)) {\n          return proxy;\n        }\n\n        if (!firstProxy) {\n          firstProxy = proxy;\n        }\n      }\n    } // If no hosted proxy found, still need to return a proxy.\n    // This case always happens in toolbox dataZoom, where axes are all hosted by\n    // other dataZooms.\n\n\n    return firstProxy;\n  };\n\n  DataZoomModel.prototype.getRangePropMode = function () {\n    return this._rangePropMode.slice();\n  };\n\n  DataZoomModel.prototype.getOrient = function () {\n    if (false) {}\n\n    return this._orient;\n  };\n\n  DataZoomModel.type = 'dataZoom';\n  DataZoomModel.dependencies = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series', 'toolbox'];\n  DataZoomModel.defaultOption = {\n    // zlevel: 0,\n    z: 4,\n    filterMode: 'filter',\n    start: 0,\n    end: 100\n  };\n  return DataZoomModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]);\n/**\n * Retrieve the those raw params from option, which will be cached separately.\n * becasue they will be overwritten by normalized/calculated values in the main\n * process.\n */\n\n\nfunction retrieveRawOption(option) {\n  var ret = {};\n  Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* each */ \"k\"])(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DataZoomModel);\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js?")},"48fb":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export statisticsAPIUrl */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return dashboard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return myStatisticsStudent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return myStatisticsTeacher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getStatByContentId; });\n/* harmony import */ var _utils_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("b775");\n\nvar BASE_PATH = \'statistics\';\nvar statisticsAPIUrl = {\n  dashboard: "/classcipe/api/".concat(BASE_PATH, "/dashboard"),\n  myStatisticsStudent: "/classcipe/api/".concat(BASE_PATH, "/myStatistics/student"),\n  myStatisticsTeacher: "/classcipe/api/".concat(BASE_PATH, "/myStatistics/teacher"),\n  getStatByContentId: "/classcipe/statistics/content/getStatByContentId"\n};\nfunction dashboard(parameter) {\n  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "d"])({\n    url: statisticsAPIUrl.dashboard,\n    method: \'post\',\n    data: parameter,\n    headers: {\n      \'Content-Type\': \'application/json;charset=UTF-8\'\n    }\n  });\n}\nfunction myStatisticsStudent(parameter) {\n  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "d"])({\n    url: statisticsAPIUrl.myStatisticsStudent,\n    method: \'post\',\n    data: parameter,\n    headers: {\n      \'Content-Type\': \'application/json;charset=UTF-8\'\n    }\n  });\n}\nfunction myStatisticsTeacher(parameter) {\n  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "d"])({\n    url: statisticsAPIUrl.myStatisticsTeacher,\n    method: \'post\',\n    data: parameter,\n    headers: {\n      \'Content-Type\': \'application/json;charset=UTF-8\'\n    }\n  });\n}\nfunction getStatByContentId(parameter) {\n  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_0__[/* default */ "d"])({\n    url: statisticsAPIUrl.getStatByContentId,\n    method: \'get\',\n    params: parameter\n  });\n}\n\n//# sourceURL=webpack:///./src/api/statistics.js?')},"4a4b":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_vue_cli_service_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_cli_service_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_cli_service_node_modules_vue_loader_lib_index_js_vue_loader_options_Dashboard_vue_vue_type_style_index_0_id_9d71548a_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("eb52");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_vue_cli_service_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_cli_service_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_cli_service_node_modules_vue_loader_lib_index_js_vue_loader_options_Dashboard_vue_vue_type_style_index_0_id_9d71548a_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_vue_cli_service_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_cli_service_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_cli_service_node_modules_vue_loader_lib_index_js_vue_loader_options_Dashboard_vue_vue_type_style_index_0_id_9d71548a_scoped_true_lang_less___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n\n//# sourceURL=webpack:///./src/views/teacher/sell/Dashboard.vue?')},"4b2a":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ install_install; });\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__("7fae");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar Component = __webpack_require__("b12f");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Component.js\nvar model_Component = __webpack_require__("6cb7");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/cartesian/GridModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nvar GridModel_GridModel =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6["a" /* __extends */])(GridModel, _super);\n\n  function GridModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GridModel.type = \'grid\';\n  GridModel.dependencies = [\'xAxis\', \'yAxis\'];\n  GridModel.layoutMode = \'box\';\n  GridModel.defaultOption = {\n    show: false,\n    // zlevel: 0,\n    z: 0,\n    left: \'10%\',\n    top: 60,\n    right: \'10%\',\n    bottom: 70,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: \'rgba(0,0,0,0)\',\n    borderWidth: 1,\n    borderColor: \'#ccc\'\n  };\n  return GridModel;\n}(model_Component["a" /* default */]);\n\n/* harmony default export */ var cartesian_GridModel = (GridModel_GridModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__("c7a2");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__("6d8b");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/axisModelCommonMixin.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nvar AxisModelCommonMixin =\n/** @class */\nfunction () {\n  function AxisModelCommonMixin() {}\n\n  AxisModelCommonMixin.prototype.getNeedCrossZero = function () {\n    var option = this.option;\n    return !option.scale;\n  };\n  /**\n   * Should be implemented by each axis model if necessary.\n   * @return coordinate system model\n   */\n\n\n  AxisModelCommonMixin.prototype.getCoordSysModel = function () {\n    return;\n  };\n\n  return AxisModelCommonMixin;\n}();\n\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar util_model = __webpack_require__("e0d3");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/cartesian/AxisModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\nvar AxisModel_CartesianAxisModel =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6["a" /* __extends */])(CartesianAxisModel, _super);\n\n  function CartesianAxisModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  CartesianAxisModel.prototype.getCoordSysModel = function () {\n    return this.getReferringComponents(\'grid\', util_model["b" /* SINGLE_REFERRING */]).models[0];\n  };\n\n  CartesianAxisModel.type = \'cartesian2dAxis\';\n  return CartesianAxisModel;\n}(model_Component["a" /* default */]);\n\n\nutil["H" /* mixin */](AxisModel_CartesianAxisModel, AxisModelCommonMixin);\n/* harmony default export */ var cartesian_AxisModel = (AxisModel_CartesianAxisModel);\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/axisDefault.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar axisDefault_defaultOption = {\n  show: true,\n  // zlevel: 0,\n  z: 0,\n  // Inverse the axis.\n  inverse: false,\n  // Axis name displayed.\n  name: \'\',\n  // \'start\' | \'middle\' | \'end\'\n  nameLocation: \'end\',\n  // By degree. By default auto rotate by nameLocation.\n  nameRotate: null,\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: \'...\',\n    placeholder: \'.\'\n  },\n  // Use global text style by default.\n  nameTextStyle: {},\n  // The gap between axisName and axisLine.\n  nameGap: 15,\n  // Default `false` to support tooltip.\n  silent: false,\n  // Default `false` to avoid legacy user event listener fail.\n  triggerEvent: false,\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  axisLine: {\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    lineStyle: {\n      color: \'#6E7079\',\n      width: 1,\n      type: \'solid\'\n    },\n    // The arrow at both ends the the axis.\n    symbol: [\'none\', \'none\'],\n    symbolSize: [10, 15]\n  },\n  axisTick: {\n    show: true,\n    // Whether axisTick is inside the grid or outside the grid.\n    inside: false,\n    // The length of axisTick.\n    length: 5,\n    lineStyle: {\n      width: 1\n    }\n  },\n  axisLabel: {\n    show: true,\n    // Whether axisLabel is inside the grid or outside the grid.\n    inside: false,\n    rotate: 0,\n    // true | false | null/undefined (auto)\n    showMinLabel: null,\n    // true | false | null/undefined (auto)\n    showMaxLabel: null,\n    margin: 8,\n    // formatter: null,\n    fontSize: 12\n  },\n  splitLine: {\n    show: true,\n    lineStyle: {\n      color: [\'#E0E6F1\'],\n      width: 1,\n      type: \'solid\'\n    }\n  },\n  splitArea: {\n    show: false,\n    areaStyle: {\n      color: [\'rgba(250,250,250,0.2)\', \'rgba(210,219,238,0.2)\']\n    }\n  }\n};\nvar categoryAxis = util["G" /* merge */]({\n  // The gap at both ends of the axis. For categoryAxis, boolean.\n  boundaryGap: true,\n  // Set false to faster category collection.\n  deduplication: null,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: \'auto\'\n  },\n  axisLabel: {\n    interval: \'auto\'\n  }\n}, axisDefault_defaultOption);\nvar valueAxis = util["G" /* merge */]({\n  boundaryGap: [0, 0],\n  axisLine: {\n    // Not shown when other axis is categoryAxis in cartesian\n    show: \'auto\'\n  },\n  axisTick: {\n    // Not shown when other axis is categoryAxis in cartesian\n    show: \'auto\'\n  },\n  // TODO\n  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]\n  splitNumber: 5,\n  minorTick: {\n    // Minor tick, not available for cateogry axis.\n    show: false,\n    // Split number of minor ticks. The value should be in range of (0, 100)\n    splitNumber: 5,\n    // Lenght of minor tick\n    length: 3,\n    // Line style\n    lineStyle: {// Default to be same with axisTick\n    }\n  },\n  minorSplitLine: {\n    show: false,\n    lineStyle: {\n      color: \'#F4F7FD\',\n      width: 1\n    }\n  }\n}, axisDefault_defaultOption);\nvar timeAxis = util["G" /* merge */]({\n  splitNumber: 6,\n  axisLabel: {\n    // To eliminate labels that are not nice\n    showMinLabel: false,\n    showMaxLabel: false,\n    rich: {\n      primary: {\n        fontWeight: \'bold\'\n      }\n    }\n  },\n  splitLine: {\n    show: false\n  }\n}, valueAxis);\nvar logAxis = util["i" /* defaults */]({\n  logBase: 10\n}, valueAxis);\n/* harmony default export */ var axisDefault = ({\n  category: categoryAxis,\n  value: valueAxis,\n  time: timeAxis,\n  log: logAxis\n});\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar util_layout = __webpack_require__("f934");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/OrdinalMeta.js\nvar OrdinalMeta = __webpack_require__("8e43");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/axisCommonTypes.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AXIS_TYPES = {\n  value: 1,\n  category: 1,\n  time: 1,\n  log: 1\n};\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/axisModelCreator.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\n/**\n * Generate sub axis model class\n * @param axisName \'x\' \'y\' \'radius\' \'angle\' \'parallel\' ...\n */\n\nfunction axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {\n  Object(util["k" /* each */])(AXIS_TYPES, function (v, axisType) {\n    var defaultOption = Object(util["G" /* merge */])(Object(util["G" /* merge */])({}, axisDefault[axisType], true), extraDefaultOption, true);\n\n    var AxisModel =\n    /** @class */\n    function (_super) {\n      Object(tslib_es6["a" /* __extends */])(AxisModel, _super);\n\n      function AxisModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = axisName + \'Axis.\' + axisType;\n        return _this;\n      }\n\n      AxisModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {\n        var layoutMode = Object(util_layout["b" /* fetchLayoutMode */])(this);\n        var inputPositionParams = layoutMode ? Object(util_layout["c" /* getLayoutParams */])(option) : {};\n        var themeModel = ecModel.getTheme();\n        Object(util["G" /* merge */])(option, themeModel.get(axisType + \'Axis\'));\n        Object(util["G" /* merge */])(option, this.getDefaultOption());\n        option.type = getAxisType(option);\n\n        if (layoutMode) {\n          Object(util_layout["e" /* mergeLayoutParam */])(option, inputPositionParams, layoutMode);\n        }\n      };\n\n      AxisModel.prototype.optionUpdated = function () {\n        var thisOption = this.option;\n\n        if (thisOption.type === \'category\') {\n          this.__ordinalMeta = OrdinalMeta["a" /* default */].createByAxisModel(this);\n        }\n      };\n      /**\n       * Should not be called before all of \'getInitailData\' finished.\n       * Because categories are collected during initializing data.\n       */\n\n\n      AxisModel.prototype.getCategories = function (rawData) {\n        var option = this.option; // FIXME\n        // warning if called before all of \'getInitailData\' finished.\n\n        if (option.type === \'category\') {\n          if (rawData) {\n            return option.data;\n          }\n\n          return this.__ordinalMeta.categories;\n        }\n      };\n\n      AxisModel.prototype.getOrdinalMeta = function () {\n        return this.__ordinalMeta;\n      };\n\n      AxisModel.type = axisName + \'Axis.\' + axisType;\n      AxisModel.defaultOption = defaultOption;\n      return AxisModel;\n    }(BaseAxisModelClass);\n\n    registers.registerComponentModel(AxisModel);\n  });\n  registers.registerSubTypeDefaulter(axisName + \'Axis\', getAxisType);\n}\n\nfunction getAxisType(option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? \'category\' : \'value\');\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisHelper.js + 3 modules\nvar axisHelper = __webpack_require__("697e");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/BoundingRect.js\nvar BoundingRect = __webpack_require__("9850");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/cartesian/Cartesian.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\nvar Cartesian_Cartesian =\n/** @class */\nfunction () {\n  function Cartesian(name) {\n    this.type = \'cartesian\';\n    this._dimList = [];\n    this._axes = {};\n    this.name = name || \'\';\n  }\n\n  Cartesian.prototype.getAxis = function (dim) {\n    return this._axes[dim];\n  };\n\n  Cartesian.prototype.getAxes = function () {\n    return util["F" /* map */](this._dimList, function (dim) {\n      return this._axes[dim];\n    }, this);\n  };\n\n  Cartesian.prototype.getAxesByScale = function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return util["n" /* filter */](this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  };\n\n  Cartesian.prototype.addAxis = function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  };\n\n  return Cartesian;\n}();\n\n;\n/* harmony default export */ var cartesian_Cartesian = (Cartesian_Cartesian);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/matrix.js\nvar matrix = __webpack_require__("1687");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/vector.js\nvar vector = __webpack_require__("401b3");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/cartesian/Cartesian2D.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\nvar cartesian2DDimensions = [\'x\', \'y\'];\n\nfunction canCalculateAffineTransform(scale) {\n  return scale.type === \'interval\' || scale.type === \'time\';\n}\n\nvar Cartesian2D_Cartesian2D =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6["a" /* __extends */])(Cartesian2D, _super);\n\n  function Cartesian2D() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = \'cartesian2d\';\n    _this.dimensions = cartesian2DDimensions;\n    return _this;\n  }\n  /**\n   * Calculate an affine transform matrix if two axes are time or value.\n   * It\'s mainly for accelartion on the large time series data.\n   */\n\n\n  Cartesian2D.prototype.calcAffineTransform = function () {\n    this._transform = this._invTransform = null;\n    var xAxisScale = this.getAxis(\'x\').scale;\n    var yAxisScale = this.getAxis(\'y\').scale;\n\n    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {\n      return;\n    }\n\n    var xScaleExtent = xAxisScale.getExtent();\n    var yScaleExtent = yAxisScale.getExtent();\n    var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);\n    var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);\n    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];\n    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];\n\n    if (!xScaleSpan || !yScaleSpan) {\n      return;\n    } // Accelerate data to point calculation on the special large time series data.\n\n\n    var scaleX = (end[0] - start[0]) / xScaleSpan;\n    var scaleY = (end[1] - start[1]) / yScaleSpan;\n    var translateX = start[0] - xScaleExtent[0] * scaleX;\n    var translateY = start[1] - yScaleExtent[0] * scaleY;\n    var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];\n    this._invTransform = Object(matrix["d" /* invert */])([], m);\n  };\n  /**\n   * Base axis will be used on stacking.\n   */\n\n\n  Cartesian2D.prototype.getBaseAxis = function () {\n    return this.getAxesByScale(\'ordinal\')[0] || this.getAxesByScale(\'time\')[0] || this.getAxis(\'x\');\n  };\n\n  Cartesian2D.prototype.containPoint = function (point) {\n    var axisX = this.getAxis(\'x\');\n    var axisY = this.getAxis(\'y\');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  };\n\n  Cartesian2D.prototype.containData = function (data) {\n    return this.getAxis(\'x\').containData(data[0]) && this.getAxis(\'y\').containData(data[1]);\n  };\n\n  Cartesian2D.prototype.dataToPoint = function (data, clamp, out) {\n    out = out || [];\n    var xVal = data[0];\n    var yVal = data[1]; // Fast path\n\n    if (this._transform // It\'s supported that if data is like `[Inifity, 123]`, where only Y pixel calculated.\n    && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {\n      return Object(vector["b" /* applyTransform */])(out, data, this._transform);\n    }\n\n    var xAxis = this.getAxis(\'x\');\n    var yAxis = this.getAxis(\'y\');\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp));\n    return out;\n  };\n\n  Cartesian2D.prototype.clampData = function (data, out) {\n    var xScale = this.getAxis(\'x\').scale;\n    var yScale = this.getAxis(\'y\').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  };\n\n  Cartesian2D.prototype.pointToData = function (point, clamp) {\n    var out = [];\n\n    if (this._invTransform) {\n      return Object(vector["b" /* applyTransform */])(out, point, this._invTransform);\n    }\n\n    var xAxis = this.getAxis(\'x\');\n    var yAxis = this.getAxis(\'y\');\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp);\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp);\n    return out;\n  };\n\n  Cartesian2D.prototype.getOtherAxis = function (axis) {\n    return this.getAxis(axis.dim === \'x\' ? \'y\' : \'x\');\n  };\n  /**\n   * Get rect area of cartesian.\n   * Area will have a contain function to determine if a point is in the coordinate system.\n   */\n\n\n  Cartesian2D.prototype.getArea = function () {\n    var xExtent = this.getAxis(\'x\').getGlobalExtent();\n    var yExtent = this.getAxis(\'y\').getGlobalExtent();\n    var x = Math.min(xExtent[0], xExtent[1]);\n    var y = Math.min(yExtent[0], yExtent[1]);\n    var width = Math.max(xExtent[0], xExtent[1]) - x;\n    var height = Math.max(yExtent[0], yExtent[1]) - y;\n    return new BoundingRect["a" /* default */](x, y, width, height);\n  };\n\n  return Cartesian2D;\n}(cartesian_Cartesian);\n\n;\n/* harmony default export */ var cartesian_Cartesian2D = (Cartesian2D_Cartesian2D);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__("3842");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/contain/text.js\nvar contain_text = __webpack_require__("e86a");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/axisTickLabelBuilder.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\nvar inner = Object(util_model["m" /* makeInner */])();\nfunction createAxisLabels(axis) {\n  // Only ordinal scale support tick interval\n  return axis.type === \'category\' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);\n}\n/**\n * @param {module:echats/coord/Axis} axis\n * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.\n * @return {Object} {\n *     ticks: Array.<number>\n *     tickCategoryInterval: number\n * }\n */\n\nfunction createAxisTicks(axis, tickModel) {\n  // Only ordinal scale support tick interval\n  return axis.type === \'category\' ? makeCategoryTicks(axis, tickModel) : {\n    ticks: util["F" /* map */](axis.scale.getTicks(), function (tick) {\n      return tick.value;\n    })\n  };\n}\n\nfunction makeCategoryLabels(axis) {\n  var labelModel = axis.getLabelModel();\n  var result = makeCategoryLabelsActually(axis, labelModel);\n  return !labelModel.get(\'show\') || axis.scale.isBlank() ? {\n    labels: [],\n    labelCategoryInterval: result.labelCategoryInterval\n  } : result;\n}\n\nfunction makeCategoryLabelsActually(axis, labelModel) {\n  var labelsCache = getListCache(axis, \'labels\');\n  var optionLabelInterval = Object(axisHelper["e" /* getOptionCategoryInterval */])(labelModel);\n  var result = listCacheGet(labelsCache, optionLabelInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var labels;\n  var numericLabelInterval;\n\n  if (util["v" /* isFunction */](optionLabelInterval)) {\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n  } else {\n    numericLabelInterval = optionLabelInterval === \'auto\' ? makeAutoCategoryInterval(axis) : optionLabelInterval;\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n  } // Cache to avoid calling interval function repeatly.\n\n\n  return listCacheSet(labelsCache, optionLabelInterval, {\n    labels: labels,\n    labelCategoryInterval: numericLabelInterval\n  });\n}\n\nfunction makeCategoryTicks(axis, tickModel) {\n  var ticksCache = getListCache(axis, \'ticks\');\n  var optionTickInterval = Object(axisHelper["e" /* getOptionCategoryInterval */])(tickModel);\n  var result = listCacheGet(ticksCache, optionTickInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var ticks;\n  var tickCategoryInterval; // Optimize for the case that large category data and no label displayed,\n  // we should not return all ticks.\n\n  if (!tickModel.get(\'show\') || axis.scale.isBlank()) {\n    ticks = [];\n  }\n\n  if (util["v" /* isFunction */](optionTickInterval)) {\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n  } // Always use label interval by default despite label show. Consider this\n  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows\n  // labels. `splitLine` and `axisTick` should be consistent in this case.\n  else if (optionTickInterval === \'auto\') {\n      var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());\n      tickCategoryInterval = labelsResult.labelCategoryInterval;\n      ticks = util["F" /* map */](labelsResult.labels, function (labelItem) {\n        return labelItem.tickValue;\n      });\n    } else {\n      tickCategoryInterval = optionTickInterval;\n      ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n    } // Cache to avoid calling interval function repeatly.\n\n\n  return listCacheSet(ticksCache, optionTickInterval, {\n    ticks: ticks,\n    tickCategoryInterval: tickCategoryInterval\n  });\n}\n\nfunction makeRealNumberLabels(axis) {\n  var ticks = axis.scale.getTicks();\n  var labelFormatter = Object(axisHelper["h" /* makeLabelFormatter */])(axis);\n  return {\n    labels: util["F" /* map */](ticks, function (tick, idx) {\n      return {\n        level: tick.level,\n        formattedLabel: labelFormatter(tick, idx),\n        rawLabel: axis.scale.getLabel(tick),\n        tickValue: tick.value\n      };\n    })\n  };\n}\n\nfunction getListCache(axis, prop) {\n  // Because key can be funciton, and cache size always be small, we use array cache.\n  return inner(axis)[prop] || (inner(axis)[prop] = []);\n}\n\nfunction listCacheGet(cache, key) {\n  for (var i = 0; i < cache.length; i++) {\n    if (cache[i].key === key) {\n      return cache[i].value;\n    }\n  }\n}\n\nfunction listCacheSet(cache, key, value) {\n  cache.push({\n    key: key,\n    value: value\n  });\n  return value;\n}\n\nfunction makeAutoCategoryInterval(axis) {\n  var result = inner(axis).autoInterval;\n  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();\n}\n/**\n * Calculate interval for category axis ticks and labels.\n * To get precise result, at least one of `getRotate` and `isHorizontal`\n * should be implemented in axis.\n */\n\n\nfunction calculateCategoryInterval(axis) {\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\n  var labelFormatter = Object(axisHelper["h" /* makeLabelFormatter */])(axis);\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:\n  // avoid generating a long array by `getTicks`\n  // in large category data case.\n\n  var tickCount = ordinalScale.count();\n\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n    return 0;\n  }\n\n  var step = 1; // Simple optimization. Empirical value: tick count should less than 40.\n\n  if (tickCount > 40) {\n    step = Math.max(1, Math.floor(tickCount / 40));\n  }\n\n  var tickValue = ordinalExtent[0];\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\n  var maxW = 0;\n  var maxH = 0; // Caution: Performance sensitive for large category data.\n  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    var width = 0;\n    var height = 0; // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n\n    var rect = contain_text["d" /* getBoundingRect */](labelFormatter({\n      value: tickValue\n    }), params.font, \'center\', \'top\'); // Magic number\n\n    width = rect.width * 1.3;\n    height = rect.height * 1.3; // Min size, void long loop.\n\n    maxW = Math.max(maxW, width, 7);\n    maxH = Math.max(maxH, height, 7);\n  }\n\n  var dw = maxW / unitW;\n  var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.\n\n  isNaN(dw) && (dw = Infinity);\n  isNaN(dh) && (dh = Infinity);\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n  var cache = inner(axis.model);\n  var axisExtent = axis.getExtent();\n  var lastAutoInterval = cache.lastAutoInterval;\n  var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,\n  // otherwise the calculated interval might jitter when the zoom\n  // window size is close to the interval-changing size.\n  // For example, if all of the axis labels are `a, b, c, d, e, f, g`.\n  // The jitter will cause that sometimes the displayed labels are\n  // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).\n\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical\n  // point is not the same when zooming in or zooming out.\n  && lastAutoInterval > interval // If the axis change is caused by chart resize, the cache should not\n  // be used. Otherwise some hiden labels might not be shown again.\n  && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {\n    interval = lastAutoInterval;\n  } // Only update cache if cache not used, otherwise the\n  // changing of interval is too insensitive.\n  else {\n      cache.lastTickCount = tickCount;\n      cache.lastAutoInterval = interval;\n      cache.axisExtent0 = axisExtent[0];\n      cache.axisExtent1 = axisExtent[1];\n    }\n\n  return interval;\n}\n\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\n  var labelModel = axis.getLabelModel();\n  return {\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n    labelRotate: labelModel.get(\'rotate\') || 0,\n    font: labelModel.getFont()\n  };\n}\n\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n  var labelFormatter = Object(axisHelper["h" /* makeLabelFormatter */])(axis);\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var labelModel = axis.getLabelModel();\n  var result = []; // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...\n\n  var step = Math.max((categoryInterval || 0) + 1, 1);\n  var startTick = ordinalExtent[0];\n  var tickCount = ordinalScale.count(); // Calculate start tick based on zero if possible to keep label consistent\n  // while zooming and moving while interval > 0. Otherwise the selection\n  // of displayable ticks and symbols probably keep changing.\n  // 3 is empirical value.\n\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n    startTick = Math.round(Math.ceil(startTick / step) * step);\n  } // (1) Only add min max label here but leave overlap checking\n  // to render stage, which also ensure the returned list\n  // suitable for splitLine and splitArea rendering.\n  // (2) Scales except category always contain min max label so\n  // do not need to perform this process.\n\n\n  var showAllLabel = Object(axisHelper["j" /* shouldShowAllLabels */])(axis);\n  var includeMinLabel = labelModel.get(\'showMinLabel\') || showAllLabel;\n  var includeMaxLabel = labelModel.get(\'showMaxLabel\') || showAllLabel;\n\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\n    addItem(ordinalExtent[0]);\n  } // Optimize: avoid generating large array by `ordinalScale.getTicks()`.\n\n\n  var tickValue = startTick;\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    addItem(tickValue);\n  }\n\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n    addItem(ordinalExtent[1]);\n  }\n\n  function addItem(tickValue) {\n    var tickObj = {\n      value: tickValue\n    };\n    result.push(onlyTick ? tickValue : {\n      formattedLabel: labelFormatter(tickObj),\n      rawLabel: ordinalScale.getLabel(tickObj),\n      tickValue: tickValue\n    });\n  }\n\n  return result;\n}\n\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n  var ordinalScale = axis.scale;\n  var labelFormatter = Object(axisHelper["h" /* makeLabelFormatter */])(axis);\n  var result = [];\n  util["k" /* each */](ordinalScale.getTicks(), function (tick) {\n    var rawLabel = ordinalScale.getLabel(tick);\n    var tickValue = tick.value;\n\n    if (categoryInterval(tick.value, rawLabel)) {\n      result.push(onlyTick ? tickValue : {\n        formattedLabel: labelFormatter(tick),\n        rawLabel: rawLabel,\n        tickValue: tickValue\n      });\n    }\n  });\n  return result;\n}\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/Axis.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nvar NORMALIZED_EXTENT = [0, 1];\n/**\n * Base class of Axis.\n */\n\nvar Axis_Axis =\n/** @class */\nfunction () {\n  function Axis(dim, scale, extent) {\n    this.onBand = false;\n    this.inverse = false;\n    this.dim = dim;\n    this.scale = scale;\n    this._extent = extent || [0, 0];\n  }\n  /**\n   * If axis extent contain given coord\n   */\n\n\n  Axis.prototype.contain = function (coord) {\n    var extent = this._extent;\n    var min = Math.min(extent[0], extent[1]);\n    var max = Math.max(extent[0], extent[1]);\n    return coord >= min && coord <= max;\n  };\n  /**\n   * If axis extent contain given data\n   */\n\n\n  Axis.prototype.containData = function (data) {\n    return this.scale.contain(data);\n  };\n  /**\n   * Get coord extent.\n   */\n\n\n  Axis.prototype.getExtent = function () {\n    return this._extent.slice();\n  };\n  /**\n   * Get precision used for formatting\n   */\n\n\n  Axis.prototype.getPixelPrecision = function (dataExtent) {\n    return Object(number["e" /* getPixelPrecision */])(dataExtent || this.scale.getExtent(), this._extent);\n  };\n  /**\n   * Set coord extent\n   */\n\n\n  Axis.prototype.setExtent = function (start, end) {\n    var extent = this._extent;\n    extent[0] = start;\n    extent[1] = end;\n  };\n  /**\n   * Convert data to coord. Data is the rank if it has an ordinal scale\n   */\n\n\n  Axis.prototype.dataToCoord = function (data, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n    data = scale.normalize(data);\n\n    if (this.onBand && scale.type === \'ordinal\') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    return Object(number["j" /* linearMap */])(data, NORMALIZED_EXTENT, extent, clamp);\n  };\n  /**\n   * Convert coord to data. Data is the rank if it has an ordinal scale\n   */\n\n\n  Axis.prototype.coordToData = function (coord, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n\n    if (this.onBand && scale.type === \'ordinal\') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    var t = Object(number["j" /* linearMap */])(coord, extent, NORMALIZED_EXTENT, clamp);\n    return this.scale.scale(t);\n  };\n  /**\n   * Convert pixel point to data in axis\n   */\n\n\n  Axis.prototype.pointToData = function (point, clamp) {\n    // Should be implemented in derived class if necessary.\n    return;\n  };\n  /**\n   * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,\n   * `axis.getTicksCoords` considers `onBand`, which is used by\n   * `boundaryGap:true` of category axis and splitLine and splitArea.\n   * @param opt.tickModel default: axis.model.getModel(\'axisTick\')\n   * @param opt.clamp If `true`, the first and the last\n   *        tick must be at the axis end points. Otherwise, clip ticks\n   *        that outside the axis extent.\n   */\n\n\n  Axis.prototype.getTicksCoords = function (opt) {\n    opt = opt || {};\n    var tickModel = opt.tickModel || this.getTickModel();\n    var result = createAxisTicks(this, tickModel);\n    var ticks = result.ticks;\n    var ticksCoords = Object(util["F" /* map */])(ticks, function (tickVal) {\n      return {\n        coord: this.dataToCoord(this.scale.type === \'ordinal\' ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),\n        tickValue: tickVal\n      };\n    }, this);\n    var alignWithLabel = tickModel.get(\'alignWithLabel\');\n    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);\n    return ticksCoords;\n  };\n\n  Axis.prototype.getMinorTicksCoords = function () {\n    if (this.scale.type === \'ordinal\') {\n      // Category axis doesn\'t support minor ticks\n      return [];\n    }\n\n    var minorTickModel = this.model.getModel(\'minorTick\');\n    var splitNumber = minorTickModel.get(\'splitNumber\'); // Protection.\n\n    if (!(splitNumber > 0 && splitNumber < 100)) {\n      splitNumber = 5;\n    }\n\n    var minorTicks = this.scale.getMinorTicks(splitNumber);\n    var minorTicksCoords = Object(util["F" /* map */])(minorTicks, function (minorTicksGroup) {\n      return Object(util["F" /* map */])(minorTicksGroup, function (minorTick) {\n        return {\n          coord: this.dataToCoord(minorTick),\n          tickValue: minorTick\n        };\n      }, this);\n    }, this);\n    return minorTicksCoords;\n  };\n\n  Axis.prototype.getViewLabels = function () {\n    return createAxisLabels(this).labels;\n  };\n\n  Axis.prototype.getLabelModel = function () {\n    return this.model.getModel(\'axisLabel\');\n  };\n  /**\n   * Notice here we only get the default tick model. For splitLine\n   * or splitArea, we should pass the splitLineModel or splitAreaModel\n   * manually when calling `getTicksCoords`.\n   * In GL, this method may be overrided to:\n   * `axisModel.getModel(\'axisTick\', grid3DModel.getModel(\'axisTick\'));`\n   */\n\n\n  Axis.prototype.getTickModel = function () {\n    return this.model.getModel(\'axisTick\');\n  };\n  /**\n   * Get width of band\n   */\n\n\n  Axis.prototype.getBandWidth = function () {\n    var axisExtent = this._extent;\n    var dataExtent = this.scale.getExtent();\n    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.\n\n    len === 0 && (len = 1);\n    var size = Math.abs(axisExtent[1] - axisExtent[0]);\n    return Math.abs(size) / len;\n  };\n  /**\n   * Only be called in category axis.\n   * Can be overrided, consider other axes like in 3D.\n   * @return Auto interval for cateogry axis tick and label\n   */\n\n\n  Axis.prototype.calculateCategoryInterval = function () {\n    return calculateCategoryInterval(this);\n  };\n\n  return Axis;\n}();\n\nfunction fixExtentWithBands(extent, nTick) {\n  var size = extent[1] - extent[0];\n  var len = nTick;\n  var margin = size / len / 2;\n  extent[0] += margin;\n  extent[1] -= margin;\n} // If axis has labels [1, 2, 3, 4]. Bands on the axis are\n// |---1---|---2---|---3---|---4---|.\n// So the displayed ticks and splitLine/splitArea should between\n// each data item, otherwise cause misleading (e.g., split tow bars\n// of a single data item when there are two bar series).\n// Also consider if tickCategoryInterval > 0 and onBand, ticks and\n// splitLine/spliteArea should layout appropriately corresponding\n// to displayed labels. (So we should not use `getBandWidth` in this\n// case).\n\n\nfunction fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp) {\n  var ticksLen = ticksCoords.length;\n\n  if (!axis.onBand || alignWithLabel || !ticksLen) {\n    return;\n  }\n\n  var axisExtent = axis.getExtent();\n  var last;\n  var diffSize;\n\n  if (ticksLen === 1) {\n    ticksCoords[0].coord = axisExtent[0];\n    last = ticksCoords[1] = {\n      coord: axisExtent[0]\n    };\n  } else {\n    var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;\n    var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;\n    Object(util["k" /* each */])(ticksCoords, function (ticksItem) {\n      ticksItem.coord -= shift_1 / 2;\n    });\n    var dataExtent = axis.scale.getExtent();\n    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;\n    last = {\n      coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize\n    };\n    ticksCoords.push(last);\n  }\n\n  var inverse = axisExtent[0] > axisExtent[1]; // Handling clamp.\n\n  if (littleThan(ticksCoords[0].coord, axisExtent[0])) {\n    clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();\n  }\n\n  if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {\n    ticksCoords.unshift({\n      coord: axisExtent[0]\n    });\n  }\n\n  if (littleThan(axisExtent[1], last.coord)) {\n    clamp ? last.coord = axisExtent[1] : ticksCoords.pop();\n  }\n\n  if (clamp && littleThan(last.coord, axisExtent[1])) {\n    ticksCoords.push({\n      coord: axisExtent[1]\n    });\n  }\n\n  function littleThan(a, b) {\n    // Avoid rounding error cause calculated tick coord different with extent.\n    // It may cause an extra unecessary tick added.\n    a = Object(number["r" /* round */])(a);\n    b = Object(number["r" /* round */])(b);\n    return inverse ? a > b : a < b;\n  }\n}\n\n/* harmony default export */ var coord_Axis = (Axis_Axis);\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/cartesian/Axis2D.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nvar Axis2D_Axis2D =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6["a" /* __extends */])(Axis2D, _super);\n\n  function Axis2D(dim, scale, coordExtent, axisType, position) {\n    var _this = _super.call(this, dim, scale, coordExtent) || this;\n    /**\n     * Index of axis, can be used as key\n     * Injected outside.\n     */\n\n\n    _this.index = 0;\n    _this.type = axisType || \'value\';\n    _this.position = position || \'bottom\';\n    return _this;\n  }\n\n  Axis2D.prototype.isHorizontal = function () {\n    var position = this.position;\n    return position === \'top\' || position === \'bottom\';\n  };\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n\n\n  Axis2D.prototype.getGlobalExtent = function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  };\n\n  Axis2D.prototype.pointToData = function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === \'x\' ? 0 : 1]), clamp);\n  };\n  /**\n   * Set ordinalSortInfo\n   * @param info new OrdinalSortInfo\n   */\n\n\n  Axis2D.prototype.setCategorySortInfo = function (info) {\n    if (this.type !== \'category\') {\n      return false;\n    }\n\n    this.model.option.categorySortInfo = info;\n    this.scale.setSortInfo(info);\n  };\n\n  return Axis2D;\n}(coord_Axis);\n\n/* harmony default export */ var cartesian_Axis2D = (Axis2D_Axis2D);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js\nvar cartesianAxisHelper = __webpack_require__("0156");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/scale/helper.js\nvar helper = __webpack_require__("944e");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/scale/Interval.js\nvar Interval = __webpack_require__("89e3");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/axisAlignTicks.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\nvar mathLog = Math.log;\nfunction alignScaleTicks(scale, axisModel, alignToScale) {\n  var intervalScaleProto = Interval["a" /* default */].prototype; // NOTE: There is a precondition for log scale  here:\n  // In log scale we store _interval and _extent of exponent value.\n  // So if we use the method of InternalScale to set/get these data.\n  // It process the exponent value, which is linear and what we want here.\n\n  var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);\n  var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, true);\n  var alignToSplitNumber = alignToTicks.length - 1;\n  var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);\n  var scaleExtent = Object(axisHelper["f" /* getScaleExtent */])(scale, axisModel);\n  var rawExtent = scaleExtent.extent;\n  var isMinFixed = scaleExtent.fixMin;\n  var isMaxFixed = scaleExtent.fixMax;\n\n  if (scale.type === \'log\') {\n    var logBase = mathLog(scale.base);\n    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];\n  }\n\n  scale.setExtent(rawExtent[0], rawExtent[1]);\n  scale.calcNiceExtent({\n    splitNumber: alignToSplitNumber,\n    fixMin: isMinFixed,\n    fixMax: isMaxFixed\n  });\n  var extent = intervalScaleProto.getExtent.call(scale); // Need to update the rawExtent.\n  // Because value in rawExtent may be not parsed. e.g. \'dataMin\', \'dataMax\'\n\n  if (isMinFixed) {\n    rawExtent[0] = extent[0];\n  }\n\n  if (isMaxFixed) {\n    rawExtent[1] = extent[1];\n  }\n\n  var interval = intervalScaleProto.getInterval.call(scale);\n  var min = rawExtent[0];\n  var max = rawExtent[1];\n\n  if (isMinFixed && isMaxFixed) {\n    // User set min, max, divide to get new interval\n    interval = (max - min) / alignToSplitNumber;\n  } else if (isMinFixed) {\n    max = rawExtent[0] + interval * alignToSplitNumber; // User set min, expand extent on the other side\n\n    while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1])) {\n      interval = Object(helper["c" /* increaseInterval */])(interval);\n      max = rawExtent[0] + interval * alignToSplitNumber;\n    }\n  } else if (isMaxFixed) {\n    // User set max, expand extent on the other side\n    min = rawExtent[1] - interval * alignToSplitNumber;\n\n    while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])) {\n      interval = Object(helper["c" /* increaseInterval */])(interval);\n      min = rawExtent[1] - interval * alignToSplitNumber;\n    }\n  } else {\n    var nicedSplitNumber = scale.getTicks().length - 1;\n\n    if (nicedSplitNumber > alignToSplitNumber) {\n      interval = Object(helper["c" /* increaseInterval */])(interval);\n    }\n\n    var range = interval * alignToSplitNumber;\n    max = Math.ceil(rawExtent[1] / interval) * interval;\n    min = Object(number["r" /* round */])(max - range); // Not change the result that crossing zero.\n\n    if (min < 0 && rawExtent[0] >= 0) {\n      min = 0;\n      max = Object(number["r" /* round */])(range);\n    } else if (max > 0 && rawExtent[1] <= 0) {\n      max = 0;\n      min = -Object(number["r" /* round */])(range);\n    }\n  } // Adjust min, max based on the extent of alignTo. When min or max is set in alignTo scale\n\n\n  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;\n  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval; // NOTE: Must in setExtent -> setInterval -> setNiceExtent order.\n\n  intervalScaleProto.setExtent.call(scale, min + interval * t0, max + interval * t1);\n  intervalScaleProto.setInterval.call(scale, interval);\n\n  if (t0 || t1) {\n    intervalScaleProto.setNiceExtent.call(scale, min + interval, max - interval);\n  }\n\n  if (false) { var ticks; }\n}\n// CONCATENATED MODULE: ./node_modules/echarts/lib/coord/cartesian/Grid.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n\n\n\n\n\n\n\n\n\n\nvar Grid_Grid =\n/** @class */\nfunction () {\n  function Grid(gridModel, ecModel, api) {\n    // FIXME:TS where used (different from registered type \'cartesian2d\')?\n    this.type = \'grid\';\n    this._coordsMap = {};\n    this._coordsList = [];\n    this._axesMap = {};\n    this._axesList = [];\n    this.axisPointerEnabled = true;\n    this.dimensions = cartesian2DDimensions;\n\n    this._initCartesian(gridModel, ecModel, api);\n\n    this.model = gridModel;\n  }\n\n  Grid.prototype.getRect = function () {\n    return this._rect;\n  };\n\n  Grid.prototype.update = function (ecModel, api) {\n    var axesMap = this._axesMap;\n\n    this._updateScale(ecModel, this.model);\n\n    function updateAxisTicks(axes) {\n      var alignTo; // Axis is added in order of axisIndex.\n\n      var axesIndices = Object(util["D" /* keys */])(axes);\n      var len = axesIndices.length;\n\n      if (!len) {\n        return;\n      }\n\n      var axisNeedsAlign = []; // Process once and calculate the ticks for those don\'t use alignTicks.\n\n      for (var i = len - 1; i >= 0; i--) {\n        var idx = +axesIndices[i]; // Convert to number.\n\n        var axis = axes[idx];\n        var model = axis.model;\n        var scale = axis.scale;\n\n        if ( // Only value and log axis without interval support alignTicks.\n        Object(helper["e" /* isIntervalOrLogScale */])(scale) && model.get(\'alignTicks\') && model.get(\'interval\') == null) {\n          axisNeedsAlign.push(axis);\n        } else {\n          Object(axisHelper["i" /* niceScaleExtent */])(scale, model);\n\n          if (Object(helper["e" /* isIntervalOrLogScale */])(scale)) {\n            // Can only align to interval or log axis.\n            alignTo = axis;\n          }\n        }\n      }\n\n      ; // All axes has set alignTicks. Pick the first one.\n      // PENDING. Should we find the axis that both set interval, min, max and align to this one?\n\n      if (axisNeedsAlign.length) {\n        if (!alignTo) {\n          alignTo = axisNeedsAlign.pop();\n          Object(axisHelper["i" /* niceScaleExtent */])(alignTo.scale, alignTo.model);\n        }\n\n        Object(util["k" /* each */])(axisNeedsAlign, function (axis) {\n          alignScaleTicks(axis.scale, axis.model, alignTo.scale);\n        });\n      }\n    }\n\n    updateAxisTicks(axesMap.x);\n    updateAxisTicks(axesMap.y); // Key: axisDim_axisIndex, value: boolean, whether onZero target.\n\n    var onZeroRecords = {};\n    Object(util["k" /* each */])(axesMap.x, function (xAxis) {\n      fixAxisOnZero(axesMap, \'y\', xAxis, onZeroRecords);\n    });\n    Object(util["k" /* each */])(axesMap.y, function (yAxis) {\n      fixAxisOnZero(axesMap, \'x\', yAxis, onZeroRecords);\n    }); // Resize again if containLabel is enabled\n    // FIXME It may cause getting wrong grid size in data processing stage\n\n    this.resize(this.model, api);\n  };\n  /**\n   * Resize the grid\n   */\n\n\n  Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {\n    var boxLayoutParams = gridModel.getBoxLayoutParams();\n    var isContainLabel = !ignoreContainLabel && gridModel.get(\'containLabel\');\n    var gridRect = Object(util_layout["d" /* getLayoutRect */])(boxLayoutParams, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    this._rect = gridRect;\n    var axesList = this._axesList;\n    adjustAxes(); // Minus label size\n\n    if (isContainLabel) {\n      Object(util["k" /* each */])(axesList, function (axis) {\n        if (!axis.model.get([\'axisLabel\', \'inside\'])) {\n          var labelUnionRect = Object(axisHelper["b" /* estimateLabelUnionRect */])(axis);\n\n          if (labelUnionRect) {\n            var dim = axis.isHorizontal() ? \'height\' : \'width\';\n            var margin = axis.model.get([\'axisLabel\', \'margin\']);\n            gridRect[dim] -= labelUnionRect[dim] + margin;\n\n            if (axis.position === \'top\') {\n              gridRect.y += labelUnionRect.height + margin;\n            } else if (axis.position === \'left\') {\n              gridRect.x += labelUnionRect.width + margin;\n            }\n          }\n        }\n      });\n      adjustAxes();\n    }\n\n    Object(util["k" /* each */])(this._coordsList, function (coord) {\n      // Calculate affine matrix to accelerate the data to point transform.\n      // If all the axes scales are time or value.\n      coord.calcAffineTransform();\n    });\n\n    function adjustAxes() {\n      Object(util["k" /* each */])(axesList, function (axis) {\n        var isHorizontal = axis.isHorizontal();\n        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n        var idx = axis.inverse ? 1 : 0;\n        axis.setExtent(extent[idx], extent[1 - idx]);\n        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n      });\n    }\n  };\n\n  Grid.prototype.getAxis = function (dim, axisIndex) {\n    var axesMapOnDim = this._axesMap[dim];\n\n    if (axesMapOnDim != null) {\n      return axesMapOnDim[axisIndex || 0];\n    }\n  };\n\n  Grid.prototype.getAxes = function () {\n    return this._axesList.slice();\n  };\n\n  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {\n    if (xAxisIndex != null && yAxisIndex != null) {\n      var key = \'x\' + xAxisIndex + \'y\' + yAxisIndex;\n      return this._coordsMap[key];\n    }\n\n    if (Object(util["z" /* isObject */])(xAxisIndex)) {\n      yAxisIndex = xAxisIndex.yAxisIndex;\n      xAxisIndex = xAxisIndex.xAxisIndex;\n    }\n\n    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n      if (coordList[i].getAxis(\'x\').index === xAxisIndex || coordList[i].getAxis(\'y\').index === yAxisIndex) {\n        return coordList[i];\n      }\n    }\n  };\n\n  Grid.prototype.getCartesians = function () {\n    return this._coordsList.slice();\n  };\n  /**\n   * @implements\n   */\n\n\n  Grid.prototype.convertToPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n\n    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n  };\n  /**\n   * @implements\n   */\n\n\n  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n\n    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n  };\n\n  Grid.prototype._findConvertTarget = function (finder) {\n    var seriesModel = finder.seriesModel;\n    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents(\'xAxis\', util_model["b" /* SINGLE_REFERRING */]).models[0];\n    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents(\'yAxis\', util_model["b" /* SINGLE_REFERRING */]).models[0];\n    var gridModel = finder.gridModel;\n    var coordsList = this._coordsList;\n    var cartesian;\n    var axis;\n\n    if (seriesModel) {\n      cartesian = seriesModel.coordinateSystem;\n      Object(util["q" /* indexOf */])(coordsList, cartesian) < 0 && (cartesian = null);\n    } else if (xAxisModel && yAxisModel) {\n      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    } else if (xAxisModel) {\n      axis = this.getAxis(\'x\', xAxisModel.componentIndex);\n    } else if (yAxisModel) {\n      axis = this.getAxis(\'y\', yAxisModel.componentIndex);\n    } // Lowest priority.\n    else if (gridModel) {\n        var grid = gridModel.coordinateSystem;\n\n        if (grid === this) {\n          cartesian = this._coordsList[0];\n        }\n      }\n\n    return {\n      cartesian: cartesian,\n      axis: axis\n    };\n  };\n  /**\n   * @implements\n   */\n\n\n  Grid.prototype.containPoint = function (point) {\n    var coord = this._coordsList[0];\n\n    if (coord) {\n      return coord.containPoint(point);\n    }\n  };\n  /**\n   * Initialize cartesian coordinate systems\n   */\n\n\n  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {\n    var _this = this;\n\n    var grid = this;\n    var axisPositionUsed = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n    var axesMap = {\n      x: {},\n      y: {}\n    };\n    var axesCount = {\n      x: 0,\n      y: 0\n    }; /// Create axis\n\n    ecModel.eachComponent(\'xAxis\', createAxisCreator(\'x\'), this);\n    ecModel.eachComponent(\'yAxis\', createAxisCreator(\'y\'), this);\n\n    if (!axesCount.x || !axesCount.y) {\n      // Roll back when there no either x or y axis\n      this._axesMap = {};\n      this._axesList = [];\n      return;\n    }\n\n    this._axesMap = axesMap; /// Create cartesian2d\n\n    Object(util["k" /* each */])(axesMap.x, function (xAxis, xAxisIndex) {\n      Object(util["k" /* each */])(axesMap.y, function (yAxis, yAxisIndex) {\n        var key = \'x\' + xAxisIndex + \'y\' + yAxisIndex;\n        var cartesian = new cartesian_Cartesian2D(key);\n        cartesian.master = _this;\n        cartesian.model = gridModel;\n        _this._coordsMap[key] = cartesian;\n\n        _this._coordsList.push(cartesian);\n\n        cartesian.addAxis(xAxis);\n        cartesian.addAxis(yAxis);\n      });\n    });\n\n    function createAxisCreator(dimName) {\n      return function (axisModel, idx) {\n        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {\n          return;\n        }\n\n        var axisPosition = axisModel.get(\'position\');\n\n        if (dimName === \'x\') {\n          // Fix position\n          if (axisPosition !== \'top\' && axisPosition !== \'bottom\') {\n            // Default bottom of X\n            axisPosition = axisPositionUsed.bottom ? \'top\' : \'bottom\';\n          }\n        } else {\n          // Fix position\n          if (axisPosition !== \'left\' && axisPosition !== \'right\') {\n            // Default left of Y\n            axisPosition = axisPositionUsed.left ? \'right\' : \'left\';\n          }\n        }\n\n        axisPositionUsed[axisPosition] = true;\n        var axis = new cartesian_Axis2D(dimName, Object(axisHelper["a" /* createScaleByModel */])(axisModel), [0, 0], axisModel.get(\'type\'), axisPosition);\n        var isCategory = axis.type === \'category\';\n        axis.onBand = isCategory && axisModel.get(\'boundaryGap\');\n        axis.inverse = axisModel.get(\'inverse\'); // Inject axis into axisModel\n\n        axisModel.axis = axis; // Inject axisModel into axis\n\n        axis.model = axisModel; // Inject grid info axis\n\n        axis.grid = grid; // Index of axis, can be used as key\n\n        axis.index = idx;\n\n        grid._axesList.push(axis);\n\n        axesMap[dimName][idx] = axis;\n        axesCount[dimName]++;\n      };\n    }\n  };\n  /**\n   * Update cartesian properties from series.\n   */\n\n\n  Grid.prototype._updateScale = function (ecModel, gridModel) {\n    // Reset scale\n    Object(util["k" /* each */])(this._axesList, function (axis) {\n      axis.scale.setExtent(Infinity, -Infinity);\n\n      if (axis.type === \'category\') {\n        var categorySortInfo = axis.model.get(\'categorySortInfo\');\n        axis.scale.setSortInfo(categorySortInfo);\n      }\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      if (Object(cartesianAxisHelper["b" /* isCartesian2DSeries */])(seriesModel)) {\n        var axesModelMap = Object(cartesianAxisHelper["a" /* findAxisModels */])(seriesModel);\n        var xAxisModel = axesModelMap.xAxisModel;\n        var yAxisModel = axesModelMap.yAxisModel;\n\n        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {\n          return;\n        }\n\n        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        var data = seriesModel.getData();\n        var xAxis = cartesian.getAxis(\'x\');\n        var yAxis = cartesian.getAxis(\'y\');\n        unionExtent(data, xAxis);\n        unionExtent(data, yAxis);\n      }\n    }, this);\n\n    function unionExtent(data, axis) {\n      Object(util["k" /* each */])(Object(axisHelper["d" /* getDataDimensionsOnAxis */])(data, axis.dim), function (dim) {\n        axis.scale.unionExtentFromData(data, dim);\n      });\n    }\n  };\n  /**\n   * @param dim \'x\' or \'y\' or \'auto\' or null/undefined\n   */\n\n\n  Grid.prototype.getTooltipAxes = function (dim) {\n    var baseAxes = [];\n    var otherAxes = [];\n    Object(util["k" /* each */])(this.getCartesians(), function (cartesian) {\n      var baseAxis = dim != null && dim !== \'auto\' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n      var otherAxis = cartesian.getOtherAxis(baseAxis);\n      Object(util["q" /* indexOf */])(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n      Object(util["q" /* indexOf */])(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n    });\n    return {\n      baseAxes: baseAxes,\n      otherAxes: otherAxes\n    };\n  };\n\n  Grid.create = function (ecModel, api) {\n    var grids = [];\n    ecModel.eachComponent(\'grid\', function (gridModel, idx) {\n      var grid = new Grid(gridModel, ecModel, api);\n      grid.name = \'grid_\' + idx; // dataSampling requires axis extent, so resize\n      // should be performed in create stage.\n\n      grid.resize(gridModel, api, true);\n      gridModel.coordinateSystem = grid;\n      grids.push(grid);\n    }); // Inject the coordinateSystems into seriesModel\n\n    ecModel.eachSeries(function (seriesModel) {\n      if (!Object(cartesianAxisHelper["b" /* isCartesian2DSeries */])(seriesModel)) {\n        return;\n      }\n\n      var axesModelMap = Object(cartesianAxisHelper["a" /* findAxisModels */])(seriesModel);\n      var xAxisModel = axesModelMap.xAxisModel;\n      var yAxisModel = axesModelMap.yAxisModel;\n      var gridModel = xAxisModel.getCoordSysModel();\n\n      if (false) {}\n\n      var grid = gridModel.coordinateSystem;\n      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    });\n    return grids;\n  }; // For deciding which dimensions to use when creating list data\n\n\n  Grid.dimensions = cartesian2DDimensions;\n  return Grid;\n}();\n/**\n * Check if the axis is used in the specified grid.\n */\n\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis, // Key: see `getOnZeroRecordKey`\nonZeroRecords) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxisOnZeroOf;\n  var axisModel = axis.model;\n  var onZero = axisModel.get([\'axisLine\', \'onZero\']);\n  var onZeroAxisIndex = axisModel.get([\'axisLine\', \'onZeroAxisIndex\']);\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n    }\n  } else {\n    // Find the first available other axis.\n    for (var idx in otherAxes) {\n      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,\n      // if both onZero, the two Y axes overlap.\n      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n        otherAxisOnZeroOf = otherAxes[idx];\n        break;\n      }\n    }\n  }\n\n  if (otherAxisOnZeroOf) {\n    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n  }\n\n  function getOnZeroRecordKey(axis) {\n    return axis.dim + \'_\' + axis.index;\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== \'category\' && axis.type !== \'time\' && Object(axisHelper["g" /* ifAxisCrossZero */])(axis);\n}\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === \'x\' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === \'x\' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\n/* harmony default export */ var cartesian_Grid = (Grid_Grid);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__("2dc5");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js + 8 modules\nvar graphic = __webpack_require__("2306");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Line.js\nvar Line = __webpack_require__("cb11");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axis/AxisBuilder.js\nvar AxisBuilder = __webpack_require__("fab2");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axis/AxisView.js\nvar AxisView = __webpack_require__("6679");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/axis/axisSplitHelper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nvar axisSplitHelper_inner = Object(util_model["m" /* makeInner */])();\nfunction rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {\n  var axis = axisModel.axis;\n\n  if (axis.scale.isBlank()) {\n    return;\n  } // TODO: TYPE\n\n\n  var splitAreaModel = axisModel.getModel(\'splitArea\');\n  var areaStyleModel = splitAreaModel.getModel(\'areaStyle\');\n  var areaColors = areaStyleModel.get(\'color\');\n  var gridRect = gridModel.coordinateSystem.getRect();\n  var ticksCoords = axis.getTicksCoords({\n    tickModel: splitAreaModel,\n    clamp: true\n  });\n\n  if (!ticksCoords.length) {\n    return;\n  } // For Making appropriate splitArea animation, the color and anid\n  // should be corresponding to previous one if possible.\n\n\n  var areaColorsLen = areaColors.length;\n  var lastSplitAreaColors = axisSplitHelper_inner(axisView).splitAreaColors;\n  var newSplitAreaColors = util["f" /* createHashMap */]();\n  var colorIndex = 0;\n\n  if (lastSplitAreaColors) {\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n\n      if (cIndex != null) {\n        colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n        break;\n      }\n    }\n  }\n\n  var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n  var areaStyle = areaStyleModel.getAreaStyle();\n  areaColors = util["s" /* isArray */](areaColors) ? areaColors : [areaColors];\n\n  for (var i = 1; i < ticksCoords.length; i++) {\n    var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n    var x = void 0;\n    var y = void 0;\n    var width = void 0;\n    var height = void 0;\n\n    if (axis.isHorizontal()) {\n      x = prev;\n      y = gridRect.y;\n      width = tickCoord - x;\n      height = gridRect.height;\n      prev = x + width;\n    } else {\n      x = gridRect.x;\n      y = prev;\n      width = gridRect.width;\n      height = tickCoord - y;\n      prev = y + height;\n    }\n\n    var tickValue = ticksCoords[i - 1].tickValue;\n    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n    axisGroup.add(new Rect["a" /* default */]({\n      anid: tickValue != null ? \'area_\' + tickValue : null,\n      shape: {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      },\n      style: util["i" /* defaults */]({\n        fill: areaColors[colorIndex]\n      }, areaStyle),\n      autoBatch: true,\n      silent: true\n    }));\n    colorIndex = (colorIndex + 1) % areaColorsLen;\n  }\n\n  axisSplitHelper_inner(axisView).splitAreaColors = newSplitAreaColors;\n}\nfunction rectCoordAxisHandleRemove(axisView) {\n  axisSplitHelper_inner(axisView).splitAreaColors = null;\n}\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/axis/CartesianAxisView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\n\n\nvar axisBuilderAttrs = [\'axisLine\', \'axisTickLabel\', \'axisName\'];\nvar selfBuilderAttrs = [\'splitArea\', \'splitLine\', \'minorSplitLine\'];\n\nvar CartesianAxisView_CartesianAxisView =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6["a" /* __extends */])(CartesianAxisView, _super);\n\n  function CartesianAxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = CartesianAxisView.type;\n    _this.axisPointerClass = \'CartesianAxisPointer\';\n    return _this;\n  }\n  /**\n   * @override\n   */\n\n\n  CartesianAxisView.prototype.render = function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new Group["a" /* default */]();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get(\'show\')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper["c" /* layout */](gridModel, axisModel);\n    var axisBuilder = new AxisBuilder["a" /* default */](axisModel, util["m" /* extend */]({\n      handleAutoShown: function (elementType) {\n        var cartesians = gridModel.coordinateSystem.getCartesians();\n\n        for (var i = 0; i < cartesians.length; i++) {\n          if (Object(helper["e" /* isIntervalOrLogScale */])(cartesians[i].getOtherAxis(axisModel.axis).scale)) {\n            // Still show axis tick or axisLine if other axis is value / log\n            return true;\n          }\n        } // Not show axisTick or axisLine if other axis is category / time\n\n\n        return false;\n      }\n    }, layout));\n    util["k" /* each */](axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    util["k" /* each */](selfBuilderAttrs, function (name) {\n      if (axisModel.get([name, \'show\'])) {\n        axisElementBuilders[name](this, this._axisGroup, axisModel, gridModel);\n      }\n    }, this); // THIS is a special case for bar racing chart.\n    // Update the axis label from the natural initial layout to\n    // sorted layout should has no animation.\n\n    var isInitialSortFromBarRacing = payload && payload.type === \'changeAxisOrder\' && payload.isInitSort;\n\n    if (!isInitialSortFromBarRacing) {\n      graphic["groupTransition"](oldAxisGroup, this._axisGroup, axisModel);\n    }\n\n    _super.prototype.render.call(this, axisModel, ecModel, api, payload);\n  };\n\n  CartesianAxisView.prototype.remove = function () {\n    rectCoordAxisHandleRemove(this);\n  };\n\n  CartesianAxisView.type = \'cartesianAxis\';\n  return CartesianAxisView;\n}(AxisView["a" /* default */]);\n\nvar axisElementBuilders = {\n  splitLine: function (axisView, axisGroup, axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel(\'splitLine\');\n    var lineStyleModel = splitLineModel.getModel(\'lineStyle\');\n    var lineColors = lineStyleModel.get(\'color\');\n    lineColors = util["s" /* isArray */](lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = [];\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n      var tickValue = ticksCoords[i].tickValue;\n      axisGroup.add(new Line["a" /* default */]({\n        anid: tickValue != null ? \'line_\' + ticksCoords[i].tickValue : null,\n        subPixelOptimize: true,\n        autoBatch: true,\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: util["i" /* defaults */]({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      }));\n    }\n  },\n  minorSplitLine: function (axisView, axisGroup, axisModel, gridModel) {\n    var axis = axisModel.axis;\n    var minorSplitLineModel = axisModel.getModel(\'minorSplitLine\');\n    var lineStyleModel = minorSplitLineModel.getModel(\'lineStyle\');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var minorTicksCoords = axis.getMinorTicksCoords();\n\n    if (!minorTicksCoords.length) {\n      return;\n    }\n\n    var p1 = [];\n    var p2 = [];\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < minorTicksCoords.length; i++) {\n      for (var k = 0; k < minorTicksCoords[i].length; k++) {\n        var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);\n\n        if (isHorizontal) {\n          p1[0] = tickCoord;\n          p1[1] = gridRect.y;\n          p2[0] = tickCoord;\n          p2[1] = gridRect.y + gridRect.height;\n        } else {\n          p1[0] = gridRect.x;\n          p1[1] = tickCoord;\n          p2[0] = gridRect.x + gridRect.width;\n          p2[1] = tickCoord;\n        }\n\n        axisGroup.add(new Line["a" /* default */]({\n          anid: \'minor_line_\' + minorTicksCoords[i][k].tickValue,\n          subPixelOptimize: true,\n          autoBatch: true,\n          shape: {\n            x1: p1[0],\n            y1: p1[1],\n            x2: p2[0],\n            y2: p2[1]\n          },\n          style: lineStyle,\n          silent: true\n        }));\n      }\n    }\n  },\n  splitArea: function (axisView, axisGroup, axisModel, gridModel) {\n    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);\n  }\n};\n\nvar CartesianAxisView_CartesianXAxisView =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6["a" /* __extends */])(CartesianXAxisView, _super);\n\n  function CartesianXAxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = CartesianXAxisView.type;\n    return _this;\n  }\n\n  CartesianXAxisView.type = \'xAxis\';\n  return CartesianXAxisView;\n}(CartesianAxisView_CartesianAxisView);\n\n\n\nvar CartesianAxisView_CartesianYAxisView =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6["a" /* __extends */])(CartesianYAxisView, _super);\n\n  function CartesianYAxisView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = CartesianAxisView_CartesianXAxisView.type;\n    return _this;\n  }\n\n  CartesianYAxisView.type = \'yAxis\';\n  return CartesianYAxisView;\n}(CartesianAxisView_CartesianAxisView);\n\n\n/* harmony default export */ var axis_CartesianAxisView = (CartesianAxisView_CartesianAxisView);\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/grid/installSimple.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\n\n\n // Grid view\n\nvar installSimple_GridView =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6["a" /* __extends */])(GridView, _super);\n\n  function GridView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = \'grid\';\n    return _this;\n  }\n\n  GridView.prototype.render = function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get(\'show\')) {\n      this.group.add(new Rect["a" /* default */]({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: Object(util["i" /* defaults */])({\n          fill: gridModel.get(\'backgroundColor\')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  };\n\n  GridView.type = \'grid\';\n  return GridView;\n}(Component["a" /* default */]);\n\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: \'\',\n  offset: 0\n};\nfunction install(registers) {\n  registers.registerComponentView(installSimple_GridView);\n  registers.registerComponentModel(cartesian_GridModel);\n  registers.registerCoordinateSystem(\'cartesian2d\', cartesian_Grid);\n  axisModelCreator(registers, \'x\', AxisModel_CartesianAxisModel, extraOption);\n  axisModelCreator(registers, \'y\', AxisModel_CartesianAxisModel, extraOption);\n  registers.registerComponentView(CartesianAxisView_CartesianXAxisView);\n  registers.registerComponentView(CartesianAxisView_CartesianYAxisView);\n  registers.registerPreprocessor(function (option) {\n    // Only create grid when need\n    if (option.xAxis && option.yAxis && !option.grid) {\n      option.grid = {};\n    }\n  });\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axisPointer/install.js + 5 modules\nvar axisPointer_install = __webpack_require__("af5c");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__("22b4");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/component/grid/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nfunction install_install(registers) {\n  Object(extension["a" /* use */])(install);\n  Object(extension["a" /* use */])(axisPointer_install["a" /* install */]);\n}\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/component/grid/install.js_+_16_modules?')},"50e5":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return DATA_ZOOM_AXIS_DIMENSIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return isCoordSupported; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return getAxisMainType; });\n/* unused harmony export getAxisIndexPropName */\n/* unused harmony export getAxisIdPropName */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return findEffectedDataZooms; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return collectReferCoordSysModelInfo; });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"6d8b\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar DATA_ZOOM_AXIS_DIMENSIONS = ['x', 'y', 'radius', 'angle', 'single']; // Supported coords.\n// FIXME: polar has been broken (but rarely used).\n\nvar SERIES_COORDS = ['cartesian2d', 'polar', 'singleAxis'];\nfunction isCoordSupported(seriesModel) {\n  var coordType = seriesModel.get('coordinateSystem');\n  return Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__[/* indexOf */ \"q\"])(SERIES_COORDS, coordType) >= 0;\n}\nfunction getAxisMainType(axisDim) {\n  if (false) {}\n\n  return axisDim + 'Axis';\n}\nfunction getAxisIndexPropName(axisDim) {\n  if (false) {}\n\n  return axisDim + 'AxisIndex';\n}\nfunction getAxisIdPropName(axisDim) {\n  if (false) {}\n\n  return axisDim + 'AxisId';\n}\n/**\n * If two dataZoomModels has the same axis controlled, we say that they are 'linked'.\n * This function finds all linked dataZoomModels start from the given payload.\n */\n\nfunction findEffectedDataZooms(ecModel, payload) {\n  // Key: `DataZoomAxisDimension`\n  var axisRecords = Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__[/* createHashMap */ \"f\"])();\n  var effectedModels = []; // Key: uid of dataZoomModel\n\n  var effectedModelMap = Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__[/* createHashMap */ \"f\"])(); // Find the dataZooms specified by payload.\n\n  ecModel.eachComponent({\n    mainType: 'dataZoom',\n    query: payload\n  }, function (dataZoomModel) {\n    if (!effectedModelMap.get(dataZoomModel.uid)) {\n      addToEffected(dataZoomModel);\n    }\n  }); // Start from the given dataZoomModels, travel the graph to find\n  // all of the linked dataZoom models.\n\n  var foundNewLink;\n\n  do {\n    foundNewLink = false;\n    ecModel.eachComponent('dataZoom', processSingle);\n  } while (foundNewLink);\n\n  function processSingle(dataZoomModel) {\n    if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {\n      addToEffected(dataZoomModel);\n      foundNewLink = true;\n    }\n  }\n\n  function addToEffected(dataZoom) {\n    effectedModelMap.set(dataZoom.uid, true);\n    effectedModels.push(dataZoom);\n    markAxisControlled(dataZoom);\n  }\n\n  function isLinked(dataZoomModel) {\n    var isLink = false;\n    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n      var axisIdxArr = axisRecords.get(axisDim);\n\n      if (axisIdxArr && axisIdxArr[axisIndex]) {\n        isLink = true;\n      }\n    });\n    return isLink;\n  }\n\n  function markAxisControlled(dataZoomModel) {\n    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n      (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;\n    });\n  }\n\n  return effectedModels;\n}\n/**\n * Find the first target coordinate system.\n * Available after model built.\n *\n * @return Like {\n *                  grid: [\n *                      {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n *                      {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n *                      ...\n *                  ],  // cartesians must not be null/undefined.\n *                  polar: [\n *                      {model: coord0, axisModels: [axis4], coordIndex: 0},\n *                      ...\n *                  ],  // polars must not be null/undefined.\n *                  singleAxis: [\n *                      {model: coord0, axisModels: [], coordIndex: 0}\n *                  ]\n *              }\n */\n\nfunction collectReferCoordSysModelInfo(dataZoomModel) {\n  var ecModel = dataZoomModel.ecModel;\n  var coordSysInfoWrap = {\n    infoList: [],\n    infoMap: Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__[/* createHashMap */ \"f\"])()\n  };\n  dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n    var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);\n\n    if (!axisModel) {\n      return;\n    }\n\n    var coordSysModel = axisModel.getCoordSysModel();\n\n    if (!coordSysModel) {\n      return;\n    }\n\n    var coordSysUid = coordSysModel.uid;\n    var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);\n\n    if (!coordSysInfo) {\n      coordSysInfo = {\n        model: coordSysModel,\n        axisModels: []\n      };\n      coordSysInfoWrap.infoList.push(coordSysInfo);\n      coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);\n    }\n\n    coordSysInfo.axisModels.push(axisModel);\n  });\n  return coordSysInfoWrap;\n}\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/component/dataZoom/helper.js?")},5426:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isCoordinateSystemType; });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction isCoordinateSystemType(coordSys, type) {\n  return coordSys.type === type;\n}\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/coord/CoordinateSystem.js?')},"64fc":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/components/ECharts/Line.vue?./node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!./node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!./node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--6-oneOf-1-2!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/@vue/cli-service/node_modules/vue-loader/lib??vue-loader-options")},6940:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_vue_cli_service_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_cli_service_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_cli_service_node_modules_vue_loader_lib_index_js_vue_loader_options_Line_vue_vue_type_style_index_0_id_6452f13c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("64fc");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_vue_cli_service_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_cli_service_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_cli_service_node_modules_vue_loader_lib_index_js_vue_loader_options_Line_vue_vue_type_style_index_0_id_6452f13c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_vue_cli_service_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_cli_service_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_cli_service_node_modules_vue_loader_lib_index_js_vue_loader_options_Line_vue_vue_type_style_index_0_id_6452f13c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n\n//# sourceURL=webpack:///./src/components/ECharts/Line.vue?')},"7dcf":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7fae");\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("b12f");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nvar DataZoomView =\n/** @class */\nfunction (_super) {\n  Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"])(DataZoomView, _super);\n\n  function DataZoomView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = DataZoomView.type;\n    return _this;\n  }\n\n  DataZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {\n    this.dataZoomModel = dataZoomModel;\n    this.ecModel = ecModel;\n    this.api = api;\n  };\n\n  DataZoomView.type = \'dataZoom\';\n  return DataZoomView;\n}(_view_Component_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);\n\n/* harmony default export */ __webpack_exports__["a"] = (DataZoomView);\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/component/dataZoom/DataZoomView.js?')},a4fe:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return take; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return release; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isTaken; });\n/* harmony import */ var _core_echarts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1be7");\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("6d8b");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// @ts-nocheck\n\n\nvar ATTR = \'\\0_ec_interaction_mutex\';\nfunction take(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  store[resourceKey] = userKey;\n}\nfunction release(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  var uKey = store[resourceKey];\n\n  if (uKey === userKey) {\n    store[resourceKey] = null;\n  }\n}\nfunction isTaken(zr, resourceKey) {\n  return !!getStore(zr)[resourceKey];\n}\n\nfunction getStore(zr) {\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n/**\n * payload: {\n *     type: \'takeGlobalCursor\',\n *     key: \'dataZoomSelect\', or \'brush\', or ...,\n *         If no userKey, release global cursor.\n * }\n */\n// TODO: SELF REGISTERED.\n\n\n_core_echarts_js__WEBPACK_IMPORTED_MODULE_0__[/* registerAction */ "c"]({\n  type: \'takeGlobalCursor\',\n  event: \'globalCursorTaken\',\n  update: \'update\'\n}, zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* noop */ "I"]);\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/component/helper/interactionMutex.js?')},b0af:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createGridClipPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return createPolarClipPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createClipPath; });\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("c7a2");\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("deab");\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("4aa2");\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("3842");\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("6d8b");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\nfunction createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {\n  var rect = cartesian.getArea();\n  var x = rect.x;\n  var y = rect.y;\n  var width = rect.width;\n  var height = rect.height;\n  var lineWidth = seriesModel.get([\'lineStyle\', \'width\']) || 2; // Expand the clip path a bit to avoid the border is clipped and looks thinner\n\n  x -= lineWidth / 2;\n  y -= lineWidth / 2;\n  width += lineWidth;\n  height += lineWidth; // fix: https://github.com/apache/incubator-echarts/issues/11369\n\n  x = Math.floor(x);\n  width = Math.round(width);\n  var clipPath = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    var baseAxis = cartesian.getBaseAxis();\n    var isHorizontal = baseAxis.isHorizontal();\n    var isAxisInversed = baseAxis.inverse;\n\n    if (isHorizontal) {\n      if (isAxisInversed) {\n        clipPath.shape.x += width;\n      }\n\n      clipPath.shape.width = 0;\n    } else {\n      if (!isAxisInversed) {\n        clipPath.shape.y += height;\n      }\n\n      clipPath.shape.height = 0;\n    }\n\n    var duringCb = Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__[/* isFunction */ "v"])(during) ? function (percent) {\n      during(percent, clipPath);\n    } : null;\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__[/* initProps */ "a"](clipPath, {\n      shape: {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n      }\n    }, seriesModel, null, done, duringCb);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipPath(polar, hasAnimation, seriesModel) {\n  var sectorArea = polar.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.\n\n  var r0 = Object(_util_number_js__WEBPACK_IMPORTED_MODULE_3__[/* round */ "r"])(sectorArea.r0, 1);\n  var r = Object(_util_number_js__WEBPACK_IMPORTED_MODULE_3__[/* round */ "r"])(sectorArea.r, 1);\n  var clipPath = new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({\n    shape: {\n      cx: Object(_util_number_js__WEBPACK_IMPORTED_MODULE_3__[/* round */ "r"])(polar.cx, 1),\n      cy: Object(_util_number_js__WEBPACK_IMPORTED_MODULE_3__[/* round */ "r"])(polar.cy, 1),\n      r0: r0,\n      r: r,\n      startAngle: sectorArea.startAngle,\n      endAngle: sectorArea.endAngle,\n      clockwise: sectorArea.clockwise\n    }\n  });\n\n  if (hasAnimation) {\n    var isRadial = polar.getBaseAxis().dim === \'angle\';\n\n    if (isRadial) {\n      clipPath.shape.endAngle = sectorArea.startAngle;\n    } else {\n      clipPath.shape.r = r0;\n    }\n\n    _util_graphic_js__WEBPACK_IMPORTED_MODULE_1__[/* initProps */ "a"](clipPath, {\n      shape: {\n        endAngle: sectorArea.endAngle,\n        r: r\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipPath(coordSys, hasAnimation, seriesModel, done, during) {\n  if (!coordSys) {\n    return null;\n  } else if (coordSys.type === \'polar\') {\n    return createPolarClipPath(coordSys, hasAnimation, seriesModel);\n  } else if (coordSys.type === \'cartesian2d\') {\n    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);\n  }\n\n  return null;\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js?')},c775:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getDefaultLabel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getDefaultInterpolatedLabel; });\n/* harmony import */ var _data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("2b17");\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("6d8b");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * @return label string. Not null/undefined\n */\n\nfunction getDefaultLabel(data, dataIndex) {\n  var labelDims = data.mapDimensionsAll(\'defaultedLabel\');\n  var len = labelDims.length; // Simple optimization (in lots of cases, label dims length is 1)\n\n  if (len === 1) {\n    var rawVal = Object(_data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_0__[/* retrieveRawValue */ "e"])(data, dataIndex, labelDims[0]);\n    return rawVal != null ? rawVal + \'\' : null;\n  } else if (len) {\n    var vals = [];\n\n    for (var i = 0; i < labelDims.length; i++) {\n      vals.push(Object(_data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_0__[/* retrieveRawValue */ "e"])(data, dataIndex, labelDims[i]));\n    }\n\n    return vals.join(\' \');\n  }\n}\nfunction getDefaultInterpolatedLabel(data, interpolatedValue) {\n  var labelDims = data.mapDimensionsAll(\'defaultedLabel\');\n\n  if (!Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__[/* isArray */ "s"])(interpolatedValue)) {\n    return interpolatedValue + \'\';\n  }\n\n  var vals = [];\n\n  for (var i = 0; i < labelDims.length; i++) {\n    var dimIndex = data.getDimensionIndex(labelDims[i]);\n\n    if (dimIndex >= 0) {\n      vals.push(interpolatedValue[dimIndex]);\n    }\n  }\n\n  return vals.join(\' \');\n}\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/chart/helper/labelHelper.js?')},ea80:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"227a4198-vue-loader-template\"}!./node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/@vue/cli-service/node_modules/vue-loader/lib??vue-loader-options!./src/views/teacher/sell/Dashboard.vue?vue&type=template&id=9d71548a&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"my-content\"},[_c('a-tabs',{staticClass:\"my-tab\",attrs:{\"type\":\"card\"},on:{\"change\":_vm.changeTab}},[_c('a-tab-pane',{key:\"1\"},[_c('span',{attrs:{\"slot\":\"tab\"},slot:\"tab\"},[_c('a-icon',{attrs:{\"type\":\"area-chart\"}}),_vm._v(\" Dashboard \")],1),_c('div',{staticClass:\"dashboard-content\"},[_c('div',{staticClass:\"dashboard-filter\"},[_c('div',{staticClass:\"filter-base\"},[_c('div',{staticClass:\"filter-options\"},[_c('a-select',{staticClass:\"filter-item\",attrs:{\"size\":\"large\",\"placeholder\":\"Search by type\"},on:{\"change\":_vm.triggerSearch},model:{value:(_vm.filterParams.statisticsType),callback:function ($$v) {_vm.$set(_vm.filterParams, \"statisticsType\", $$v)},expression:\"filterParams.statisticsType\"}},_vm._l((_vm.typeOptions),function(item,index){return _c('a-select-option',{key:'type_'+index,attrs:{\"value\":item.value}},[_vm._v(\" \"+_vm._s(item.label)+\" \")])}),1)],1),_c('div',{staticClass:\"filter-options\"},[_c('div',[_c('a-select',{staticClass:\"filter-item\",attrs:{\"size\":\"large\",\"placeholder\":\"Select a during\"},on:{\"change\":_vm.triggerSearch},model:{value:(_vm.filterParams.duringsType),callback:function ($$v) {_vm.$set(_vm.filterParams, \"duringsType\", $$v)},expression:\"filterParams.duringsType\"}},_vm._l((_vm.duringOptions),function(item,index){return _c('a-select-option',{key:'type_'+index,attrs:{\"value\":item.value}},[_vm._v(\" \"+_vm._s(item.label)+\" \")])}),1),_c('a-range-picker',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.filterParams.duringsType === 7),expression:\"filterParams.duringsType === 7\"}],staticStyle:{\"margin-left\":\"10px\"},attrs:{\"size\":\"large\"},on:{\"change\":_vm.onChangeDate},model:{value:(_vm.filterParams.during),callback:function ($$v) {_vm.$set(_vm.filterParams, \"during\", $$v)},expression:\"filterParams.during\"}})],1)])]),_c('div',{staticClass:\"filter-summary\"},[_c('div',{staticClass:\"summary-title\"},[_vm._v(_vm._s(_vm.title))]),_c('div',{staticClass:\"summary-total\"},[_vm._v(_vm._s(_vm.formatSum(_vm.sum)))])])]),_c('div',{staticClass:\"dashboard-chart\"},[_c('e-line',{attrs:{\"datas\":_vm.dataSource,\"height\":\"350px\"}})],1)])])],1)],1)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/views/teacher/sell/Dashboard.vue?vue&type=template&id=9d71548a&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules\nvar toConsumableArray = __webpack_require__(\"2909\");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 3 modules\nvar slicedToArray = __webpack_require__(\"3835\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.values.js\nvar es_object_values = __webpack_require__(\"07ac\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find.js\nvar es_array_find = __webpack_require__(\"7db0\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js\nvar es_object_to_string = __webpack_require__(\"d3b7\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js\nvar es_array_map = __webpack_require__(\"d81d\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js\nvar es_regexp_exec = __webpack_require__(\"ac1f\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js\nvar es_string_split = __webpack_require__(\"1276\");\n\n// EXTERNAL MODULE: ./node_modules/moment/moment.js\nvar moment = __webpack_require__(\"c1df\");\nvar moment_default = /*#__PURE__*/__webpack_require__.n(moment);\n\n// CONCATENATED MODULE: ./src/const/dateRange.js\n\nvar DATERANGE_FOR_CHARTS = {\n  'Today': [moment_default()().startOf('day'), moment_default()().endOf('day')],\n  // 'Yesterday': [moment().subtract(1, 'days').startOf('day'), moment().subtract(1, 'days').endOf('day')],\n  'This week': [moment_default()().startOf('isoWeek').startOf('day'), moment_default()().endOf('day')],\n  'This month': [moment_default()().startOf('month').startOf('day'), moment_default()().endOf('day')],\n  'This quarter': [moment_default()().startOf('quarter').startOf('day'), moment_default()().endOf('day')],\n  'This year': [moment_default()().startOf('year').startOf('day'), moment_default()().endOf('day')],\n  'All Time': [moment_default()('2013-01-01').startOf('day'), moment_default()().endOf('day')]\n};\nvar DURING_TYPE = [{\n  value: 1,\n  label: 'Today'\n}, {\n  value: 2,\n  label: 'This week'\n}, {\n  value: 3,\n  label: 'This month'\n}, {\n  value: 4,\n  label: 'This quarter'\n}, {\n  value: 5,\n  label: 'This year'\n}, {\n  value: 6,\n  label: 'All time'\n}, {\n  value: 7,\n  label: 'Custom Range'\n}];\n// EXTERNAL MODULE: ./src/const/common.js\nvar common = __webpack_require__(\"f93e\");\n\n// EXTERNAL MODULE: ./src/api/statistics.js\nvar statistics = __webpack_require__(\"48fb\");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"227a4198-vue-loader-template\"}!./node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/@vue/cli-service/node_modules/vue-loader/lib??vue-loader-options!./src/components/ECharts/Line.vue?vue&type=template&id=6452f13c&scoped=true&\nvar Linevue_type_template_id_6452f13c_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"chartGraph\",style:({height: _vm.height})},[_c('v-chart',{ref:\"chart\",attrs:{\"option\":_vm.options,\"autoresize\":true}})],1)}\nvar Linevue_type_template_id_6452f13c_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/ECharts/Line.vue?vue&type=template&id=6452f13c&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js\nvar es_number_constructor = __webpack_require__(\"a9e3\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js\nvar es_array_concat = __webpack_require__(\"99af\");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js\nvar es_function_name = __webpack_require__(\"b0c0\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(\"22b4\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/renderer/installCanvasRenderer.js + 2 modules\nvar installCanvasRenderer = __webpack_require__(\"f95e\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(\"7fae\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createSeriesData.js + 1 modules\nvar createSeriesData = __webpack_require__(\"1830\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Series.js + 2 modules\nvar Series = __webpack_require__(\"4f85\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar util_symbol = __webpack_require__(\"a15a\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(\"2dc5\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/chart/line/LineSeries.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\nvar LineSeries_LineSeriesModel =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(LineSeriesModel, _super);\n\n  function LineSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = LineSeriesModel.type;\n    _this.hasSymbolVisual = true;\n    return _this;\n  }\n\n  LineSeriesModel.prototype.getInitialData = function (option) {\n    if (false) { var coordSys; }\n\n    return Object(createSeriesData[\"a\" /* default */])(null, this, {\n      useEncodeDefaulter: true\n    });\n  };\n\n  LineSeriesModel.prototype.getLegendIcon = function (opt) {\n    var group = new Group[\"a\" /* default */]();\n    var line = Object(util_symbol[\"a\" /* createSymbol */])('line', 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);\n    group.add(line);\n    line.setStyle(opt.lineStyle);\n    var visualType = this.getData().getVisual('symbol');\n    var visualRotate = this.getData().getVisual('symbolRotate');\n    var symbolType = visualType === 'none' ? 'circle' : visualType; // Symbol size is 80% when there is a line\n\n    var size = opt.itemHeight * 0.8;\n    var symbol = Object(util_symbol[\"a\" /* createSymbol */])(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);\n    group.add(symbol);\n    symbol.setStyle(opt.itemStyle);\n    var symbolRotate = opt.iconRotate === 'inherit' ? visualRotate : opt.iconRotate || 0;\n    symbol.rotation = symbolRotate * Math.PI / 180;\n    symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);\n\n    if (symbolType.indexOf('empty') > -1) {\n      symbol.style.stroke = symbol.style.fill;\n      symbol.style.fill = '#fff';\n      symbol.style.lineWidth = 2;\n    }\n\n    return group;\n  };\n\n  LineSeriesModel.type = 'series.line';\n  LineSeriesModel.dependencies = ['grid', 'polar'];\n  LineSeriesModel.defaultOption = {\n    // zlevel: 0,\n    z: 3,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    clip: true,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    endLabel: {\n      show: false,\n      valueAnimation: true,\n      distance: 8\n    },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    emphasis: {\n      scale: true\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    symbol: 'emptyCircle',\n    symbolSize: 4,\n    symbolRotate: null,\n    showSymbol: true,\n    // `false`: follow the label interval strategy.\n    // `true`: show all symbols.\n    // `'auto'`: If possible, show all symbols, otherwise\n    //           follow the label interval strategy.\n    showAllSymbol: 'auto',\n    // Whether to connect break point.\n    connectNulls: false,\n    // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity,\n    universalTransition: {\n      divideShape: 'clone'\n    },\n    triggerLineEvent: false\n  };\n  return LineSeriesModel;\n}(Series[\"a\" /* default */]);\n\n/* harmony default export */ var LineSeries = (LineSeries_LineSeriesModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(\"6d8b\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/animation/basicTrasition.js\nvar basicTrasition = __webpack_require__(\"deab\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js + 8 modules\nvar graphic = __webpack_require__(\"2306\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(\"861c\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(\"7d6c\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/labelHelper.js\nvar labelHelper = __webpack_require__(\"c775\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(\"7837\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Image.js\nvar Image = __webpack_require__(\"0da8\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/chart/helper/Symbol.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\n\n\n\n\n\n\nvar Symbol_Symbol =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(Symbol, _super);\n\n  function Symbol(data, idx, seriesScope, opts) {\n    var _this = _super.call(this) || this;\n\n    _this.updateData(data, idx, seriesScope, opts);\n\n    return _this;\n  }\n\n  Symbol.prototype._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {\n    // Remove paths created before\n    this.removeAll(); // let symbolPath = createSymbol(\n    //     symbolType, -0.5, -0.5, 1, 1, color\n    // );\n    // If width/height are set too small (e.g., set to 1) on ios10\n    // and macOS Sierra, a circle stroke become a rect, no matter what\n    // the scale is set. So we set width/height as 2. See #4150.\n\n    var symbolPath = Object(util_symbol[\"a\" /* createSymbol */])(symbolType, -1, -1, 2, 2, null, keepAspect);\n    symbolPath.attr({\n      z2: 100,\n      culling: true,\n      scaleX: symbolSize[0] / 2,\n      scaleY: symbolSize[1] / 2\n    }); // Rewrite drift method\n\n    symbolPath.drift = driftSymbol;\n    this._symbolType = symbolType;\n    this.add(symbolPath);\n  };\n  /**\n   * Stop animation\n   * @param {boolean} toLastFrame\n   */\n\n\n  Symbol.prototype.stopSymbolAnimation = function (toLastFrame) {\n    this.childAt(0).stopAnimation(null, toLastFrame);\n  };\n\n  Symbol.prototype.getSymbolType = function () {\n    return this._symbolType;\n  };\n  /**\n   * FIXME:\n   * Caution: This method breaks the encapsulation of this module,\n   * but it indeed brings convenience. So do not use the method\n   * unless you detailedly know all the implements of `Symbol`,\n   * especially animation.\n   *\n   * Get symbol path element.\n   */\n\n\n  Symbol.prototype.getSymbolPath = function () {\n    return this.childAt(0);\n  };\n  /**\n   * Highlight symbol\n   */\n\n\n  Symbol.prototype.highlight = function () {\n    Object(states[\"o\" /* enterEmphasis */])(this.childAt(0));\n  };\n  /**\n   * Downplay symbol\n   */\n\n\n  Symbol.prototype.downplay = function () {\n    Object(states[\"z\" /* leaveEmphasis */])(this.childAt(0));\n  };\n  /**\n   * @param {number} zlevel\n   * @param {number} z\n   */\n\n\n  Symbol.prototype.setZ = function (zlevel, z) {\n    var symbolPath = this.childAt(0);\n    symbolPath.zlevel = zlevel;\n    symbolPath.z = z;\n  };\n\n  Symbol.prototype.setDraggable = function (draggable) {\n    var symbolPath = this.childAt(0);\n    symbolPath.draggable = draggable;\n    symbolPath.cursor = draggable ? 'move' : symbolPath.cursor;\n  };\n  /**\n   * Update symbol properties\n   */\n\n\n  Symbol.prototype.updateData = function (data, idx, seriesScope, opts) {\n    this.silent = false;\n    var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n    var seriesModel = data.hostModel;\n    var symbolSize = Symbol.getSymbolSize(data, idx);\n    var isInit = symbolType !== this._symbolType;\n    var disableAnimation = opts && opts.disableAnimation;\n\n    if (isInit) {\n      var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');\n\n      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);\n    } else {\n      var symbolPath = this.childAt(0);\n      symbolPath.silent = false;\n      var target = {\n        scaleX: symbolSize[0] / 2,\n        scaleY: symbolSize[1] / 2\n      };\n      disableAnimation ? symbolPath.attr(target) : basicTrasition[\"f\" /* updateProps */](symbolPath, target, seriesModel, idx);\n      Object(basicTrasition[\"e\" /* saveOldStyle */])(symbolPath);\n    }\n\n    this._updateCommon(data, idx, symbolSize, seriesScope, opts);\n\n    if (isInit) {\n      var symbolPath = this.childAt(0);\n\n      if (!disableAnimation) {\n        var target = {\n          scaleX: this._sizeX,\n          scaleY: this._sizeY,\n          style: {\n            // Always fadeIn. Because it has fadeOut animation when symbol is removed..\n            opacity: symbolPath.style.opacity\n          }\n        };\n        symbolPath.scaleX = symbolPath.scaleY = 0;\n        symbolPath.style.opacity = 0;\n        basicTrasition[\"a\" /* initProps */](symbolPath, target, seriesModel, idx);\n      }\n    }\n\n    if (disableAnimation) {\n      // Must stop leave transition manually if don't call initProps or updateProps.\n      this.childAt(0).stopAnimation('leave');\n    }\n  };\n\n  Symbol.prototype._updateCommon = function (data, idx, symbolSize, seriesScope, opts) {\n    var symbolPath = this.childAt(0);\n    var seriesModel = data.hostModel;\n    var emphasisItemStyle;\n    var blurItemStyle;\n    var selectItemStyle;\n    var focus;\n    var blurScope;\n    var emphasisDisabled;\n    var labelStatesModels;\n    var hoverScale;\n    var cursorStyle;\n\n    if (seriesScope) {\n      emphasisItemStyle = seriesScope.emphasisItemStyle;\n      blurItemStyle = seriesScope.blurItemStyle;\n      selectItemStyle = seriesScope.selectItemStyle;\n      focus = seriesScope.focus;\n      blurScope = seriesScope.blurScope;\n      labelStatesModels = seriesScope.labelStatesModels;\n      hoverScale = seriesScope.hoverScale;\n      cursorStyle = seriesScope.cursorStyle;\n      emphasisDisabled = seriesScope.emphasisDisabled;\n    }\n\n    if (!seriesScope || data.hasItemOption) {\n      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);\n      var emphasisModel = itemModel.getModel('emphasis');\n      emphasisItemStyle = emphasisModel.getModel('itemStyle').getItemStyle();\n      selectItemStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();\n      blurItemStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();\n      focus = emphasisModel.get('focus');\n      blurScope = emphasisModel.get('blurScope');\n      emphasisDisabled = emphasisModel.get('disabled');\n      labelStatesModels = Object(labelStyle[\"c\" /* getLabelStatesModels */])(itemModel);\n      hoverScale = emphasisModel.getShallow('scale');\n      cursorStyle = itemModel.getShallow('cursor');\n    }\n\n    var symbolRotate = data.getItemVisual(idx, 'symbolRotate');\n    symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n    var symbolOffset = Object(util_symbol[\"b\" /* normalizeSymbolOffset */])(data.getItemVisual(idx, 'symbolOffset'), symbolSize);\n\n    if (symbolOffset) {\n      symbolPath.x = symbolOffset[0];\n      symbolPath.y = symbolOffset[1];\n    }\n\n    cursorStyle && symbolPath.attr('cursor', cursorStyle);\n    var symbolStyle = data.getItemVisual(idx, 'style');\n    var visualColor = symbolStyle.fill;\n\n    if (symbolPath instanceof Image[\"a\" /* default */]) {\n      var pathStyle = symbolPath.style;\n      symbolPath.useStyle(Object(util[\"m\" /* extend */])({\n        // TODO other properties like x, y ?\n        image: pathStyle.image,\n        x: pathStyle.x,\n        y: pathStyle.y,\n        width: pathStyle.width,\n        height: pathStyle.height\n      }, symbolStyle));\n    } else {\n      if (symbolPath.__isEmptyBrush) {\n        // fill and stroke will be swapped if it's empty.\n        // So we cloned a new style to avoid it affecting the original style in visual storage.\n        // TODO Better implementation. No empty logic!\n        symbolPath.useStyle(Object(util[\"m\" /* extend */])({}, symbolStyle));\n      } else {\n        symbolPath.useStyle(symbolStyle);\n      } // Disable decal because symbol scale will been applied on the decal.\n\n\n      symbolPath.style.decal = null;\n      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);\n      symbolPath.style.strokeNoScale = true;\n    }\n\n    var liftZ = data.getItemVisual(idx, 'liftZ');\n    var z2Origin = this._z2;\n\n    if (liftZ != null) {\n      if (z2Origin == null) {\n        this._z2 = symbolPath.z2;\n        symbolPath.z2 += liftZ;\n      }\n    } else if (z2Origin != null) {\n      symbolPath.z2 = z2Origin;\n      this._z2 = null;\n    }\n\n    var useNameLabel = opts && opts.useNameLabel;\n    Object(labelStyle[\"e\" /* setLabelStyle */])(symbolPath, labelStatesModels, {\n      labelFetcher: seriesModel,\n      labelDataIndex: idx,\n      defaultText: getLabelDefaultText,\n      inheritColor: visualColor,\n      defaultOpacity: symbolStyle.opacity\n    }); // Do not execute util needed.\n\n    function getLabelDefaultText(idx) {\n      return useNameLabel ? data.getName(idx) : Object(labelHelper[\"b\" /* getDefaultLabel */])(data, idx);\n    }\n\n    this._sizeX = symbolSize[0] / 2;\n    this._sizeY = symbolSize[1] / 2;\n    var emphasisState = symbolPath.ensureState('emphasis');\n    emphasisState.style = emphasisItemStyle;\n    symbolPath.ensureState('select').style = selectItemStyle;\n    symbolPath.ensureState('blur').style = blurItemStyle;\n\n    if (hoverScale) {\n      var scaleRatio = Math.max(1.1, 3 / this._sizeY);\n      emphasisState.scaleX = this._sizeX * scaleRatio;\n      emphasisState.scaleY = this._sizeY * scaleRatio;\n    }\n\n    this.setSymbolScale(1);\n    Object(states[\"E\" /* toggleHoverEmphasis */])(this, focus, blurScope, emphasisDisabled);\n  };\n\n  Symbol.prototype.setSymbolScale = function (scale) {\n    this.scaleX = this.scaleY = scale;\n  };\n\n  Symbol.prototype.fadeOut = function (cb, seriesModel, opt) {\n    var symbolPath = this.childAt(0);\n    var dataIndex = Object(innerStore[\"a\" /* getECData */])(this).dataIndex;\n    var animationOpt = opt && opt.animation; // Avoid mistaken hover when fading out\n\n    this.silent = symbolPath.silent = true; // Not show text when animating\n\n    if (opt && opt.fadeLabel) {\n      var textContent = symbolPath.getTextContent();\n\n      if (textContent) {\n        basicTrasition[\"c\" /* removeElement */](textContent, {\n          style: {\n            opacity: 0\n          }\n        }, seriesModel, {\n          dataIndex: dataIndex,\n          removeOpt: animationOpt,\n          cb: function () {\n            symbolPath.removeTextContent();\n          }\n        });\n      }\n    } else {\n      symbolPath.removeTextContent();\n    }\n\n    basicTrasition[\"c\" /* removeElement */](symbolPath, {\n      style: {\n        opacity: 0\n      },\n      scaleX: 0,\n      scaleY: 0\n    }, seriesModel, {\n      dataIndex: dataIndex,\n      cb: cb,\n      removeOpt: animationOpt\n    });\n  };\n\n  Symbol.getSymbolSize = function (data, idx) {\n    return Object(util_symbol[\"c\" /* normalizeSymbolSize */])(data.getItemVisual(idx, 'symbolSize'));\n  };\n\n  return Symbol;\n}(Group[\"a\" /* default */]);\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\n/* harmony default export */ var helper_Symbol = (Symbol_Symbol);\n// CONCATENATED MODULE: ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of\n  // the symbol element shape. We use the same clip shape here as\n  // the line clip.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !Object(util[\"z\" /* isObject */])(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  var emphasisModel = seriesModel.getModel('emphasis');\n  return {\n    emphasisItemStyle: emphasisModel.getModel('itemStyle').getItemStyle(),\n    blurItemStyle: seriesModel.getModel(['blur', 'itemStyle']).getItemStyle(),\n    selectItemStyle: seriesModel.getModel(['select', 'itemStyle']).getItemStyle(),\n    focus: emphasisModel.get('focus'),\n    blurScope: emphasisModel.get('blurScope'),\n    emphasisDisabled: emphasisModel.get('disabled'),\n    hoverScale: emphasisModel.get('scale'),\n    labelStatesModels: Object(labelStyle[\"c\" /* getLabelStatesModels */])(seriesModel),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar SymbolDraw_SymbolDraw =\n/** @class */\nfunction () {\n  function SymbolDraw(SymbolCtor) {\n    this.group = new Group[\"a\" /* default */]();\n    this._SymbolCtor = SymbolCtor || helper_Symbol;\n  }\n  /**\n   * Update symbols draw by new data\n   */\n\n\n  SymbolDraw.prototype.updateData = function (data, opt) {\n    // Remove progressive els.\n    this._progressiveEls = null;\n    opt = normalizeUpdateOpt(opt);\n    var group = this.group;\n    var seriesModel = data.hostModel;\n    var oldData = this._data;\n    var SymbolCtor = this._SymbolCtor;\n    var disableAnimation = opt.disableAnimation;\n    var seriesScope = makeSeriesScope(data);\n    var symbolUpdateOpt = {\n      disableAnimation: disableAnimation\n    };\n\n    var getSymbolPoint = opt.getSymbolPoint || function (idx) {\n      return data.getItemLayout(idx);\n    }; // There is no oldLineData only when first rendering or switching from\n    // stream mode to normal mode, where previous elements should be removed.\n\n\n    if (!oldData) {\n      group.removeAll();\n    }\n\n    data.diff(oldData).add(function (newIdx) {\n      var point = getSymbolPoint(newIdx);\n\n      if (symbolNeedsDraw(data, point, newIdx, opt)) {\n        var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);\n        symbolEl.setPosition(point);\n        data.setItemGraphicEl(newIdx, symbolEl);\n        group.add(symbolEl);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var symbolEl = oldData.getItemGraphicEl(oldIdx);\n      var point = getSymbolPoint(newIdx);\n\n      if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n        group.remove(symbolEl);\n        return;\n      }\n\n      var newSymbolType = data.getItemVisual(newIdx, 'symbol') || 'circle';\n      var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();\n\n      if (!symbolEl // Create a new if symbol type changed.\n      || oldSymbolType && oldSymbolType !== newSymbolType) {\n        group.remove(symbolEl);\n        symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);\n        symbolEl.setPosition(point);\n      } else {\n        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);\n        var target = {\n          x: point[0],\n          y: point[1]\n        };\n        disableAnimation ? symbolEl.attr(target) : basicTrasition[\"f\" /* updateProps */](symbolEl, target, seriesModel);\n      } // Add back\n\n\n      group.add(symbolEl);\n      data.setItemGraphicEl(newIdx, symbolEl);\n    }).remove(function (oldIdx) {\n      var el = oldData.getItemGraphicEl(oldIdx);\n      el && el.fadeOut(function () {\n        group.remove(el);\n      }, seriesModel);\n    }).execute();\n    this._getSymbolPoint = getSymbolPoint;\n    this._data = data;\n  };\n\n  ;\n\n  SymbolDraw.prototype.updateLayout = function () {\n    var _this = this;\n\n    var data = this._data;\n\n    if (data) {\n      // Not use animation\n      data.eachItemGraphicEl(function (el, idx) {\n        var point = _this._getSymbolPoint(idx);\n\n        el.setPosition(point);\n        el.markRedraw();\n      });\n    }\n  };\n\n  ;\n\n  SymbolDraw.prototype.incrementalPrepareUpdate = function (data) {\n    this._seriesScope = makeSeriesScope(data);\n    this._data = null;\n    this.group.removeAll();\n  };\n\n  ;\n  /**\n   * Update symbols draw by new data\n   */\n\n  SymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {\n    // Clear\n    this._progressiveEls = [];\n    opt = normalizeUpdateOpt(opt);\n\n    function updateIncrementalAndHover(el) {\n      if (!el.isGroup) {\n        el.incremental = true;\n        el.ensureState('emphasis').hoverLayer = true;\n      }\n    }\n\n    for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n      var point = data.getItemLayout(idx);\n\n      if (symbolNeedsDraw(data, point, idx, opt)) {\n        var el = new this._SymbolCtor(data, idx, this._seriesScope);\n        el.traverse(updateIncrementalAndHover);\n        el.setPosition(point);\n        this.group.add(el);\n        data.setItemGraphicEl(idx, el);\n\n        this._progressiveEls.push(el);\n      }\n    }\n  };\n\n  ;\n\n  SymbolDraw.prototype.eachRendered = function (cb) {\n    graphic[\"traverseElements\"](this._progressiveEls || this.group, cb);\n  };\n\n  SymbolDraw.prototype.remove = function (enableAnimation) {\n    var group = this.group;\n    var data = this._data; // Incremental model do not have this._data.\n\n    if (data && enableAnimation) {\n      data.eachItemGraphicEl(function (el) {\n        el.fadeOut(function () {\n          group.remove(el);\n        }, data.hostModel);\n      });\n    } else {\n      group.removeAll();\n    }\n  };\n\n  ;\n  return SymbolDraw;\n}();\n\n/* harmony default export */ var helper_SymbolDraw = (SymbolDraw_SymbolDraw);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/dataStackHelper.js\nvar dataStackHelper = __webpack_require__(\"ee1a\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/chart/line/helper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var dims = Object(util[\"F\" /* map */])(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  var stacked = false;\n  var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n  if (Object(dataStackHelper[\"c\" /* isDimensionStacked */])(data, dims[0]\n  /*, dims[1]*/\n  )) {\n    // jshint ignore:line\n    stacked = true;\n    dims[0] = stackResultDim;\n  }\n\n  if (Object(dataStackHelper[\"c\" /* isDimensionStacked */])(data, dims[1]\n  /*, dims[0]*/\n  )) {\n    // jshint ignore:line\n    stacked = true;\n    dims[1] = stackResultDim;\n  }\n\n  return {\n    dataDimsForPoint: dims,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: !!stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/vendor.js\nvar vendor = __webpack_require__(\"f658\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // let newIdList = newData.mapArray(newData.getId);\n  // let oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin); // const oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  var oldPoints = oldData.getLayout('points') || [];\n  var newPoints = newData.getLayout('points') || [];\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true;\n    var oldIdx2 = void 0;\n    var newIdx2 = void 0; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        oldIdx2 = diffItem.idx * 2;\n        newIdx2 = diffItem.idx1 * 2;\n        var currentX = oldPoints[oldIdx2];\n        var currentY = oldPoints[oldIdx2 + 1];\n        var nextX = newPoints[newIdx2];\n        var nextY = newPoints[newIdx2 + 1]; // If previous data is NaN, use next point directly\n\n        if (isNaN(currentX) || isNaN(currentY)) {\n          currentX = nextX;\n          currentY = nextY;\n        }\n\n        currPoints.push(currentX, currentY);\n        nextPoints.push(nextX, nextY);\n        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);\n        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var newIdx = diffItem.idx;\n        var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;\n        var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);\n        newIdx2 = newIdx * 2;\n        currPoints.push(oldPt[0], oldPt[1]);\n        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);\n        var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);\n        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);\n        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);\n        rawIndices.push(newData.getRawIndex(newIdx));\n        break;\n\n      case '-':\n        pointAdded = false;\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var len = currPoints.length;\n  var sortedCurrPoints = Object(vendor[\"a\" /* createFloat32Array */])(len);\n  var sortedNextPoints = Object(vendor[\"a\" /* createFloat32Array */])(len);\n  var sortedCurrStackedPoints = Object(vendor[\"a\" /* createFloat32Array */])(len);\n  var sortedNextStackedPoints = Object(vendor[\"a\" /* createFloat32Array */])(len);\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    var i2 = i * 2;\n    var idx2 = idx * 2;\n    sortedCurrPoints[i2] = currPoints[idx2];\n    sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];\n    sortedNextPoints[i2] = nextPoints[idx2];\n    sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];\n    sortedCurrStackedPoints[i2] = currStackedPoints[idx2];\n    sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];\n    sortedNextStackedPoints[i2] = nextStackedPoints[idx2];\n    sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/LinearGradient.js\nvar LinearGradient = __webpack_require__(\"48a9\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(\"76a5\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(\"e0d3\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Path.js + 6 modules\nvar Path = __webpack_require__(\"cbe5\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/PathProxy.js + 1 modules\nvar PathProxy = __webpack_require__(\"20c8\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/curve.js\nvar curve = __webpack_require__(\"4a3f\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/chart/line/poly.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n // Poly path support NaN point\n\n\n\n\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n\nfunction isPointNull(x, y) {\n  return isNaN(x) || isNaN(y);\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {\n  var prevX;\n  var prevY;\n  var cpx0;\n  var cpy0;\n  var cpx1;\n  var cpy1;\n  var idx = start;\n  var k = 0;\n\n  for (; k < segLen; k++) {\n    var x = points[idx * 2];\n    var y = points[idx * 2 + 1];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(x, y)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);\n      cpx0 = x;\n      cpy0 = y;\n    } else {\n      var dx = x - prevX;\n      var dy = y - prevY; // Ignore tiny segment.\n\n      if (dx * dx + dy * dy < 0.5) {\n        idx += dir;\n        continue;\n      }\n\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextX = points[nextIdx * 2];\n        var nextY = points[nextIdx * 2 + 1]; // Ignore duplicate point\n\n        while (nextX === x && nextY === y && k < segLen) {\n          k++;\n          nextIdx += dir;\n          idx += dir;\n          nextX = points[nextIdx * 2];\n          nextY = points[nextIdx * 2 + 1];\n          x = points[idx * 2];\n          y = points[idx * 2 + 1];\n          dx = x - prevX;\n          dy = y - prevY;\n        }\n\n        var tmpK = k + 1;\n\n        if (connectNulls) {\n          // Find next point not null\n          while (isPointNull(nextX, nextY) && tmpK < segLen) {\n            tmpK++;\n            nextIdx += dir;\n            nextX = points[nextIdx * 2];\n            nextY = points[nextIdx * 2 + 1];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var vx = 0;\n        var vy = 0;\n        var nextCpx0 = void 0;\n        var nextCpy0 = void 0; // Is last point\n\n        if (tmpK >= segLen || isPointNull(nextX, nextY)) {\n          cpx1 = x;\n          cpy1 = y;\n        } else {\n          vx = nextX - prevX;\n          vy = nextY - prevY;\n          var dx0 = x - prevX;\n          var dx1 = nextX - x;\n          var dy0 = y - prevY;\n          var dy1 = nextY - y;\n          var lenPrevSeg = void 0;\n          var lenNextSeg = void 0;\n\n          if (smoothMonotone === 'x') {\n            lenPrevSeg = Math.abs(dx0);\n            lenNextSeg = Math.abs(dx1);\n            var dir_1 = vx > 0 ? 1 : -1;\n            cpx1 = x - dir_1 * lenPrevSeg * smooth;\n            cpy1 = y;\n            nextCpx0 = x + dir_1 * lenNextSeg * smooth;\n            nextCpy0 = y;\n          } else if (smoothMonotone === 'y') {\n            lenPrevSeg = Math.abs(dy0);\n            lenNextSeg = Math.abs(dy1);\n            var dir_2 = vy > 0 ? 1 : -1;\n            cpx1 = x;\n            cpy1 = y - dir_2 * lenPrevSeg * smooth;\n            nextCpx0 = x;\n            nextCpy0 = y + dir_2 * lenNextSeg * smooth;\n          } else {\n            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1); // Use ratio of seg length\n\n            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n            cpx1 = x - vx * smooth * (1 - ratioNextSeg);\n            cpy1 = y - vy * smooth * (1 - ratioNextSeg); // cp0 of next segment\n\n            nextCpx0 = x + vx * smooth * ratioNextSeg;\n            nextCpy0 = y + vy * smooth * ratioNextSeg; // Smooth constraint between point and next point.\n            // Avoid exceeding extreme after smoothing.\n\n            nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));\n            nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));\n            nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));\n            nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y)); // Reclaculate cp1 based on the adjusted cp0 of next seg.\n\n            vx = nextCpx0 - x;\n            vy = nextCpy0 - y;\n            cpx1 = x - vx * lenPrevSeg / lenNextSeg;\n            cpy1 = y - vy * lenPrevSeg / lenNextSeg; // Smooth constraint between point and prev point.\n            // Avoid exceeding extreme after smoothing.\n\n            cpx1 = mathMin(cpx1, mathMax(prevX, x));\n            cpy1 = mathMin(cpy1, mathMax(prevY, y));\n            cpx1 = mathMax(cpx1, mathMin(prevX, x));\n            cpy1 = mathMax(cpy1, mathMin(prevY, y)); // Adjust next cp0 again.\n\n            vx = x - cpx1;\n            vy = y - cpy1;\n            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;\n            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;\n          }\n        }\n\n        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);\n        cpx0 = nextCpx0;\n        cpy0 = nextCpy0;\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n\n    prevX = x;\n    prevY = y;\n    idx += dir;\n  }\n\n  return k;\n}\n\nvar ECPolylineShape =\n/** @class */\nfunction () {\n  function ECPolylineShape() {\n    this.smooth = 0;\n    this.smoothConstraint = true;\n  }\n\n  return ECPolylineShape;\n}();\n\nvar poly_ECPolyline =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(ECPolyline, _super);\n\n  function ECPolyline(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polyline';\n    return _this;\n  }\n\n  ECPolyline.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n\n  ECPolyline.prototype.getDefaultShape = function () {\n    return new ECPolylineShape();\n  };\n\n  ECPolyline.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length / 2; // const result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  };\n\n  ECPolyline.prototype.getPointOn = function (xOrY, dim) {\n    if (!this.path) {\n      this.createPathProxy();\n      this.buildPath(this.path, this.shape);\n    }\n\n    var path = this.path;\n    var data = path.data;\n    var CMD = PathProxy[\"a\" /* default */].CMD;\n    var x0;\n    var y0;\n    var isDimX = dim === 'x';\n    var roots = [];\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n      var x = void 0;\n      var y = void 0;\n      var x2 = void 0;\n      var y2 = void 0;\n      var x3 = void 0;\n      var y3 = void 0;\n      var t = void 0;\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = data[i++];\n          y0 = data[i++];\n          break;\n\n        case CMD.L:\n          x = data[i++];\n          y = data[i++];\n          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);\n\n          if (t <= 1 && t >= 0) {\n            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;\n            return isDimX ? [xOrY, val] : [val, xOrY];\n          }\n\n          x0 = x;\n          y0 = y;\n          break;\n\n        case CMD.C:\n          x = data[i++];\n          y = data[i++];\n          x2 = data[i++];\n          y2 = data[i++];\n          x3 = data[i++];\n          y3 = data[i++];\n          var nRoot = isDimX ? Object(curve[\"f\" /* cubicRootAt */])(x0, x, x2, x3, xOrY, roots) : Object(curve[\"f\" /* cubicRootAt */])(y0, y, y2, y3, xOrY, roots);\n\n          if (nRoot > 0) {\n            for (var i_1 = 0; i_1 < nRoot; i_1++) {\n              var t_1 = roots[i_1];\n\n              if (t_1 <= 1 && t_1 >= 0) {\n                var val = isDimX ? Object(curve[\"a\" /* cubicAt */])(y0, y, y2, y3, t_1) : Object(curve[\"a\" /* cubicAt */])(x0, x, x2, x3, t_1);\n                return isDimX ? [xOrY, val] : [val, xOrY];\n              }\n            }\n          }\n\n          x0 = x3;\n          y0 = y3;\n          break;\n      }\n    }\n  };\n\n  return ECPolyline;\n}(Path[\"b\" /* default */]);\n\n\n\nvar poly_ECPolygonShape =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(ECPolygonShape, _super);\n\n  function ECPolygonShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return ECPolygonShape;\n}(ECPolylineShape);\n\nvar poly_ECPolygon =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(ECPolygon, _super);\n\n  function ECPolygon(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polygon';\n    return _this;\n  }\n\n  ECPolygon.prototype.getDefaultShape = function () {\n    return new poly_ECPolygonShape();\n  };\n\n  ECPolygon.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length / 2;\n    var smoothMonotone = shape.smoothMonotone;\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  };\n\n  return ECPolygon;\n}(Path[\"b\" /* default */]);\n\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Chart.js\nvar Chart = __webpack_require__(\"e887\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js\nvar createClipPathFromCoordSys = __webpack_require__(\"b0af\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/CoordinateSystem.js\nvar CoordinateSystem = __webpack_require__(\"5426\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/format.js\nvar format = __webpack_require__(\"eda2\");\n\n// EXTERNAL MODULE: ./node_modules/zrender/lib/tool/color.js\nvar tool_color = __webpack_require__(\"41ef\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/chart/line/LineView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n // FIXME step not support polar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    if (points1[i] !== points2[i]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction bboxFromPoints(points) {\n  var minX = Infinity;\n  var minY = Infinity;\n  var maxX = -Infinity;\n  var maxY = -Infinity;\n\n  for (var i = 0; i < points.length;) {\n    var x = points[i++];\n    var y = points[i++];\n\n    if (!isNaN(x)) {\n      minX = Math.min(x, minX);\n      maxX = Math.max(x, maxX);\n    }\n\n    if (!isNaN(y)) {\n      minY = Math.min(y, minY);\n      maxY = Math.max(y, maxY);\n    }\n  }\n\n  return [[minX, minY], [maxX, maxY]];\n}\n\nfunction getBoundingDiff(points1, points2) {\n  var _a = bboxFromPoints(points1),\n      min1 = _a[0],\n      max1 = _a[1];\n\n  var _b = bboxFromPoints(points2),\n      min2 = _b[0],\n      max2 = _b[1]; // Get a max value from each corner of two boundings.\n\n\n  return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]));\n}\n\nfunction getSmooth(smooth) {\n  return util[\"y\" /* isNumber */](smooth) ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var len = data.count();\n  var points = Object(vendor[\"a\" /* createFloat32Array */])(len * 2);\n\n  for (var idx = 0; idx < len; idx++) {\n    var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);\n    points[idx * 2] = pt[0];\n    points[idx * 2 + 1] = pt[1];\n  }\n\n  return points;\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt, connectNulls) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n  var i = 0;\n  var stepPt = [];\n  var pt = [];\n  var nextPt = [];\n  var filteredPoints = [];\n\n  if (connectNulls) {\n    for (i = 0; i < points.length; i += 2) {\n      if (!isNaN(points[i]) && !isNaN(points[i + 1])) {\n        filteredPoints.push(points[i], points[i + 1]);\n      }\n    }\n\n    points = filteredPoints;\n  }\n\n  for (i = 0; i < points.length - 2; i += 2) {\n    nextPt[0] = points[i + 2];\n    nextPt[1] = points[i + 3];\n    pt[0] = points[i];\n    pt[1] = points[i + 1];\n    stepPoints.push(pt[0], pt[1]);\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPoints.push(stepPt[0], stepPt[1]);\n        break;\n\n      case 'middle':\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt[0], stepPt[1]);\n        stepPoints.push(stepPt2[0], stepPt2[1]);\n        break;\n\n      default:\n        // default is start\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt[0], stepPt[1]);\n    }\n  } // Last points\n\n\n  stepPoints.push(points[i++], points[i++]);\n  return stepPoints;\n}\n/**\n * Clip color stops to edge. Avoid creating too large gradients.\n * Which may lead to blurry when GPU acceleration is enabled. See #15680\n *\n * The stops has been sorted from small to large.\n */\n\n\nfunction clipColorStops(colorStops, maxSize) {\n  var newColorStops = [];\n  var len = colorStops.length; // coord will always < 0 in prevOutOfRangeColorStop.\n\n  var prevOutOfRangeColorStop;\n  var prevInRangeColorStop;\n\n  function lerpStop(stop0, stop1, clippedCoord) {\n    var coord0 = stop0.coord;\n    var p = (clippedCoord - coord0) / (stop1.coord - coord0);\n    var color = Object(tool_color[\"a\" /* lerp */])(p, [stop0.color, stop1.color]);\n    return {\n      coord: clippedCoord,\n      color: color\n    };\n  }\n\n  for (var i = 0; i < len; i++) {\n    var stop_1 = colorStops[i];\n    var coord = stop_1.coord;\n\n    if (coord < 0) {\n      prevOutOfRangeColorStop = stop_1;\n    } else if (coord > maxSize) {\n      if (prevInRangeColorStop) {\n        newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));\n      } else if (prevOutOfRangeColorStop) {\n        // If there are two stops and coord range is between these two stops\n        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));\n      } // All following stop will be out of range. So just ignore them.\n\n\n      break;\n    } else {\n      if (prevOutOfRangeColorStop) {\n        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0)); // Reset\n\n        prevOutOfRangeColorStop = null;\n      }\n\n      newColorStops.push(stop_1);\n      prevInRangeColorStop = stop_1;\n    }\n  }\n\n  return newColorStops;\n}\n\nfunction getVisualGradient(data, coordSys, api) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    if (false) {}\n\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimInfo = data.getDimensionInfo(visualMetaList[i].dimension);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    if (false) {}\n\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoord mapping may not be linear, but must be monotonic.\n\n  var colorStops = util[\"F\" /* map */](visualMeta.stops, function (stop) {\n    // offset will be calculated later.\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var colorStopsInRange = clipColorStops(colorStops, coordDim === 'x' ? api.getWidth() : api.getHeight());\n  var inRangeStopLen = colorStopsInRange.length;\n\n  if (!inRangeStopLen && stopLen) {\n    // All stops are out of range. All will be the same color.\n    return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStopsInRange[0].coord - tinyExtent;\n  var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  util[\"k\" /* each */](colorStopsInRange, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStopsInRange.push({\n    // NOTE: inRangeStopLen may still be 0 if stoplen is zero.\n    offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStopsInRange.unshift({\n    offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  });\n  var gradient = new LinearGradient[\"a\" /* default */](0, 0, 0, 0, colorStopsInRange, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nfunction getIsIgnoreFunc(seriesModel, data, coordSys) {\n  var showAllSymbol = seriesModel.get('showAllSymbol');\n  var isAuto = showAllSymbol === 'auto';\n\n  if (showAllSymbol && !isAuto) {\n    return;\n  }\n\n  var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n  if (!categoryAxis) {\n    return;\n  } // Note that category label interval strategy might bring some weird effect\n  // in some scenario: users may wonder why some of the symbols are not\n  // displayed. So we show all symbols as possible as we can.\n\n\n  if (isAuto // Simplify the logic, do not determine label overlap here.\n  && canShowAllSymbolForCategory(categoryAxis, data)) {\n    return;\n  } // Otherwise follow the label interval strategy on category axis.\n\n\n  var categoryDataDim = data.mapDimension(categoryAxis.dim);\n  var labelMap = {};\n  util[\"k\" /* each */](categoryAxis.getViewLabels(), function (labelItem) {\n    var ordinalNumber = categoryAxis.scale.getRawOrdinalNumber(labelItem.tickValue);\n    labelMap[ordinalNumber] = 1;\n  });\n  return function (dataIndex) {\n    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));\n  };\n}\n\nfunction canShowAllSymbolForCategory(categoryAxis, data) {\n  // In mose cases, line is monotonous on category axis, and the label size\n  // is close with each other. So we check the symbol size and some of the\n  // label size alone with the category axis to estimate whether all symbol\n  // can be shown without overlap.\n  var axisExtent = categoryAxis.getExtent();\n  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();\n  isNaN(availSize) && (availSize = 0); // 0/0 is NaN.\n  // Sampling some points, max 5.\n\n  var dataLen = data.count();\n  var step = Math.max(1, Math.round(dataLen / 5));\n\n  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {\n    if (helper_Symbol.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.\n    )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number\n    * 1.5 > availSize) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction LineView_isPointNull(x, y) {\n  return isNaN(x) || isNaN(y);\n}\n\nfunction getLastIndexNotNull(points) {\n  var len = points.length / 2;\n\n  for (; len > 0; len--) {\n    if (!LineView_isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n      break;\n    }\n  }\n\n  return len - 1;\n}\n\nfunction getPointAtIndex(points, idx) {\n  return [points[idx * 2], points[idx * 2 + 1]];\n}\n\nfunction getIndexRange(points, xOrY, dim) {\n  var len = points.length / 2;\n  var dimIdx = dim === 'x' ? 0 : 1;\n  var a;\n  var b;\n  var prevIndex = 0;\n  var nextIndex = -1;\n\n  for (var i = 0; i < len; i++) {\n    b = points[i * 2 + dimIdx];\n\n    if (isNaN(b) || isNaN(points[i * 2 + 1 - dimIdx])) {\n      continue;\n    }\n\n    if (i === 0) {\n      a = b;\n      continue;\n    }\n\n    if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {\n      nextIndex = i;\n      break;\n    }\n\n    prevIndex = i;\n    a = b;\n  }\n\n  return {\n    range: [prevIndex, nextIndex],\n    t: (xOrY - a) / (b - a)\n  };\n}\n\nfunction anyStateShowEndLabel(seriesModel) {\n  if (seriesModel.get(['endLabel', 'show'])) {\n    return true;\n  }\n\n  for (var i = 0; i < states[\"g\" /* SPECIAL_STATES */].length; i++) {\n    if (seriesModel.get([states[\"g\" /* SPECIAL_STATES */][i], 'endLabel', 'show'])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {\n  if (Object(CoordinateSystem[\"a\" /* isCoordinateSystemType */])(coordSys, 'cartesian2d')) {\n    var endLabelModel_1 = seriesModel.getModel('endLabel');\n    var valueAnimation_1 = endLabelModel_1.get('valueAnimation');\n    var data_1 = seriesModel.getData();\n    var labelAnimationRecord_1 = {\n      lastFrameIndex: 0\n    };\n    var during = anyStateShowEndLabel(seriesModel) ? function (percent, clipRect) {\n      lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);\n    } : null;\n    var isHorizontal = coordSys.getBaseAxis().isHorizontal();\n    var clipPath = Object(createClipPathFromCoordSys[\"b\" /* createGridClipPath */])(coordSys, hasAnimation, seriesModel, function () {\n      var endLabel = lineView._endLabel;\n\n      if (endLabel && hasAnimation) {\n        if (labelAnimationRecord_1.originalX != null) {\n          endLabel.attr({\n            x: labelAnimationRecord_1.originalX,\n            y: labelAnimationRecord_1.originalY\n          });\n        }\n      }\n    }, during); // Expand clip shape to avoid clipping when line value exceeds axis\n\n    if (!seriesModel.get('clip', true)) {\n      var rectShape = clipPath.shape;\n      var expandSize = Math.max(rectShape.width, rectShape.height);\n\n      if (isHorizontal) {\n        rectShape.y -= expandSize;\n        rectShape.height += expandSize * 2;\n      } else {\n        rectShape.x -= expandSize;\n        rectShape.width += expandSize * 2;\n      }\n    } // Set to the final frame. To make sure label layout is right.\n\n\n    if (during) {\n      during(1, clipPath);\n    }\n\n    return clipPath;\n  } else {\n    if (false) {}\n\n    return Object(createClipPathFromCoordSys[\"c\" /* createPolarClipPath */])(coordSys, hasAnimation, seriesModel);\n  }\n}\n\nfunction getEndLabelStateSpecified(endLabelModel, coordSys) {\n  var baseAxis = coordSys.getBaseAxis();\n  var isHorizontal = baseAxis.isHorizontal();\n  var isBaseInversed = baseAxis.inverse;\n  var align = isHorizontal ? isBaseInversed ? 'right' : 'left' : 'center';\n  var verticalAlign = isHorizontal ? 'middle' : isBaseInversed ? 'top' : 'bottom';\n  return {\n    normal: {\n      align: endLabelModel.get('align') || align,\n      verticalAlign: endLabelModel.get('verticalAlign') || verticalAlign\n    }\n  };\n}\n\nvar LineView_LineView =\n/** @class */\nfunction (_super) {\n  Object(tslib_es6[\"a\" /* __extends */])(LineView, _super);\n\n  function LineView() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  LineView.prototype.init = function () {\n    var lineGroup = new Group[\"a\" /* default */]();\n    var symbolDraw = new helper_SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  };\n\n  LineView.prototype.render = function (seriesModel, ecModel, api) {\n    var _this = this;\n\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.getLayout('points') || [];\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n    var connectNulls = seriesModel.get('connectNulls');\n    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar ? seriesModel.get('step') : false;\n    var clipShapeForSymbol;\n\n    if (coordSys && coordSys.getArea && seriesModel.get('clip', true)) {\n      clipShapeForSymbol = coordSys.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.\n      // See #7913 and `test/dataZoom-clip.html`.\n\n      if (clipShapeForSymbol.width != null) {\n        clipShapeForSymbol.x -= 0.1;\n        clipShapeForSymbol.y -= 0.1;\n        clipShapeForSymbol.width += 0.2;\n        clipShapeForSymbol.height += 0.2;\n      } else if (clipShapeForSymbol.r0) {\n        clipShapeForSymbol.r0 -= 0.5;\n        clipShapeForSymbol.r += 0.5;\n      }\n    }\n\n    this._clipShapeForSymbol = clipShapeForSymbol;\n    var visualColor = getVisualGradient(data, coordSys, api) || data.getVisual('style')[data.getVisual('drawType')]; // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: clipShapeForSymbol,\n        disableAnimation: true,\n        getSymbolPoint: function (idx) {\n          return [points[idx * 2], points[idx * 2 + 1]];\n        }\n      });\n      hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step, connectNulls);\n\n        if (stackedOnPoints) {\n          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);\n        }\n      }\n\n      polyline = this._newPolyline(points);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints);\n      } // NOTE: Must update _endLabel before setClipPath.\n\n\n      if (!isCoordSysPolar) {\n        this._initOrUpdateEndLabel(seriesModel, coordSys, Object(format[\"b\" /* convertToColorString */])(visualColor));\n      }\n\n      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      } // NOTE: Must update _endLabel before setClipPath.\n\n\n      if (!isCoordSysPolar) {\n        this._initOrUpdateEndLabel(seriesModel, coordSys, Object(format[\"b\" /* convertToColorString */])(visualColor));\n      } // Update clipPath\n\n\n      var oldClipPath = lineGroup.getClipPath();\n\n      if (oldClipPath) {\n        var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);\n        basicTrasition[\"a\" /* initProps */](oldClipPath, {\n          shape: newClipPath.shape\n        }, seriesModel);\n      } else {\n        lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));\n      } // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: clipShapeForSymbol,\n        disableAnimation: true,\n        getSymbolPoint: function (idx) {\n          return [points[idx * 2], points[idx * 2 + 1]];\n        }\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step, connectNulls);\n\n            if (stackedOnPoints) {\n              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);\n            }\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var emphasisModel = seriesModel.getModel('emphasis');\n    var focus = emphasisModel.get('focus');\n    var blurScope = emphasisModel.get('blurScope');\n    var emphasisDisabled = emphasisModel.get('disabled');\n    polyline.useStyle(util[\"i\" /* defaults */]( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    Object(states[\"D\" /* setStatesStylesFromModel */])(polyline, seriesModel, 'lineStyle');\n\n    if (polyline.style.lineWidth > 0 && seriesModel.get(['emphasis', 'lineStyle', 'width']) === 'bolder') {\n      var emphasisLineStyle = polyline.getState('emphasis').style;\n      emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;\n    } // Needs seriesIndex for focus\n\n\n    Object(innerStore[\"a\" /* getECData */])(polyline).seriesIndex = seriesModel.seriesIndex;\n    Object(states[\"E\" /* toggleHoverEmphasis */])(polyline, focus, blurScope, emphasisDisabled);\n    var smooth = getSmooth(seriesModel.get('smooth'));\n    var smoothMonotone = seriesModel.get('smoothMonotone');\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: smoothMonotone,\n      connectNulls: connectNulls\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(util[\"i\" /* defaults */](areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel',\n        decal: data.getVisual('style').decal\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: smoothMonotone,\n        connectNulls: connectNulls\n      });\n      Object(states[\"D\" /* setStatesStylesFromModel */])(polygon, seriesModel, 'areaStyle'); // Needs seriesIndex for focus\n\n      Object(innerStore[\"a\" /* getECData */])(polygon).seriesIndex = seriesModel.seriesIndex;\n      Object(states[\"E\" /* toggleHoverEmphasis */])(polygon, focus, blurScope, emphasisDisabled);\n    }\n\n    var changePolyState = function (toState) {\n      _this._changePolyState(toState);\n    };\n\n    data.eachItemGraphicEl(function (el) {\n      // Switch polyline / polygon state if element changed its state.\n      el && (el.onHoverStateChange = changePolyState);\n    });\n    this._polyline.onHoverStateChange = changePolyState;\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n\n    if (seriesModel.get('triggerLineEvent')) {\n      this.packEventData(seriesModel, polyline);\n      polygon && this.packEventData(seriesModel, polygon);\n    }\n  };\n\n  LineView.prototype.packEventData = function (seriesModel, el) {\n    Object(innerStore[\"a\" /* getECData */])(el).eventData = {\n      componentType: 'series',\n      componentSubType: 'line',\n      componentIndex: seriesModel.componentIndex,\n      seriesIndex: seriesModel.seriesIndex,\n      seriesName: seriesModel.name,\n      seriesType: 'line'\n    };\n  };\n\n  LineView.prototype.highlight = function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = model[\"s\" /* queryDataIndex */](data, payload);\n\n    this._changePolyState('emphasis');\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var points = data.getLayout('points');\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var x = points[dataIndex * 2];\n        var y = points[dataIndex * 2 + 1];\n\n        if (isNaN(x) || isNaN(y)) {\n          // Null data\n          return;\n        } // fix #11360: should't draw symbol outside clipShapeForSymbol\n\n\n        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {\n          return;\n        }\n\n        var zlevel = seriesModel.get('zlevel');\n        var z = seriesModel.get('z');\n        symbol = new helper_Symbol(data, dataIndex);\n        symbol.x = x;\n        symbol.y = y;\n        symbol.setZ(zlevel, z); // ensure label text of the temporary symbol is in front of line and area polygon\n\n        var symbolLabel = symbol.getSymbolPath().getTextContent();\n\n        if (symbolLabel) {\n          symbolLabel.zlevel = zlevel;\n          symbolLabel.z = z;\n          symbolLabel.z2 = this._polyline.z2 + 1;\n        }\n\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      Chart[\"a\" /* default */].prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  };\n\n  LineView.prototype.downplay = function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = model[\"s\" /* queryDataIndex */](data, payload);\n\n    this._changePolyState('normal');\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      Chart[\"a\" /* default */].prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  };\n\n  LineView.prototype._changePolyState = function (toState) {\n    var polygon = this._polygon;\n    Object(states[\"C\" /* setStatesFlag */])(this._polyline, toState);\n    polygon && Object(states[\"C\" /* setStatesFlag */])(polygon, toState);\n  };\n\n  LineView.prototype._newPolyline = function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new poly_ECPolyline({\n      shape: {\n        points: points\n      },\n      segmentIgnoreThreshold: 2,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  };\n\n  LineView.prototype._newPolygon = function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new poly_ECPolygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      segmentIgnoreThreshold: 2\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  };\n\n  LineView.prototype._initSymbolLabelAnimation = function (data, coordSys, clipShape) {\n    var isHorizontalOrRadial;\n    var isCoordSysPolar;\n    var baseAxis = coordSys.getBaseAxis();\n    var isAxisInverse = baseAxis.inverse;\n\n    if (coordSys.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n      isCoordSysPolar = false;\n    } else if (coordSys.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n      isCoordSysPolar = true;\n    }\n\n    var seriesModel = data.hostModel;\n    var seriesDuration = seriesModel.get('animationDuration');\n\n    if (util[\"v\" /* isFunction */](seriesDuration)) {\n      seriesDuration = seriesDuration(null);\n    }\n\n    var seriesDalay = seriesModel.get('animationDelay') || 0;\n    var seriesDalayValue = util[\"v\" /* isFunction */](seriesDalay) ? seriesDalay(null) : seriesDalay;\n    data.eachItemGraphicEl(function (symbol, idx) {\n      var el = symbol;\n\n      if (el) {\n        var point = [symbol.x, symbol.y];\n        var start = void 0;\n        var end = void 0;\n        var current = void 0;\n\n        if (clipShape) {\n          if (isCoordSysPolar) {\n            var polarClip = clipShape;\n            var coord = coordSys.pointToCoord(point);\n\n            if (isHorizontalOrRadial) {\n              start = polarClip.startAngle;\n              end = polarClip.endAngle;\n              current = -coord[1] / 180 * Math.PI;\n            } else {\n              start = polarClip.r0;\n              end = polarClip.r;\n              current = coord[0];\n            }\n          } else {\n            var gridClip = clipShape;\n\n            if (isHorizontalOrRadial) {\n              start = gridClip.x;\n              end = gridClip.x + gridClip.width;\n              current = symbol.x;\n            } else {\n              start = gridClip.y + gridClip.height;\n              end = gridClip.y;\n              current = symbol.y;\n            }\n          }\n        }\n\n        var ratio = end === start ? 0 : (current - start) / (end - start);\n\n        if (isAxisInverse) {\n          ratio = 1 - ratio;\n        }\n\n        var delay = util[\"v\" /* isFunction */](seriesDalay) ? seriesDalay(idx) : seriesDuration * ratio + seriesDalayValue;\n        var symbolPath = el.getSymbolPath();\n        var text = symbolPath.getTextContent();\n        el.attr({\n          scaleX: 0,\n          scaleY: 0\n        });\n        el.animateTo({\n          scaleX: 1,\n          scaleY: 1\n        }, {\n          duration: 200,\n          setToFinal: true,\n          delay: delay\n        });\n\n        if (text) {\n          text.animateFrom({\n            style: {\n              opacity: 0\n            }\n          }, {\n            duration: 300,\n            delay: delay\n          });\n        }\n\n        symbolPath.disableLabelAnimation = true;\n      }\n    });\n  };\n\n  LineView.prototype._initOrUpdateEndLabel = function (seriesModel, coordSys, inheritColor) {\n    var endLabelModel = seriesModel.getModel('endLabel');\n\n    if (anyStateShowEndLabel(seriesModel)) {\n      var data_2 = seriesModel.getData();\n      var polyline = this._polyline; // series may be filtered.\n\n      var points = data_2.getLayout('points');\n\n      if (!points) {\n        polyline.removeTextContent();\n        this._endLabel = null;\n        return;\n      }\n\n      var endLabel = this._endLabel;\n\n      if (!endLabel) {\n        endLabel = this._endLabel = new Text[\"a\" /* default */]({\n          z2: 200 // should be higher than item symbol\n\n        });\n        endLabel.ignoreClip = true;\n        polyline.setTextContent(this._endLabel);\n        polyline.disableLabelAnimation = true;\n      } // Find last non-NaN data to display data\n\n\n      var dataIndex = getLastIndexNotNull(points);\n\n      if (dataIndex >= 0) {\n        Object(labelStyle[\"e\" /* setLabelStyle */])(polyline, Object(labelStyle[\"c\" /* getLabelStatesModels */])(seriesModel, 'endLabel'), {\n          inheritColor: inheritColor,\n          labelFetcher: seriesModel,\n          labelDataIndex: dataIndex,\n          defaultText: function (dataIndex, opt, interpolatedValue) {\n            return interpolatedValue != null ? Object(labelHelper[\"a\" /* getDefaultInterpolatedLabel */])(data_2, interpolatedValue) : Object(labelHelper[\"b\" /* getDefaultLabel */])(data_2, dataIndex);\n          },\n          enableTextSetter: true\n        }, getEndLabelStateSpecified(endLabelModel, coordSys));\n        polyline.textConfig.position = null;\n      }\n    } else if (this._endLabel) {\n      this._polyline.removeTextContent();\n\n      this._endLabel = null;\n    }\n  };\n\n  LineView.prototype._endLabelOnDuring = function (percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {\n    var endLabel = this._endLabel;\n    var polyline = this._polyline;\n\n    if (endLabel) {\n      // NOTE: Don't remove percent < 1. percent === 1 means the first frame during render.\n      // The label is not prepared at this time.\n      if (percent < 1 && animationRecord.originalX == null) {\n        animationRecord.originalX = endLabel.x;\n        animationRecord.originalY = endLabel.y;\n      }\n\n      var points = data.getLayout('points');\n      var seriesModel = data.hostModel;\n      var connectNulls = seriesModel.get('connectNulls');\n      var precision = endLabelModel.get('precision');\n      var distance = endLabelModel.get('distance') || 0;\n      var baseAxis = coordSys.getBaseAxis();\n      var isHorizontal = baseAxis.isHorizontal();\n      var isBaseInversed = baseAxis.inverse;\n      var clipShape = clipRect.shape;\n      var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;\n      var distanceX = (isHorizontal ? distance : 0) * (isBaseInversed ? -1 : 1);\n      var distanceY = (isHorizontal ? 0 : -distance) * (isBaseInversed ? -1 : 1);\n      var dim = isHorizontal ? 'x' : 'y';\n      var dataIndexRange = getIndexRange(points, xOrY, dim);\n      var indices = dataIndexRange.range;\n      var diff = indices[1] - indices[0];\n      var value = void 0;\n\n      if (diff >= 1) {\n        // diff > 1 && connectNulls, which is on the null data.\n        if (diff > 1 && !connectNulls) {\n          var pt = getPointAtIndex(points, indices[0]);\n          endLabel.attr({\n            x: pt[0] + distanceX,\n            y: pt[1] + distanceY\n          });\n          valueAnimation && (value = seriesModel.getRawValue(indices[0]));\n        } else {\n          var pt = polyline.getPointOn(xOrY, dim);\n          pt && endLabel.attr({\n            x: pt[0] + distanceX,\n            y: pt[1] + distanceY\n          });\n          var startValue = seriesModel.getRawValue(indices[0]);\n          var endValue = seriesModel.getRawValue(indices[1]);\n          valueAnimation && (value = model[\"i\" /* interpolateRawValues */](data, precision, startValue, endValue, dataIndexRange.t));\n        }\n\n        animationRecord.lastFrameIndex = indices[0];\n      } else {\n        // If diff <= 0, which is the range is not found(Include NaN)\n        // Choose the first point or last point.\n        var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;\n        var pt = getPointAtIndex(points, idx);\n        valueAnimation && (value = seriesModel.getRawValue(idx));\n        endLabel.attr({\n          x: pt[0] + distanceX,\n          y: pt[1] + distanceY\n        });\n      }\n\n      if (valueAnimation) {\n        Object(labelStyle[\"d\" /* labelInner */])(endLabel).setLabelText(value);\n      }\n    }\n  };\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n\n\n  LineView.prototype._doUpdateAnimation = function (data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step, connectNulls);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step, connectNulls);\n      next = turnPointsIntoStep(diff.next, coordSys, step, connectNulls);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step, connectNulls);\n    } // Don't apply animation if diff is large.\n    // For better result and avoid memory explosion problems like\n    // https://github.com/apache/incubator-echarts/issues/12229\n\n\n    if (getBoundingDiff(current, next) > 3000 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3000) {\n      polyline.stopAnimation();\n      polyline.setShape({\n        points: next\n      });\n\n      if (polygon) {\n        polygon.stopAnimation();\n        polygon.setShape({\n          points: next,\n          stackedOnPoints: stackedOnNext\n        });\n      }\n\n      return;\n    }\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    var target = {\n      shape: {\n        points: next\n      }\n    }; // Also animate the original points.\n    // If points reference is changed when turning into step line.\n\n    if (diff.current !== current) {\n      target.shape.__points = diff.next;\n    } // Stop previous animation.\n\n\n    polyline.stopAnimation();\n    basicTrasition[\"f\" /* updateProps */](polyline, target, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        // Reuse the points with polyline.\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      polygon.stopAnimation();\n      basicTrasition[\"f\" /* updateProps */](polygon, {\n        shape: {\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel); // If use attr directly in updateProps.\n\n      if (polyline.shape.points !== polygon.shape.points) {\n        polygon.shape.points = polyline.shape.points;\n      }\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        polygon && polygon.dirtyShape();\n        var points = polyline.shape.__points;\n\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          var offset = updatedDataInfo[i].ptIdx * 2;\n          el.x = points[offset];\n          el.y = points[offset + 1];\n          el.markRedraw();\n        }\n      });\n    }\n  };\n\n  LineView.prototype.remove = function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;\n  };\n\n  LineView.type = 'line';\n  return LineView;\n}(Chart[\"a\" /* default */]);\n\n/* harmony default export */ var line_LineView = (LineView_LineView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/chart/helper/createRenderPlanner.js\nvar createRenderPlanner = __webpack_require__(\"cccd\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/layout/points.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n\nfunction pointsLayout(seriesType, forceStoreInTypedArray) {\n  return {\n    seriesType: seriesType,\n    plan: Object(createRenderPlanner[\"a\" /* default */])(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = Object(util[\"F\" /* map */])(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n      if (Object(dataStackHelper[\"c\" /* isDimensionStacked */])(data, dims[0])) {\n        dims[0] = stackResultDim;\n      }\n\n      if (Object(dataStackHelper[\"c\" /* isDimensionStacked */])(data, dims[1])) {\n        dims[1] = stackResultDim;\n      }\n\n      var store = data.getStore();\n      var dimIdx0 = data.getDimensionIndex(dims[0]);\n      var dimIdx1 = data.getDimensionIndex(dims[1]);\n      return dimLen && {\n        progress: function (params, data) {\n          var segCount = params.end - params.start;\n          var points = useTypedArray && Object(vendor[\"a\" /* createFloat32Array */])(segCount * dimLen);\n          var tmpIn = [];\n          var tmpOut = [];\n\n          for (var i = params.start, offset = 0; i < params.end; i++) {\n            var point = void 0;\n\n            if (dimLen === 1) {\n              var x = store.get(dimIdx0, i); // NOTE: Make sure the second parameter is null to use default strategy.\n\n              point = coordSys.dataToPoint(x, null, tmpOut);\n            } else {\n              tmpIn[0] = store.get(dimIdx0, i);\n              tmpIn[1] = store.get(dimIdx1, i); // Let coordinate system to handle the NaN data.\n\n              point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n            }\n\n            if (useTypedArray) {\n              points[offset++] = point[0];\n              points[offset++] = point[1];\n            } else {\n              data.setItemLayout(i, point.slice());\n            }\n          }\n\n          useTypedArray && data.setLayout('points', points);\n        }\n      };\n    }\n  };\n}\n;\n// EXTERNAL MODULE: ./node_modules/echarts/lib/processor/dataSample.js\nvar dataSample = __webpack_require__(\"fdde\");\n\n// CONCATENATED MODULE: ./node_modules/echarts/lib/chart/line/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n // In case developer forget to include grid component\n\n\n\nfunction install(registers) {\n  registers.registerChartView(line_LineView);\n  registers.registerSeriesModel(LineSeries);\n  registers.registerLayout(pointsLayout('line', true));\n  registers.registerVisual({\n    seriesType: 'line',\n    reset: function (seriesModel) {\n      var data = seriesModel.getData(); // Visual coding for legend\n\n      var lineStyle = seriesModel.getModel('lineStyle').getLineStyle();\n\n      if (lineStyle && !lineStyle.stroke) {\n        // Fill in visual should be palette color if\n        // has color callback\n        lineStyle.stroke = data.getVisual('style').fill;\n      }\n\n      data.setVisual('legendLineStyle', lineStyle);\n    }\n  }); // Down sample after filter\n\n  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, Object(dataSample[\"a\" /* default */])('line'));\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/title/install.js\nvar title_install = __webpack_require__(\"9394\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/install.js + 5 modules\nvar tooltip_install = __webpack_require__(\"2da7\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/legend/install.js + 9 modules\nvar legend_install = __webpack_require__(\"ff32\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/dataZoom/install.js + 8 modules\nvar dataZoom_install = __webpack_require__(\"104d\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/grid/install.js + 16 modules\nvar grid_install = __webpack_require__(\"4b2a\");\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/toolbox/install.js + 16 modules\nvar toolbox_install = __webpack_require__(\"3094\");\n\n// EXTERNAL MODULE: ./node_modules/vue-echarts/dist/index.esm.min.js + 3 modules\nvar index_esm_min = __webpack_require__(\"5c7f\");\n\n// EXTERNAL MODULE: ./src/components/ECharts/mixins/ChartToolMixins.js\nvar ChartToolMixins = __webpack_require__(\"e0d4\");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/@vue/cli-service/node_modules/vue-loader/lib??vue-loader-options!./src/components/ECharts/Line.vue?vue&type=script&lang=js&\n\n\n\n\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\nObject(extension[\"a\" /* use */])([installCanvasRenderer[\"a\" /* install */], install, title_install[\"a\" /* install */], tooltip_install[\"a\" /* install */], legend_install[\"a\" /* install */], dataZoom_install[\"a\" /* install */], grid_install[\"a\" /* install */], toolbox_install[\"a\" /* install */]]);\n/* harmony default export */ var Linevue_type_script_lang_js_ = ({\n  name: 'ELine',\n  mixins: [ChartToolMixins[\"a\" /* ChartToolMixins */]],\n  props: {\n    color: {\n      type: Array,\n      default: function _default() {\n        return ['#EF4136', '#FFBD00', '#4484CF', '#946EDB', '#8D7B7B', '#54C7B0', '#F47920', '#194283', '#59C754'];\n      }\n    },\n    height: {\n      type: [String, Number],\n      default: '100%'\n    },\n    // [\n    //   {\n    //     name: 'series',\n    //     type: 'line',\n    //     data: []\n    //   }\n    // ]\n    datas: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    }\n  },\n  components: {\n    'v-chart': index_esm_min[\"a\" /* default */]\n  },\n  watch: {\n    datas: {\n      handler: function handler(newName, oldName) {\n        this.initData(newName.concat());\n      },\n      immediate: true,\n      deep: true\n    }\n  },\n  mounted: function mounted() {\n    if (this.datas.length > 0) {\n      this.initData(this.datas);\n    }\n  },\n  data: function data() {\n    return {\n      options: null\n    };\n  },\n  methods: {\n    initData: function initData(datas) {\n      var _this = this;\n\n      var seriesData = datas;\n\n      if (!seriesData[0] || !seriesData[0].data) {\n        return;\n      }\n\n      var xAxis = seriesData[0].data.map(function (item) {\n        return item.date;\n      });\n      var that = this;\n      var toolbox = {\n        feature: {\n          saveAsImage: {}\n        }\n      };\n      var dataZoom = null;\n      var bottom = '30';\n\n      if (xAxis.length > 27) {\n        toolbox.feature = {\n          dataZoom: {\n            yAxisIndex: 'none'\n          },\n          restore: {},\n          saveAsImage: {}\n        };\n        dataZoom = [// {\n        //   type: 'inside',\n        //   start: 0,\n        //   end: 10\n        // },\n        {\n          start: 0,\n          end: 30\n        }];\n        bottom = '100';\n      }\n\n      this.options = {\n        color: this.color,\n        grid: {\n          left: '50',\n          bottom: bottom,\n          top: '20',\n          right: '50'\n        },\n        xAxis: {\n          type: 'category',\n          boundaryGap: false,\n          data: xAxis\n        },\n        yAxis: {\n          type: 'value',\n          boundaryGap: [0, '100%']\n        },\n        tooltip: {\n          trigger: 'axis',\n          backgroundColor: '#f2f2f2',\n          borderColor: '#dfdfdf',\n          borderWidth: 1,\n          textStyle: {\n            color: '#333',\n            fontFamily: 'Open Sans'\n          },\n          extraCssText: 'text-align:left;',\n          formatter: function formatter(params) {\n            if (params.length < 2) {\n              return '<p><span style=\"color:#999;\">' + params[0].name + '</span></p><p><b>' + that.formatNum(params[0].value, 0) + '</b></p>';\n            } else {\n              return '<p><span style=\"color:#999;\">' + params[0].name + '</span></p><p><b>' + that.formatNum(params[0].value, 0) + '</b> vs <b>' + that.formatNum(params[1].value, 0) + '</b></p>';\n            }\n          }\n        },\n        series: seriesData\n      }; // this.options.toolbox = toolbox\n\n      if (dataZoom) {\n        this.options.dataZoom = dataZoom;\n      } // toolbox datazoom变了在触发 TODO\n\n\n      this.$nextTick(function () {\n        _this.$refs.chart && _this.$refs.chart.dispatchAction({\n          type: 'restore'\n        });\n      });\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/ECharts/Line.vue?vue&type=script&lang=js&\n /* harmony default export */ var ECharts_Linevue_type_script_lang_js_ = (Linevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/ECharts/Line.vue?vue&type=style&index=0&id=6452f13c&scoped=true&lang=css&\nvar Linevue_type_style_index_0_id_6452f13c_scoped_true_lang_css_ = __webpack_require__(\"6940\");\n\n// EXTERNAL MODULE: ./node_modules/@vue/cli-service/node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(\"0c7c\");\n\n// CONCATENATED MODULE: ./src/components/ECharts/Line.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  ECharts_Linevue_type_script_lang_js_,\n  Linevue_type_template_id_6452f13c_scoped_true_render,\n  Linevue_type_template_id_6452f13c_scoped_true_staticRenderFns,\n  false,\n  null,\n  \"6452f13c\",\n  null\n  \n)\n\n/* harmony default export */ var Line = (component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/@vue/cli-service/node_modules/vue-loader/lib??vue-loader-options!./src/views/teacher/sell/Dashboard.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n // import { getDaysBetweenDates } from '@/utils/util'\n\n\n\n/* harmony default export */ var Dashboardvue_type_script_lang_js_ = ({\n  name: 'TeacherSellDashboard',\n  components: {\n    ELine: Line\n  },\n  data: function data() {\n    return {\n      loading: false,\n      DATERANGE_FOR_CHARTS: DATERANGE_FOR_CHARTS,\n      typeOptions: Object.values(common[\"J\" /* STATISTICS_TYPE */]),\n      duringOptions: DURING_TYPE,\n      filterParams: {\n        statisticsType: 1,\n        duringsType: 1,\n        during: [moment_default()().startOf('month').startOf('day'), moment_default()().endOf('day')]\n      },\n      dataSource: [{\n        name: 'line',\n        type: 'line',\n        symbol: 'none',\n        smooth: true,\n        data: []\n      }],\n      sum: 0\n    };\n  },\n  created: function created() {\n    this.init();\n  },\n  computed: {\n    title: function title() {\n      var _this = this;\n\n      var typeObj = this.typeOptions.find(function (item) {\n        return item.value === _this.filterParams.statisticsType;\n      });\n\n      if (this.filterParams.duringsType !== 7) {\n        var key = this.duringOptions.find(function (item) {\n          return item.value === _this.filterParams.duringsType;\n        }).label; // during = DATERANGE_FOR_CHARTS[key]\n\n        return key.toUpperCase() + ' ' + (typeObj ? typeObj.label.toUpperCase() : '');\n      } else {\n        var during = this.filterParams.during;\n\n        if (during.length === 2) {\n          var _during = Object(slicedToArray[\"a\" /* default */])(during, 2),\n              start = _during[0],\n              end = _during[1];\n\n          return start.format('MM/DD/YY') + ' - ' + end.format('MM/DD/YY') + ' ' + (typeObj ? typeObj.label.toUpperCase() : '');\n        }\n      }\n\n      return ' - ';\n    }\n  },\n  methods: {\n    init: function init() {\n      this.initChart();\n    },\n    initChart: function initChart() {\n      var _this2 = this;\n\n      // const dateRange = getDaysBetweenDates(...this.filterParams.during)\n      // this.dataSource[0].data = []\n      // dateRange.forEach(date => {\n      //   this.dataSource[0].data.push({\n      //     date: date,\n      //     value: Math.random() * 1000\n      //   })\n      // })\n      var params = {\n        duringsType: this.filterParams.duringsType,\n        statisticsType: this.filterParams.statisticsType,\n        startTime: this.filterParams.during[0].startOf('day').format('YYYY-MM-DD HH:mm:ss'),\n        endTime: this.filterParams.during[1].endOf('day').format('YYYY-MM-DD HH:mm:ss')\n      };\n      this.loading = true;\n      Object(statistics[\"a\" /* dashboard */])(params).then(function (res) {\n        if (res && res.success) {\n          _this2.sum = res.result.sum;\n          _this2.dataSource[0].data = _this2.convertAxis(res.result.data);\n        }\n      }).finally(function () {\n        _this2.loading = false;\n      });\n    },\n    convertAxis: function convertAxis(data) {\n      var WEEK = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; // const MONTH = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']\n\n      var datasource = Object(toConsumableArray[\"a\" /* default */])(data);\n\n      if (this.filterParams.duringsType === 1) {\n        datasource = datasource.map(function (item) {\n          return {\n            date: moment_default()(item.date).format('HH:mm'),\n            value: item.value\n          };\n        });\n      } else if (this.filterParams.duringsType === 2) {\n        datasource = datasource.map(function (item) {\n          return {\n            date: WEEK[moment_default()(item.date).day()],\n            value: item.value\n          };\n        }); // } else if (this.filterParams.duringsType === 5) {\n        //   const _data = datasource.map(item => {\n        //     return {\n        //       date: MONTH[moment(item.date).month()],\n        //       value: item.value\n        //     }\n        //   })\n        //   datasource = []\n        //   _data.forEach(item => {\n        //     const findItem = datasource.find(_ => _.date === item.date)\n        //     if (findItem) {\n        //       findItem.value += item.value\n        //     } else {\n        //       datasource.push({\n        //         ...item\n        //       })\n        //     }\n        //   })\n      } else {\n        datasource = datasource.map(function (item) {\n          return {\n            date: item.date.split(' ')[0],\n            value: item.value\n          };\n        });\n      }\n\n      return datasource;\n    },\n    changeTab: function changeTab(key) {},\n    onChangeDate: function onChangeDate(dates, dateStrings) {\n      this.triggerSearch();\n    },\n    triggerSearch: function triggerSearch() {\n      this.init();\n    },\n    formatSum: function formatSum(sum) {\n      if (this.filterParams.statisticsType === common[\"J\" /* STATISTICS_TYPE */].EARNINGS.value) {\n        return '$' + this.$options.filters['percentFormat'](sum);\n      } else if (this.filterParams.statisticsType === common[\"J\" /* STATISTICS_TYPE */].CONVERSIONS.value) {\n        return this.$options.filters['percentFormat'](sum) + '%';\n      } else {\n        return parseInt(sum);\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/views/teacher/sell/Dashboard.vue?vue&type=script&lang=js&\n /* harmony default export */ var sell_Dashboardvue_type_script_lang_js_ = (Dashboardvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/views/teacher/sell/Dashboard.vue?vue&type=style&index=0&id=9d71548a&scoped=true&lang=less&\nvar Dashboardvue_type_style_index_0_id_9d71548a_scoped_true_lang_less_ = __webpack_require__(\"4a4b\");\n\n// CONCATENATED MODULE: ./src/views/teacher/sell/Dashboard.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar Dashboard_component = Object(componentNormalizer[\"a\" /* default */])(\n  sell_Dashboardvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"9d71548a\",\n  null\n  \n)\n\n/* harmony default export */ var Dashboard = __webpack_exports__[\"default\"] = (Dashboard_component.exports);\n\n//# sourceURL=webpack:///./src/views/teacher/sell/Dashboard.vue_+_19_modules?")},eb52:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/views/teacher/sell/Dashboard.vue?./node_modules/mini-css-extract-plugin/dist/loader.js??ref--10-oneOf-1-0!./node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--10-oneOf-1-1!./node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--10-oneOf-1-2!./node_modules/less-loader/dist/cjs.js??ref--10-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/@vue/cli-service/node_modules/vue-loader/lib??vue-loader-options")},ef6a:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return sliderMove; });\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param delta Move length.\n * @param handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param handleIndex Can be \'all\', means that both move the two handleEnds.\n * @param minSpan The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param maxSpan The range of dataZoom can not be larger than that.\n * @return The input handleEnds.\n */\nfunction sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === \'all\') {\n    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleSpan = restrict(handleSpan, [0, extentSpan]);\n    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);\n    handleIndex = 0;\n  }\n\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign;\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, \'cross\' is forbidden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));\n}\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/component/helper/sliderMove.js?')},fdde:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return dataSample; });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("6d8b");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(max) ? max : NaN;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(min) ? min : NaN;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame) {\n  return Math.round(frame.length / 2);\n};\n\nfunction dataSample(seriesType) {\n  return {\n    seriesType: seriesType,\n    // FIXME:TS never used, so comment it\n    // modifyOutputEnd: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get(\'sampling\');\n      var coordSys = seriesModel.coordinateSystem;\n      var count = data.count(); // Only cartesian2d support down sampling. Disable it when there is few data.\n\n      if (count > 10 && coordSys.type === \'cartesian2d\' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent();\n        var dpr = api.getDevicePixelRatio(); // Coordinste system has been resized\n\n        var size = Math.abs(extent[1] - extent[0]) * (dpr || 1);\n        var rate = Math.round(count / size);\n\n        if (isFinite(rate) && rate > 1) {\n          if (sampling === \'lttb\') {\n            seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis.dim), 1 / rate));\n          }\n\n          var sampler = void 0;\n\n          if (Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__[/* isString */ "A"])(sampling)) {\n            sampler = samplers[sampling];\n          } else if (Object(zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__[/* isFunction */ "v"])(sampling)) {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            // Only support sample the first dim mapped from value axis.\n            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/echarts/lib/processor/dataSample.js?')}}]);